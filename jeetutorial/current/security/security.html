<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Jakarta Security :: Jakarta EE Documentation</title>
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
    <script>!function (theme) {
        if (theme === 'dark') document.documentElement.classList.add('theme-dark')
      }(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)') && 'dark'))
    </script>
      </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a id="site-title" class="navbar-item" href="../../..">Jakarta EE Documentation</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
<!--
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
 -->
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="../../../jakartaee-tutorial/10/jakarta-ee-tutorial.pdf">Download</a>
          </span>
        </div>
      </div>
      <div class="navbar-theme-switcher">
        <span class="switch" title="Switch between Light and Dark Theme">
          <input id="theme-switcher-checkbox" type="checkbox" />
          <label for="theme-switcher-checkbox">Dark Theme</label>
        </span>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="jakartaee-tutorial" data-version="10">
  <div class="toolbar"></div>
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Jakarta EE Tutorial</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Introduction</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../intro/overview/overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../intro/usingexamples/usingexamples.html">Using the Tutorial Examples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Platform Basics</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../platform/resource-creation/resource-creation.html">Resource Creation</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../platform/injection/injection.html">Injection</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../platform/packaging/packaging.html">Packaging</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Core Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta CDI Lite</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../cdi/cdi-basic/cdi-basic.html">Introduction to Jakarta Contexts and Dependency Injection</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../cdi/cdi-basicexamples/cdi-basicexamples.html">Running the Basic Contexts and Dependency Injection Examples</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../supporttechs/interceptors/interceptors.html">Using Jakarta EE Interceptors</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta REST</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../websvcs/jaxrs/jaxrs.html">Building RESTful Web Services with Jakarta REST</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../websvcs/jaxrs-client/jaxrs-client.html">Accessing REST Resources with the Jakarta REST Client API</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../websvcs/jaxrs-advanced/jaxrs-advanced.html">Jakarta REST: Advanced Topics and an Example</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta JSON</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/jsonb/jsonb.html">JSON Binding</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/jsonp/jsonp.html">JSON Processing</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Web Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta CDI Full</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../cdi/cdi-adv/cdi-adv.html">Jakarta Contexts and Dependency Injection: Advanced Topics</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../cdi/cdi-bootstrap-se8/cdi-bootstrap-se8.html">Bootstrapping a CDI Container in Java SE</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../cdi/cdi-adv-examples/cdi-adv-examples.html">Running the Advanced Contexts and Dependency Injection Examples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Validation</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../beanvalidation/bean-validation/bean-validation.html">Introduction to Jakarta Bean Validation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../beanvalidation/bean-validation-advanced/bean-validation-advanced.html">Bean Validation: Advanced Topics</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="security.html">Jakarta Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Servlets</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/webapp/webapp.html">Getting Started with Web Applications</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/servlets/servlets.html">Jakarta Servlet</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Faces</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/faces-intro/faces-intro.html">Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/faces-facelets/faces-facelets.html">Introduction to Facelets</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/faces-page/faces-page.html">Using Jakarta Faces Technology in Web Pages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/faces-page-core/faces-page-core.html">Using Converters, Listeners, and Validators</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/faces-develop/faces-develop.html">Developing with Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/faces-ajax/faces-ajax.html">Using Ajax with Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/faces-advanced-cc/faces-advanced-cc.html">Composite Components: Advanced Topics and an Example</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/faces-custom/faces-custom.html">Creating Custom UI Components and Other Custom Objects</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/faces-configure/faces-configure.html">Configuring Jakarta Faces Applications</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/faces-ws/faces-ws.html">Using WebSockets with Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/webi18n/webi18n.html">Internationalizing and Localizing Web Applications</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../web/websocket/websocket.html">Jakarta WebSocket</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Persistence</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../persist/persistence-intro/persistence-intro.html">Introduction to Jakarta Persistence</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../persist/persistence-basicexamples/persistence-basicexamples.html">Running the Persistence Examples</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../persist/persistence-querylanguage/persistence-querylanguage.html">The Jakarta Persistence Query Language</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../persist/persistence-criteria/persistence-criteria.html">Using the Criteria API to Create Queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../persist/persistence-string-queries/persistence-string-queries.html">Creating and Using String-Based Criteria Queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../persist/persistence-locking/persistence-locking.html">Controlling Concurrent Access to Entity Data with Locking</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../persist/persistence-entitygraphs/persistence-entitygraphs.html">Creating Fetch Plans with Entity Graphs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../persist/persistence-cache/persistence-cache.html">Using a Second-Level Cache with Jakarta Persistence Applications</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Enterprise Beans Lite</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../entbeans/ejb-intro/ejb-intro.html">Enterprise Beans</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../entbeans/ejb-gettingstarted/ejb-gettingstarted.html">Getting Started with Enterprise Beans</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../entbeans/ejb-basicexamples/ejb-basicexamples.html">Running the Enterprise Bean Examples</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../entbeans/ejb-async/ejb-async.html">Using Asynchronous Method Invocation in Session Beans</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Platform</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../messaging/mail-api/mail-api.html">Jakarta Mail</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Messaging</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../messaging/jms-concepts/jms-concepts.html">Jakarta Messaging Concepts</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../messaging/jms-examples/jms-examples.html">Jakarta Messaging Examples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../supporttechs/batch-processing/batch-processing.html">Jakarta Batch</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Advanced</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Web Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="security-authentication/security-authentication.html">Jakarta Authentication</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="security-authorization/security-authorization.html">Jakarta Authorization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../supporttechs/transactions/transactions.html">Jakarta Transactions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../supporttechs/concurrency-utilities/concurrency-utilities.html">Jakarta Concurrency</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Platform</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../supporttechs/connectors/connectors.html">Jakarta Connectors</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Optional Components</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/faces-el/faces-el.html">Jakarta Expression Language</a>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Jakarta XML Binding</span>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Archived</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Web Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/jakarta-pages/jakarta-pages.html">Jakarta Pages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../web/jakarta-tags/jakarta-tags.html">Jakarta Tags</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Platform</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../websvcs/xml-websvcs/xml-websvcs.html">XML Web Services</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../entbeans/ejb-full/ejb-full.html">Jakarta Enterprise Beans Full</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Jakarta EE Tutorial</span>
    <span class="version">10</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Jakarta EE Tutorial</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">10</a>
        </li>
        <li class="version">
          <a href="../../9.1/index.html">9.1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Jakarta EE Tutorial</a></li>
    <li>Jakarta EE Web Profile</li>
    <li><a href="security.html">Jakarta Security</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">10</button>
  <div class="version-menu">
    <a class="version is-current" href="security.html">10</a>
    <a class="version is-missing" href="../../9.1/index.html">9.1</a>
  </div>
</div>
  <div class="edit-this-page"><a href="file:///home/john/workspace/virtua/jakartaee-tutorial/src/main/antora/modules/security/pages/security.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Jakarta Security</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Jakarta Security is the overarching security API in Jakarta EE. Overarching here means that it strives to address the security needs of all other APIs in Jakarta EE in a holistic way.</p>
</div>
<div class="paragraph">
<p>Due to historical and political reasons, a number of security features are still distributed among several other APIs in Jakarta EE. Sometimes they overlap, and sometimes such features are only accessible from these other APIs. In this chapter, we&#8217;ll focus primarily on explaining Jakarta Security, but we&#8217;ll mention when other APIs are needed to accomplish a certain task.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_overview"><a class="anchor" href="#_overview"></a>Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before we look at some practical examples, let&#8217;s quickly go through some basics.</p>
</div>
<div class="paragraph">
<p>Some of the guiding principles in Jakarta Security are:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It should work directly out of the box, without requiring vendor-specific configuration.</p>
</li>
<li>
<p>It leverages Jakarta CDI as much as possible. Most artifacts are CDI beans, and many features are done via CDI interceptors.</p>
</li>
<li>
<p>The difference between framework-provided artifacts and custom (user provided) artifacts is minimal or non-existent.</p>
</li>
<li>
<p>It fully integrates with security features from other Jakarta EE APIs and proprietary (vendor-specific) artifacts.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Jakarta Security defines several distinct artifacts that play an important role in the security process:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/security/3.0/jakarta-security-spec-3.0.html#authentication-mechanism" class="external" target="_blank" rel="noopener">Authentication Mechanism</a></p>
</li>
<li>
<p><a href="https://jakarta.ee/specifications/security/3.0/jakarta-security-spec-3.0.html#identity-store" class="external" target="_blank" rel="noopener">Identity Store</a></p>
</li>
<li>
<p>Permission Store</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The first two of these are used in the authentication process:</p>
</div>
<div class="paragraph">
<p>An <em>authentication mechanism</em> is somewhat like a controller in the well-known <a href="https://en.wikipedia.org/wiki/Model–view–controller" class="external" target="_blank" rel="noopener">MVC</a> pattern; it is the entity that interacts with the caller (typically a human), via some kind of view to collect credentials, and with the model (business logic) to validate <code>these</code> credentials. An authentication mechanism knows about the environment this caller uses to communicate with the server. An authentication mechanism for HTTP knows about URLs to redirect or forward to, or about response headers to send to the client. It also knows about the data coming back, such as cookies, request headers, and post data. Examples of authentication mechanisms are Form authentication and Basic authentication.</p>
</div>
<div class="paragraph">
<p>An <em>identity store</em> is more like the model in the MVC pattern. This entity strictly performs a business / data operation where credentials go in, and an identity comes out. The identity contains logic to validate said credentials, and embeds or contacts a database. This "database" contains usernames, along with their credentials and (typically) roles. An identity store therefore knows nothing about the environment that this caller uses to communicate with the server; for example, it doesn&#8217;t know about HTTP or headers and more.
Some examples of identity stores are services that contact SQL or NoSQL databases, LDAP servers, files on the file-system, and more.</p>
</div>
<div class="paragraph">
<p><a href="#_mechanism_store_in_mvc">Figure 1, &#8220;Mechanism Store in MVC&#8221;</a> shows the <em>authentication mechanism</em> and <em>identity store</em> in an MVC-like structure.</p>
</div>
<div id="_mechanism_store_in_mvc" class="imageblock">
<div class="content">
<img src="_images/authentication-mvc.svg" alt="Diagram illustrating the role of the authentication mechanism and identity store in an MVC like structure">
</div>
<div class="title">Figure 1. Mechanism Store in MVC</div>
</div>
<div class="paragraph">
<p>The third one is used for the authorization process:</p>
</div>
<div class="paragraph">
<p>A <em>permission store</em> is another kind of model that stores permissions, typically either globally, or per role (role-based permissions). This entity then performs a business / data operation where a query and an identity go in, and a yes/no answer goes out. For instance, a query such as "can access /foo/bar?" along with the identity for user "John" with roles "bar" and "kaz" would return "yes" if that identity is authorized to access "/foo/bar", and "no" if not authorized.
Examples of permission stores are the Jakarta Authorization usage of the Policy class, or the internal data structure where a Servlet Container such as Tomcat or Jetty stores the security constraints an application defined.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_provided_authentication_mechanisms_and_identity_stores"><a class="anchor" href="#_provided_authentication_mechanisms_and_identity_stores"></a>Provided authentication mechanisms and identity stores</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jakarta Security provides a number of built-in authentication mechanisms and identity stores. We&#8217;ll enumerate them here first, and will look at them in more detail below.</p>
</div>
<div class="paragraph">
<p>Authentication mechanisms:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/security/3.0/jakarta-security-spec-3.0.html#basic-annotation" class="external" target="_blank" rel="noopener">Basic</a></p>
</li>
<li>
<p><a href="https://jakarta.ee/specifications/security/3.0/jakarta-security-spec-3.0.html#form-annotation" class="external" target="_blank" rel="noopener">Form</a></p>
</li>
<li>
<p><a href="https://jakarta.ee/specifications/security/3.0/jakarta-security-spec-3.0.html#custom-form-annotation" class="external" target="_blank" rel="noopener">Custom Form</a></p>
</li>
<li>
<p><a href="https://jakarta.ee/specifications/security/3.0/jakarta-security-spec-3.0.html#openid-connect-annotation" class="external" target="_blank" rel="noopener">Open ID Connect (OIDC)</a></p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Identity stores:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/security/3.0/jakarta-security-spec-3.0.html#database-annotation" class="external" target="_blank" rel="noopener">Database</a></p>
</li>
<li>
<p><a href="https://jakarta.ee/specifications/security/3.0/jakarta-security-spec-3.0.html#ldap-annotation" class="external" target="_blank" rel="noopener">LDAP</a></p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_custom_authentication_mechanisms_and_identity_stores"><a class="anchor" href="#_custom_authentication_mechanisms_and_identity_stores"></a>Custom authentication mechanisms and identity stores</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When the provided authentication mechanisms and identity stores aren&#8217;t sufficient, we can easily define custom ones. Both provided and custom ones use <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/identitystore" class="external" target="_blank" rel="noopener">the same interfaces</a>, and the system doesn&#8217;t distinguish between them.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_authentication_mechanisms_and_identity_stores_from_other_apis"><a class="anchor" href="#_authentication_mechanisms_and_identity_stores_from_other_apis"></a>Authentication mechanisms and identity stores from other APIs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html" class="external" target="_blank" rel="noopener">Servlet specification</a> defines the exact same <a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#form-based-authentication" class="external" target="_blank" rel="noopener">Form</a> and <a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#http-basic-authentication" class="external" target="_blank" rel="noopener">Basic</a> authentication mechanisms. Authenticating with them will have the same result as authenticating with a Jakarta Security authentication mechanism. (Role checks will work the same independent on which API was used to authenticate.)</p>
</div>
<div class="paragraph">
<p>A Servlet authentication mechanism, however, will not necessarily consult a Jakarta Security identity store. This is server dependent. The identity store that is called is server dependent as well. Calling this server-dependent identity store is possible from Jakarta Security, but as an advanced feature.</p>
</div>
<div class="paragraph">
<p>Likewise, programmatic role checks can be done from various APIs, including Jakarta Security, Jakarta REST, and Jakarta Servlet. These all return the same outcome, independent of whether authentication took place with a Jakarta Security Authentication Mechanism or a Servlet Authentication Mechanism. Within a Jakarta EE environment the usage of Jakarta Security for this is encouraged, and the usage of those other APIs is discouraged.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Programmatic role checks in Jakarta REST, Jakarta Servlet and various other APIs are not being deprecated for the time being, as those APIs are also used stand-alone (outside Jakarta EE). Future versions of those APIs may contain warnings about their usage within Jakarta EE.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_securing_an_endpoint_with_basic_authentication"><a class="anchor" href="#_securing_an_endpoint_with_basic_authentication"></a>Securing an endpoint with Basic authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the following example, we&#8217;ll be securing a REST endpoint using Basic authentication.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll learn how to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#specifying-security-constraints" class="external" target="_blank" rel="noopener">Define security constraints</a></p>
</li>
<li>
<p>Set a provided authentication mechanism</p>
</li>
<li>
<p>Define (and implicitly set) a custom identity store</p>
</li>
<li>
<p>Use the Jakarta Security <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a></p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_write_the_application"><a class="anchor" href="#_write_the_application"></a>Write the application</h3>
<div class="paragraph">
<p>Let&#8217;s start with defining a simple REST resource class for a <code>/rest/resource</code> endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/resource")
@RequestScoped
public class Resource {

    @Inject
    private SecurityContext securityContext;

    @GET
    @Produces(TEXT_PLAIN)
    public String getCallerAndRole() {
        return
            securityContext.getCallerPrincipal().getName() + " : " +
            securityContext.isCallerInRole("user");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This resource uses the injected Jakarta EE <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> to obtain access to the current authenticated caller, which is represented by a <code>Principal</code> instance.</p>
</div>
<div class="paragraph">
<p>If this resource were available to unauthenticated callers, <code>getCallerPrincipal()</code> would return <code>null</code> for unauthenticated requests, so we&#8217;d have to check for <code>null</code>. Our example, however, requires authentication for this resource, so we can skip that check.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a Jakarta REST-specific type that is also named <a href="https://jakarta.ee/specifications/restful-ws/3.1/apidocs/jakarta.ws.rs/jakarta/ws/rs/core/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> and has similar methods as the ones we used here. From the Jakarta EE perspective, that is a discouraged type and the Jakarta Security version is to be preferred.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_declare_the_security_constraints"><a class="anchor" href="#_declare_the_security_constraints"></a>Declare the security constraints</h4>
<div class="paragraph">
<p>Next we&#8217;ll define the security constraints in <code>web.xml</code>, which tell the security system that access to a given URL or URL pattern is protected, and hence authentication is required:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="6.0"
    xmlns="https://jakarta.ee/xml/ns/jakartaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"&gt;

    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;protected&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;user&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
    &lt;/security-constraint&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This XML essentially says that to access any URL that starts with "/rest" requires the caller to have the role "user". Roles are opaque strings; merely identifiers. It&#8217;s fully up to the application how broad or fine-grained they are.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In Jakarta EE, internally these XML constraints are transformed into <code>Permission</code> instances and made available via a specific type of permission store. Knowledge about this transformation is only needed for very advanced use cases.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The observant reader may wonder if XML is really the only option here, given the strong feelings that exist in parts of the community around XML. The answer is yes and no. Jakarta EE does define the <a href="https://jakarta.ee/specifications/annotations/2.1/annotations-spec-2.1.html#jakarta-annotation-security-rolesallowed" class="external" target="_blank" rel="noopener">@RolesAllowed</a> annotation that could be used to replace the XML shown above, but only the legacy Enterprise Beans has specified a behaviour for this when put on an Enterprise Bean. Jakarta REST has done no such thing, although the <a href="https://microprofile.io/project/eclipse/microprofile-jwt-auth/spec/src/main/asciidoc/configuration.asciidoc" class="external" target="_blank" rel="noopener">JWT API in MicroProfile</a> has defined this for REST resources. In Jakarta EE, however, this remains a vendor-specific extension. There are also a number of <a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#programmatic-security-policy-configuration" class="external" target="_blank" rel="noopener">annotations and APIs</a> in Jakarta EE to set these kinds of constraints for individual Servlets, but those won&#8217;t help us much either here.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_declare_the_authentication_mechanism"><a class="anchor" href="#_declare_the_authentication_mechanism"></a>Declare the authentication mechanism</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@BasicAuthenticationMechanismDefinition(realmName = "basicAuth")
@DeclareRoles({ "user", "caller" })
@ApplicationPath("/rest")
public class ApplicationConfig extends Application {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To declare the usage of a specific authentication mechanism, Jakarta EE provides <code>[XYZ]MechanismDefinition</code> annotations. Such an annotation is picked up by the security system, and in response to it a CDI bean that implements the <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/httpauthenticationmechanism" class="external" target="_blank" rel="noopener">HttpAuthenticationMechanism</a> is enabled for it.</p>
</div>
<div class="paragraph">
<p>The annotation can be put on any bean, but in a REST application it fits particularly well on the <code>Application</code> subclass because it also declares the path for REST resources.</p>
</div>
</div>
<div class="sect3">
<h4 id="_define_the_identity_store"><a class="anchor" href="#_define_the_identity_store"></a>Define the identity store</h4>
<div class="paragraph">
<p>Finally, let&#8217;s define a simple identity store that the security system can use to validate provided credentials for Basic authentication:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class TestIdentityStore implements IdentityStore {

    public CredentialValidationResult validate(UsernamePasswordCredential usernamePasswordCredential) {
        if (usernamePasswordCredential.compareTo("john", "secret1")) {
            return new CredentialValidationResult("john", Set.of("user", "caller"));
        }

        return INVALID_RESULT;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This identity store only validates the single identity (user) "john", with password "secret1" and roles "user" and "caller". Defining this kind of identity store is often the simplest way to get started.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Jakarta Security doesn&#8217;t provide a simple identity store out of the box. The reason is that everything in Jakarta Security promotes best practices, and it&#8217;s not clear if a simple identity store fits in with those best practices.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The identity store is installed and used by the security system just by the virtue of being there; it picks up all enabled CDI beans that implement <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/identitystore" class="external" target="_blank" rel="noopener">IdentityStore</a>. Such beans can be enabled by the security system itself (following some configuration annotation), or can be programmatically added using the appropriate CDI APIs. Where the bean comes from doesn&#8217;t matter for Jakarta Security, only the fact that it&#8217;s there.</p>
</div>
</div>
<div class="sect3">
<h4 id="_test_the_application"><a class="anchor" href="#_test_the_application"></a>Test the application</h4>
<div class="paragraph">
<p>It&#8217;s now time to test our application. A ready-to-test version is available from the Jakarta EE Examples project at <a href="https://github.com/eclipse-ee4j/jakartaee-examples" class="bare">https://github.com/eclipse-ee4j/jakartaee-examples</a>.</p>
</div>
<div class="paragraph">
<p>Download or clone this repo, then cd into the <code>focused</code> folder and execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">mvn clean install -pl :restBasicAuthCustomStore</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will run a test associated with the project, printing something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">john : true
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 6.414 s - in jakartaee.examples.focused.security.restbasicauthcustomstore.RestBasicAuthCustomStoreIT</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s take a quick look at the actual test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(Arquillian.class)
@RunAsClient
public class RestBasicAuthCustomStoreIT extends ITBase {

    /**
     * Stores the base URL.
     */
    @ArquillianResource
    private URL baseUrl;

    /**
     * Test the call to a protected REST service
     *
     * @throws Exception when a serious error occurs.
     */
    @RunAsClient
    @Test
    public void testRestCall() throws Exception {
        DefaultCredentialsProvider credentialsProvider = new DefaultCredentialsProvider();
        credentialsProvider.addCredentials("john", "secret1");

        webClient.setCredentialsProvider(credentialsProvider);

        TextPage page = webClient.getPage(baseUrl + "/rest/resource");
        String content = page.getContent();

        System.out.println(content);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The test starts a server and deploys the output of the build process (a .war file) to it. The test runs in the integration test phase, rather than the unit test phase, to make sure this build output is available when it runs. The test then sends a request to the server using the provided HtmlUnit <code>webClient</code>. Note that the <code>webClient</code> can be used for any other HTTP requests your test requires.</p>
</div>
<div class="paragraph">
<p>If you want to inspect the app yourself, you can manually deploy the WAR file (<code>security/restBasicAuthCustomStore/target/restBasicAuthCustomStore.war</code>) to the server of your choice (e.g. <a href="https://projects.eclipse.org/projects/ee4j.glassfish" class="external" target="_blank" rel="noopener">GlassFish 7</a>), and request the URL via a browser or a commandline util such as <code>curl</code>.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultCredentialsProvider</code> used here makes sure that the headers for Basic authentication are added to the request. The Basic authentication mechanism that we defined for our applications reads those headers, extracts the username and password from them, and consults our identity store with them.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_securing_an_endpoint_with_basic_authentication_and_a_database_identity_store"><a class="anchor" href="#_securing_an_endpoint_with_basic_authentication_and_a_database_identity_store"></a>Securing an endpoint with Basic authentication and a database identity store</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the following example, we&#8217;ll secure a REST endpoint using Basic authentication and the database identity store that is provided by Jakarta Security.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll learn how to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#specifying-security-constraints" class="external" target="_blank" rel="noopener">Define security constraints</a></p>
</li>
<li>
<p>Use the provided <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/basicauthenticationmechanismdefinition" class="external" target="_blank" rel="noopener">BasicAuthenticationMechanismDefinition</a></p>
</li>
<li>
<p>Use the provided <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/databaseidentitystoredefinition" class="external" target="_blank" rel="noopener">DatabaseIdentityStoreDefinition</a></p>
</li>
<li>
<p>Populate and configure the identity store</p>
</li>
<li>
<p>Use the Jakarta Security <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a></p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_write_the_application_2"><a class="anchor" href="#_write_the_application_2"></a>Write the application</h3>
<div class="paragraph">
<p>Let&#8217;s start with defining a simple REST resource class for a <code>/rest/resource</code> endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/resource")
@RequestScoped
public class Resource {

    @Inject
    private SecurityContext securityContext;

    @GET
    @Produces(TEXT_PLAIN)
    public String getCallerAndRole() {
        return
            securityContext.getCallerPrincipal().getName() + " : " +
            securityContext.isCallerInRole("user");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This resource uses the injected Jakarta EE <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> to obtain access to the current authenticated caller, which is represented by a <code>Principal</code> instance.</p>
</div>
<div class="paragraph">
<p>If this resource were available to unauthenticated callers, <code>getCallerPrincipal()</code> would return <code>null</code> for unauthenticated requests, so we&#8217;d have to check for <code>null</code>. Our example, however, requires authentication for this resource, so we can skip that check.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a Jakarta REST-specific type that is also named <a href="https://jakarta.ee/specifications/restful-ws/3.1/apidocs/jakarta.ws.rs/jakarta/ws/rs/core/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> and has similar methods as the ones we used here. From the Jakarta EE perspective, that is a discouraged type and the Jakarta Security version is to be preferred.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_declare_the_authentication_mechanism_and_identity_store"><a class="anchor" href="#_declare_the_authentication_mechanism_and_identity_store"></a>Declare the authentication mechanism and identity store</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@BasicAuthenticationMechanismDefinition(
    realmName = "basicAuth"
)
@DatabaseIdentityStoreDefinition(
    callerQuery = "select password from basic_auth_user where username = ?",
    groupsQuery = "select name from basic_auth_group where username = ?",
    hashAlgorithmParameters = {
        "Pbkdf2PasswordHash.Iterations=3072",
        "Pbkdf2PasswordHash.Algorithm=PBKDF2WithHmacSHA512",
        "Pbkdf2PasswordHash.SaltSizeBytes=64"
    }
)
@DeclareRoles("user")
@ApplicationPath("/rest")
public class ApplicationConfig extends Application {</code></pre>
</div>
</div>
<div class="paragraph">
<p>To declare the usage of a specific authentication mechanism, Jakarta EE provides <code>[XYZ]MechanismDefinition</code> annotations. Such an annotation is picked up by the security system, and in response to it a CDI bean that implements the <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/httpauthenticationmechanism" class="external" target="_blank" rel="noopener">HttpAuthenticationMechanism</a> is enabled for it.</p>
</div>
<div class="paragraph">
<p>The annotation can be put on any bean, but in a REST application it fits particularly well on the <code>Application</code> subclass because it also declares the path for REST resources.</p>
</div>
<div class="paragraph">
<p>Likewise, to declare the usage of a specific identity store, Jakarta EE provides <code>[XYZ]StoreDefinition</code> annotations.</p>
</div>
<div class="paragraph">
<p>The annotations can be put on any bean, but in a REST application it fits particularly well on the <code>Application</code> subclass that also declares the path for REST resources.</p>
</div>
<div class="paragraph">
<p>You can use the provided <code>DatabaseIdentityStoreDefinition</code> with any authentication mechanism that validates username/password credentials. It requires at least two SQL queries:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A query that returns a password for the username part of credentials. The returned password is compared with the password part of those credentials. If they match (of more typically, their hashes match) the credential is considered valid.</p>
</li>
<li>
<p>A query that returns a number of roles given that same username part of the credentials</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Although not required, it&#8217;s a good practice to provide some parameters for the hash algorithm. Passwords should never be stored in plain-text in a database.</p>
</div>
</div>
<div class="sect3">
<h4 id="_populating_the_identity_store"><a class="anchor" href="#_populating_the_identity_store"></a>Populating the identity store</h4>
<div class="paragraph">
<p>In order to use the identity store, we need to put some data in a database. The following code shows one way how to do that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@BasicAuthenticationMechanismDefinition(
    realmName = "basicAuth"
)
@DatabaseIdentityStoreDefinition(
    callerQuery = "select password from basic_auth_user where username = ?",
    groupsQuery = "select name from basic_auth_group where username = ?",
    hashAlgorithmParameters = {
        "Pbkdf2PasswordHash.Iterations=3072",
        "Pbkdf2PasswordHash.Algorithm=PBKDF2WithHmacSHA512",
        "Pbkdf2PasswordHash.SaltSizeBytes=64"
    }
)
@DeclareRoles("user")
@ApplicationPath("/rest")
public class ApplicationConfig extends Application {

    /**
     * Id of the one and only user we populate in out DB.
     */
    private static final BigInteger USER_ID = ONE;

    /**
     * Id of the one and only group we populate in out DB.
     */
    private static final BigInteger GROUP_ID = ONE;

    @PersistenceContext
    private EntityManager entityManager;

    @Inject
    private Pbkdf2PasswordHash passwordHash;

    @Transactional
    public void onStart(@Observes @Initialized(ApplicationScoped.class) Object applicationContext) {
        passwordHash.initialize(Map.of(
            "Pbkdf2PasswordHash.Iterations", "3072",
            "Pbkdf2PasswordHash.Algorithm", "PBKDF2WithHmacSHA512",
            "Pbkdf2PasswordHash.SaltSizeBytes", "64"));

        if (entityManager.find(User.class, USER_ID) == null) {
            var user = new User();
            user.id  = USER_ID;
            user.username = "john";
            user.password = passwordHash.generate("secret1".toCharArray());
            entityManager.persist(user);
        }

        if (entityManager.find(Group.class, GROUP_ID) == null) {
            var group = new Group();
            group.id = GROUP_ID;
            group.name = "user";
            group.username = "john";
            entityManager.persist(group);
        }
    }

}

@Entity
@Table(name = "basic_auth_user")
class User {
    @Id
    BigInteger id;

    @Column(name = "password")
    String password;

    @Column(name = "username", unique = true)
    String username;
}

@Entity
@Table(name = "basic_auth_group")
class Group {
    @Column(name = "id")
    @Id
    BigInteger id;

    @Column(name = "name")
    String name;

    @Column(name = "username")
    String username;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code above uses Jakarta Persistence, which generates SQL from Java types. Jakarta Persistence is discussed in detail in its own chapter. Since we haven&#8217;t specified a datasource, the <code>@DatabaseIdentityStoreDefinition</code> annotation will use the default datasource defined in Jakarta EE, so you don&#8217;t have to explicitly install and configure an external database such as Postgres or MySQL. However, if necessary, you can configure a different one using the <code>dataSourceLookup</code> attribute.</p>
</div>
</div>
<div class="sect3">
<h4 id="_test_the_application_2"><a class="anchor" href="#_test_the_application_2"></a>Test the application</h4>
<div class="paragraph">
<p>It&#8217;s now time to test our application. A ready-to-test version is available from the Jakarta EE Examples project at <a href="https://github.com/eclipse-ee4j/jakartaee-examples" class="bare">https://github.com/eclipse-ee4j/jakartaee-examples</a>.</p>
</div>
<div class="paragraph">
<p>Download or clone this repo, then cd into the <code>focused</code> folder and execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">mvn clean install -pl :restBasicAuthDBStore</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will run a test associated with the project, printing something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">john : true
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 8.307 s - in jakartaee.examples.focused.security.restbasicauthdbstore.RestBasicAuthDBStoreIT</code></pre>
</div>
</div>
<div class="paragraph">
<p>The test itself is basically the same as that for the <a href="#_securing_an_endpoint_with_basic_authentication">Securing an endpoint with Basic authentication</a> example.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_securing_an_endpoint_with_basic_authentication_and_multiple_identity_stores"><a class="anchor" href="#_securing_an_endpoint_with_basic_authentication_and_multiple_identity_stores"></a>Securing an endpoint with Basic authentication and multiple identity stores</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the following example, we&#8217;ll be securing a REST endpoint using Basic authentication and two identity stores: the database identity store that is provided by Jakarta Security and a custom identity store.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll learn how to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#specifying-security-constraints" class="external" target="_blank" rel="noopener">Define security constraints</a></p>
</li>
<li>
<p>Use the provided <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/basicauthenticationmechanismdefinition" class="external" target="_blank" rel="noopener">BasicAuthenticationMechanismDefinition</a></p>
</li>
<li>
<p>Use the provided <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/databaseidentitystoredefinition" class="external" target="_blank" rel="noopener">DatabaseIdentityStoreDefinition</a></p>
</li>
<li>
<p>Create a custom <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/package-summary.html" class="external" target="_blank" rel="noopener">identity store</a></p>
</li>
<li>
<p>Use the Jakarta Security <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a></p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_write_the_application_3"><a class="anchor" href="#_write_the_application_3"></a>Write the application</h3>
<div class="paragraph">
<p>Let&#8217;s start with defining a simple REST resource class for a <code>/rest/resource</code> endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/resource")
@RequestScoped
public class Resource {

    @Inject
    private SecurityContext securityContext;

    @GET
    @Produces(TEXT_PLAIN)
    public String getCallerAndRole() {
        return
            securityContext.getCallerPrincipal().getName() + " : " +
            securityContext.isCallerInRole("user");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This resource uses the injected Jakarta EE <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> to obtain access to the current authenticated caller, which is represented by a <code>Principal</code> instance.</p>
</div>
<div class="paragraph">
<p>If this resource were available to unauthenticated callers, <code>getCallerPrincipal()</code> would return <code>null</code> for unauthenticated requests, so we&#8217;d have to check for <code>null</code>. Our example, however, requires authentication for this resource, so we can skip that check.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a Jakarta REST-specific type that is also named <a href="https://jakarta.ee/specifications/restful-ws/3.1/apidocs/jakarta.ws.rs/jakarta/ws/rs/core/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> and has similar methods as the ones we used here. From the Jakarta EE perspective, that is a discouraged type and the Jakarta Security version is to be preferred.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_declare_the_authentication_mechanism_and_identity_store_2"><a class="anchor" href="#_declare_the_authentication_mechanism_and_identity_store_2"></a>Declare the authentication mechanism and identity store</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@BasicAuthenticationMechanismDefinition(
    realmName = "basicAuth"
)
@DatabaseIdentityStoreDefinition(
    callerQuery = "select password from basic_auth_user where username = ?",
    groupsQuery = "select name from basic_auth_group where username = ?",
    hashAlgorithmParameters = {
        "Pbkdf2PasswordHash.Iterations=3072",
        "Pbkdf2PasswordHash.Algorithm=PBKDF2WithHmacSHA512",
        "Pbkdf2PasswordHash.SaltSizeBytes=64"
    }
)
@DeclareRoles("user")
@ApplicationPath("/rest")
public class ApplicationConfig extends Application {</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class CustomIdentityStore implements IdentityStore {

    public CredentialValidationResult validate(UsernamePasswordCredential usernamePasswordCredential) {
        if (usernamePasswordCredential.compareTo("pete", "secret2")) {
            return new CredentialValidationResult("pete", Set.of("user", "caller"));
        }

        return INVALID_RESULT;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example we have two enabled CDI beans implementing the <code>IdentityStore</code> interface. One of them will be implicitly enabled via the <code>@DatabaseIdentityStoreDefinition</code> annotation, while the other one is defined explicitly via the <code>CustomIdentityStore</code> class. As with a single identity store, it doesn&#8217;t matter how or where the CDI beans are defined, only that multiple enabled ones exist.</p>
</div>
<div class="paragraph">
<p>When multiple identity stores are present, the security system will try them in order of their priority. We didn&#8217;t set a priority here, so the order will be undefined. If the default validation algorithm is used, a successful validation wins over a failed validation. For example, let&#8217;s say we have multiple identity stores that know about the user "pete". If "pete" fails validation in one store, but passes validation in another store, the end result is still that validation passed.</p>
</div>
<div class="paragraph">
<p>In the two stores above, however only one store knows about "pete" and that&#8217;s the <code>CustomIdentityStore</code>. The store created from <code>@DatabaseIdentityStoreDefinition</code> doesn&#8217;t know about "pete" at all, and will simply not validate it.</p>
</div>
</div>
<div class="sect3">
<h4 id="_populating_the_identity_store_2"><a class="anchor" href="#_populating_the_identity_store_2"></a>Populating the identity store</h4>
<div class="paragraph">
<p>In order to use the identity store, we need to put some data in a database. This is done in the same as in <a href="#_securing_an_endpoint_with_basic_authentication_and_a_database_identity_store">Securing an endpoint with Basic authentication and a database identity store</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_test_the_application_3"><a class="anchor" href="#_test_the_application_3"></a>Test the application</h4>
<div class="paragraph">
<p>It&#8217;s now time to test our application. A ready-to-test version is available from the Jakarta EE Examples project at <a href="https://github.com/eclipse-ee4j/jakartaee-examples" class="bare">https://github.com/eclipse-ee4j/jakartaee-examples</a>.</p>
</div>
<div class="paragraph">
<p>Download or clone this repo, then cd into the <code>focused</code> folder and execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">mvn clean install -pl :restBasicAuthDBStoreAndCustomStore</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will run a test associated with the project, printing something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">john : true
pete : true
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 9.239 s - in jakartaee.examples.focused.security.restbasicauthdbstoreandcustomstore.RestBasicAuthDBStoreAndCustomStoreIT</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s take a quick look at the actual test again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(Arquillian.class)
@RunAsClient
public class RestBasicAuthDBStoreAndCustomStoreIT extends ITBase {

    @ArquillianResource
    private URL baseUrl;

    /**
     * Test the call to a protected REST service
     *
     * &lt;p&gt;
     * This will use the "john" credentials, which should be validated by the DB store
     *
     * @throws Exception when a serious error occurs.
     */
    @RunAsClient
    @Test
    public void testRestCall1() throws Exception {
        DefaultCredentialsProvider credentialsProvider = new DefaultCredentialsProvider();
        credentialsProvider.addCredentials("john", "secret1");

        webClient.setCredentialsProvider(credentialsProvider);

        TextPage page = webClient.getPage(baseUrl + "/rest/resource");
        String content = page.getContent();

        System.out.println(content);
    }

    /**
     * Test the call to a protected REST service
     *
     * &lt;p&gt;
     * This will use the "pete" credentials, which should be validated by the custom store
     *
     * @throws Exception when a serious error occurs.
     */
    @RunAsClient
    @Test
    public void testRestCall2() throws Exception {
        DefaultCredentialsProvider credentialsProvider = new DefaultCredentialsProvider();
        credentialsProvider.addCredentials("pete", "secret2");

        webClient.setCredentialsProvider(credentialsProvider);

        TextPage page = webClient.getPage(baseUrl + "/rest/resource");
        String content = page.getContent();

        System.out.println(content);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The test starts a server and deploys the output of the build process (a .war file) to it. The test runs in the integration test phase, rather than the unit test phase, to make sure this build output is available when it runs. The test then sends a request to the server using the provided HtmlUnit <code>webClient</code>. Note that the <code>webClient</code> can be used for any other HTTP requests your test requires.</p>
</div>
<div class="paragraph">
<p>If you want to inspect the app yourself, you can manually deploy the WAR file (<code>security/restBasicAuthDBStoreAndCustomStore/target/restBasicAuthDBStoreAndCustomStore.war</code>) to the server of your choice (e.g. <a href="https://projects.eclipse.org/projects/ee4j.glassfish" class="external" target="_blank" rel="noopener">GlassFish 7</a>), and request the URL via a browser or a commandline util such as <code>curl</code>.</p>
</div>
<div class="paragraph">
<p>We have two tests here: in one test we try to authenticate as "john", in the other test as "pete". As we&#8217;ve seen, each identity store only validates one of them. The fact that both tests pass demonstrates that each store will validate the right user, and that not recognizing a username by any of them will not fail the overall validation.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_securing_an_endpoint_with_form_authentication"><a class="anchor" href="#_securing_an_endpoint_with_form_authentication"></a>Securing an endpoint with Form authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the following example, we&#8217;ll secure a REST endpoint using Form authentication.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll learn how to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#specifying-security-constraints" class="external" target="_blank" rel="noopener">Define security constraints</a></p>
</li>
<li>
<p>Use the <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/formauthenticationmechanismdefinition" class="external" target="_blank" rel="noopener">Form authentication mechanism</a></p>
</li>
<li>
<p>How to define (and implicitly set) a custom <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/package-summary.html" class="external" target="_blank" rel="noopener">identity store</a></p>
</li>
<li>
<p>Use the Jakarta Security <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a></p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_write_the_application_4"><a class="anchor" href="#_write_the_application_4"></a>Write the application</h3>
<div class="paragraph">
<p>Let&#8217;s start with defining a simple REST resource class for a <code>/rest/resource</code> endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/resource")
@RequestScoped
public class Resource {

    @Inject
    private SecurityContext securityContext;

    @GET
    @Produces(TEXT_PLAIN)
    public String getCallerAndRole() {
        return
            securityContext.getCallerPrincipal().getName() + " : " +
            securityContext.isCallerInRole("user");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This resource uses the injected Jakarta EE <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> to obtain access to the current authenticated caller, which is represented by a <code>Principal</code> instance.</p>
</div>
<div class="paragraph">
<p>If this resource were available to unauthenticated callers, <code>getCallerPrincipal()</code> would return <code>null</code> for unauthenticated requests, so we&#8217;d have to check for <code>null</code>. Our example, however, requires authentication for this resource, so we can skip that check.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a Jakarta REST-specific type that is also named <a href="https://jakarta.ee/specifications/restful-ws/3.1/apidocs/jakarta.ws.rs/jakarta/ws/rs/core/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> and has similar methods as the ones we used here. From the Jakarta EE perspective, that is a discouraged type and the Jakarta Security version is to be preferred.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_declare_the_security_constraints_2"><a class="anchor" href="#_declare_the_security_constraints_2"></a>Declare the security constraints</h4>
<div class="paragraph">
<p>Next we&#8217;ll define the security constraints in <code>web.xml</code>, which tell the security system that access to a given URL or URL pattern is protected, and hence authentication is required:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="6.0"
    xmlns="https://jakarta.ee/xml/ns/jakartaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"&gt;

    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;protected&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;user&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
    &lt;/security-constraint&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This XML essentially says that to access any URL that starts with "/rest" requires the caller to have the role "user". Roles are opaque strings; merely identifiers. It&#8217;s fully up to the application how broad or fine-grained they are.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In Jakarta EE, internally these XML constraints are transformed into <code>Permission</code> instances and made available via a specific type of permission store. Knowledge about this transformation is only needed for very advanced use cases.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The observant reader may wonder if XML is really the only option here, given the strong feelings that exist in parts of the community around XML. The answer is yes and no. Jakarta EE does define the <a href="https://jakarta.ee/specifications/annotations/2.1/annotations-spec-2.1.html#jakarta-annotation-security-rolesallowed" class="external" target="_blank" rel="noopener">@RolesAllowed</a> annotation that could be used to replace the XML shown above, but only the legacy Enterprise Beans has specified a behaviour for this when put on an Enterprise Bean. Jakarta REST has done no such thing, although the <a href="https://microprofile.io/project/eclipse/microprofile-jwt-auth/spec/src/main/asciidoc/configuration.asciidoc" class="external" target="_blank" rel="noopener">JWT API in MicroProfile</a> has defined this for REST resources. In Jakarta EE, however, this remains a vendor-specific extension. There are also a number of <a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#programmatic-security-policy-configuration" class="external" target="_blank" rel="noopener">annotations and APIs</a> in Jakarta EE to set these kinds of constraints for individual Servlets, but those won&#8217;t help us much either here.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_declare_the_authentication_mechanism_2"><a class="anchor" href="#_declare_the_authentication_mechanism_2"></a>Declare the authentication mechanism</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@FormAuthenticationMechanismDefinition(
    loginToContinue = @LoginToContinue(
        loginPage="/login.html",
        errorPage="/login-error.html"
    )
)
@DeclareRoles({ "user", "caller" })
@ApplicationPath("/rest")
public class ApplicationConfig extends Application {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To declare the usage of a specific authentication mechanism, Jakarta EE provides <code>[XYZ]MechanismDefinition</code> annotations. Such an annotation is picked up by the security system, and in response to it a CDI bean that implements the <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/httpauthenticationmechanism" class="external" target="_blank" rel="noopener">HttpAuthenticationMechanism</a> is enabled for it.</p>
</div>
<div class="paragraph">
<p>The annotation can be put on any bean, but in a REST application it fits particularly well on the <code>Application</code> subclass because it also declares the path for REST resources.</p>
</div>
<div class="paragraph">
<p>Contrary to the Basic HTTP authentication mechanism, the Form authentication mechanism allows us to customize the login dialog (the process between the caller and the authentication mechanism) and to keep track of the authenticated session on the server (using a cookie). This also allows us to logout, something that for unknown reasons has never been specified for Basic HTTP authentication.</p>
</div>
<div class="paragraph">
<p>To use this authentication method, we need to designate two paths to resources that are relative to our application. One path is for the login page, which the user will be directed to when attempting to access a protected resource. The other path is for when login fails, such as when the user enters incorrect login credentials. If the paths are the same, a request parameter can be used to distinguish between them. Paths can point to anything our server can respond to; a static HTML file, a REST resource, or anything else. For simplicity, we&#8217;ll use two static HTML files here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!DOCTYPE html&gt;

&lt;html&gt;
    &lt;body&gt;
        Login to continue
        &lt;form method="POST" action="j_security_check"&gt;
            &lt;p&gt;
                &lt;strong&gt;Username &lt;/strong&gt; &lt;input type="text" name="j_username"&gt;
            &lt;p&gt;
                &lt;strong&gt;Password &lt;/strong&gt; &lt;input type="password" name="j_password"&gt;
            &lt;p&gt;
                &lt;input type="submit" value="Submit"&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!DOCTYPE html&gt;

&lt;html&gt;
    &lt;body&gt;
        Login failed!
        &lt;a href="login.html"&gt;Try again&lt;/a&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_define_the_identity_store_2"><a class="anchor" href="#_define_the_identity_store_2"></a>Define the identity store</h4>
<div class="paragraph">
<p>Finally, let&#8217;s define a basic identity store that the security system can use to validate provided credentials for Form authentication:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class CustomIdentityStore implements IdentityStore {

    public CredentialValidationResult validate(UsernamePasswordCredential usernamePasswordCredential) {
        if (usernamePasswordCredential.compareTo("john", "secret1")) {
            return new CredentialValidationResult("john", Set.of("user", "caller"));
        }

        return INVALID_RESULT;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This identity store only validates the single identity (user) "john", with password "secret1" and roles "user" and "caller". Defining this kind of identity store is often the simplest way to get started. Note that Jakarta Security doesn&#8217;t define a simple identity store out of the box, because there are questions about whether that would promote security best practices.</p>
</div>
<div class="paragraph">
<p>The identity store is installed and used by the security system just by the virtue of being there; it picks up all enabled CDI beans that implement <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/identitystore" class="external" target="_blank" rel="noopener">IdentityStore</a>. Such beans can be enabled by the security system itself (following some configuration annotation), or can be programmatically added using the appropriate CDI APIs. Where the bean comes from doesn&#8217;t matter for Jakarta Security, only the fact that it&#8217;s there.</p>
</div>
</div>
<div class="sect3">
<h4 id="_test_the_application_4"><a class="anchor" href="#_test_the_application_4"></a>Test the application</h4>
<div class="paragraph">
<p>It&#8217;s now time to test our application. A ready-to-test version is available from the Jakarta EE Examples project at <a href="https://github.com/eclipse-ee4j/jakartaee-examples" class="bare">https://github.com/eclipse-ee4j/jakartaee-examples</a>.</p>
</div>
<div class="paragraph">
<p>Download or clone this repo, then cd into the <code>focused</code> folder and execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">mvn clean install -pl :restBasicAuthCustomStore</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will run a test associated with the project, printing something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">john : true
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.24 s - in jakartaee.examples.focused.security.restformauthcustomstore.RestFormAuthCustomStoreIT</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s take a quick look at the actual test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(Arquillian.class)
@RunAsClient
public class RestFormAuthCustomStoreIT extends ITBase {

    @ArquillianResource
    private URL baseUrl;

    /**
     * Test the call to a protected REST service
     *
     * @throws Exception when a serious error occurs.
     */
    @RunAsClient
    @Test
    public void testRestCall() throws Exception {
        HtmlPage loginPage = webClient.getPage(baseUrl + "/rest/resource");
        System.out.println(loginPage.asXml());

        HtmlForm form = loginPage.getForms()
                                 .get(0);

        form.getInputByName("j_username")
            .setValueAttribute("john");

        form.getInputByName("j_password")
            .setValueAttribute("secret1");

        TextPage page = form.getInputByValue("Submit")
                   .click();

        System.out.println(page.getContent());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The test starts a server and deploys the output of the build process (a .war file) to it. The test runs in the integration test phase, rather than the unit test phase, to make sure this build output is available when it runs. The test then sends a request to the server using the provided HtmlUnit <code>webClient</code>. Note that the <code>webClient</code> can be used for any other HTTP requests your test requires.</p>
</div>
<div class="paragraph">
<p>If you want to inspect the app yourself, you can manually deploy the WAR file (<code>security/restBasicAuthCustomStore/target/restBasicAuthCustomStore.war</code>) to the server of your choice (e.g. <a href="https://projects.eclipse.org/projects/ee4j.glassfish" class="external" target="_blank" rel="noopener">GlassFish 7</a>), and request the URL via a browser or a commandline util such as <code>curl</code>.</p>
</div>
<div class="paragraph">
<p>The test first sends a request here to the protected resource, and the server responds with the HTML form we defined above. Using the <code>HtmlUnit</code> API, it&#8217;s easy to navigate the HTML DOM, fill out the username and password in the form, and programmatically click the Submit button. The form posts back to a special "j_security_check" URL, where the authentication mechanism receives the request and retrieves the username and password from the POST data, much like the Basic authentication mechanism retrieves them from the HTTP headers.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_securing_an_endpoint_with_basic_authentication_and_a_custom_algorithm_for_handling_multiple_identity_stores"><a class="anchor" href="#_securing_an_endpoint_with_basic_authentication_and_a_custom_algorithm_for_handling_multiple_identity_stores"></a>Securing an endpoint with Basic authentication and a custom algorithm for handling multiple identity stores</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the following example, we&#8217;ll be securing a REST endpoint using Basic authentication and two identity stores: the database identity store that is provided by Jakarta Security and a custom identity store. Instead of relying on the default algorithm provided by Jakarta Security to handle multiple identity stores we&#8217;ll be using a custom algoritm.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll learn how to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#specifying-security-constraints" class="external" target="_blank" rel="noopener">Define security constraints</a></p>
</li>
<li>
<p>Use the provided <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/basicauthenticationmechanismdefinition" class="external" target="_blank" rel="noopener">BasicAuthenticationMechanismDefinition</a></p>
</li>
<li>
<p>Use the provided <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/databaseidentitystoredefinition" class="external" target="_blank" rel="noopener">DatabaseIdentityStoreDefinition</a></p>
</li>
<li>
<p>Create a custom <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/package-summary.html" class="external" target="_blank" rel="noopener">identity store</a></p>
</li>
<li>
<p>Create a custom <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/identitystorehandler" class="external" target="_blank" rel="noopener">identity store handler</a></p>
</li>
<li>
<p>Use the Jakarta Security <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a></p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_write_the_application_5"><a class="anchor" href="#_write_the_application_5"></a>Write the application</h3>
<div class="paragraph">
<p>We&#8217;ll use a slightly modified resource and security constraints compared to the ones we used for the <a href="#_securing_an_endpoint_with_basic_authentication">Securing an endpoint with Basic authentication</a> example.</p>
</div>
<div class="paragraph">
<p>The REST resource is now as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/resource")
@RequestScoped
public class Resource {

    @Inject
    private SecurityContext securityContext;

    @GET
    @Produces(TEXT_PLAIN)
    public String getCallerAndRole() {
        return
            securityContext.getCallerPrincipal().getName() + " : " +
            securityContext.isCallerInRole("user") + "," +
            securityContext.isCallerInRole("caller1") + "," +
            securityContext.isCallerInRole("caller2");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As can be seen, the difference is quite small; we&#8217;re now printing out the results of two extra role checks.</p>
</div>
<div class="paragraph">
<p><code>web.xml</code> on its turn looks as follows now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;web-app xmlns="https://jakarta.ee/xml/ns/jakartaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_6_0.xsd"
         version="6.0"&gt;

    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;protected&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;user&lt;/role-name&gt;
            &lt;role-name&gt;caller2&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
    &lt;/security-constraint&gt;
    &lt;security-role&gt;
        &lt;role-name&gt;caller1&lt;/role-name&gt;
    &lt;/security-role&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Compared to the example in <a href="#_securing_an_endpoint_with_basic_authentication">Securing an endpoint with Basic authentication</a> we have now added an extra role to the <code>&lt;auth-constraint&gt;</code> section. The semantics of that are that a caller needs to have both of these roles in order to be authorised to access the resource under <code>/rest/*</code>.</p>
</div>
<div class="paragraph">
<p>Although it&#8217;s customary to explicitly declare all roles in the application using <code>&lt;security-role&gt;</code>, it&#8217;s technically not needed. As long as the role name appears in some XML fragment or annotation attribute the Jakarta EE requirement to declare all roles upfront is satisfied. As we can see in the fragment above, the role names "user" and "caller2" already appear in the <code>&lt;auth-constraint&gt;</code> section, so they don&#8217;t <strong>have</strong> to be repeated.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The reason it&#8217;s deemed good practice to list all roles in the <code>&lt;security-role&gt;</code> element in web.xml (or alternatively in an <code>@DeclareRoles</code> annotation) even when not really needed is to have a single place where all roles are listed, instead of them being scattered throughout the application.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_declare_the_authentication_mechanism_and_identity_store_3"><a class="anchor" href="#_declare_the_authentication_mechanism_and_identity_store_3"></a>Declare the authentication mechanism and identity store</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@BasicAuthenticationMechanismDefinition(
    realmName = "basicAuth"
)
@DatabaseIdentityStoreDefinition(
    callerQuery = "select password from basic_auth_user where username = ?",
    groupsQuery = "select name from basic_auth_group where username = ?",
    hashAlgorithmParameters = {
        "Pbkdf2PasswordHash.Iterations=3072",
        "Pbkdf2PasswordHash.Algorithm=PBKDF2WithHmacSHA512",
        "Pbkdf2PasswordHash.SaltSizeBytes=64"
    }
)
@DeclareRoles("user")
@ApplicationPath("/rest")
public class ApplicationConfig extends Application {</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class CustomIdentityStore implements IdentityStore {

    public CredentialValidationResult validate(UsernamePasswordCredential usernamePasswordCredential) {
        if (usernamePasswordCredential.compareTo("john", "secret1")) {
            return new CredentialValidationResult("john", Set.of("caller1", "caller2"));
        }

        return INVALID_RESULT;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example we have two enabled CDI beans implementing the <code>IdentityStore</code> interface. One of them will be implicitly enabled via the <code>@DatabaseIdentityStoreDefinition</code> annotation, while the other one is defined explicitly via the <code>CustomIdentityStore</code> class. As with a single identity store, it doesn&#8217;t matter how or where the CDI beans are defined, only that multiple enabled ones exist.</p>
</div>
<div class="paragraph">
<p>When multiple identity stores are present, an identity store handler (of type <code>IdentityStoreHandler</code>) is consulted. Jakara Security provides a default one as explained in <a href="#_securing_an_endpoint_with_basic_authentication_and_multiple_identity_stores">Securing an endpoint with Basic authentication and multiple identity stores</a>. This default handler can be overridden however to provide custom semantics. We&#8217;ll use a custom handler to enforce a caller authenticates with both identity stores, and we&#8217;ll combine the roles returned by both in the final result.</p>
</div>
</div>
<div class="sect3">
<h4 id="_populating_the_identity_store_3"><a class="anchor" href="#_populating_the_identity_store_3"></a>Populating the identity store</h4>
<div class="paragraph">
<p>In order to use the identity store, we need to put some data in a database. This is done in the same as in <a href="#Securing an endpoint with Basic authentication and a Database identity store">[Securing an endpoint with Basic authentication and a Database identity store]</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the custom identity store defined above and in the database identity store here we both use name "john' and password "secret1".
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_writing_the_identity_store_handler"><a class="anchor" href="#_writing_the_identity_store_handler"></a>Writing the identity store handler</h4>
<div class="paragraph">
<p>We&#8217;ll now write the identity store handler:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Alternative <i class="conum" data-value="1"></i><b>(1)</b>
@Priority(APPLICATION) <i class="conum" data-value="2"></i><b>(2)</b>
@ApplicationScoped
public class CustomIdentityStoreHandler implements IdentityStoreHandler {

    @Inject
    Instance&lt;IdentityStore&gt; identityStores; <i class="conum" data-value="3"></i><b>(3)</b>

    @Override
    public CredentialValidationResult validate(Credential credential) {
        CredentialValidationResult result = null;
        Set&lt;String&gt; groups = new HashSet&lt;&gt;();

        for (IdentityStore identityStore : identityStores) {
            result = identityStore.validate(credential);
            if (result.getStatus() == NOT_VALIDATED) {
                // Identity store probably doesn't handle our credential type
                continue;
            }

            if (result.getStatus() == INVALID) {
                // Identity store handled our credential type and determined its
                // invalid. End the loop.
                return INVALID_RESULT;
            }

            groups.addAll(result.getCallerGroups());
        }

        return new CredentialValidationResult(
            result.getCallerPrincipal(), groups);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Since we&#8217;re overriding an existing CDI bean (the default <code>IdentityStoreHandler</code> provided by Jakarta Security), we have to annotate our custom <code>IdentityStoreHandler</code> with <code>@Alternative</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>To make <code>@Alternative</code> actually work, we additionally have to annotate with <code>@Priority(APPLICATION)</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>With <code>@Inject</code> <code>Instance&lt;IdentityStore&gt; identityStores</code> CDI will give us a collection of all identity stores in the application. In the case of this example that will be the store behind <code>@DatabaseIdentityStoreDefinition</code> and our <code>CustomIdentityStore</code>. We can the iterate over those stores in our code, and offer the credentials (the username and password in this example) to each of them.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are various result outcomes possible.</p>
</div>
<div class="paragraph">
<p><code>NOT_VALIDATED</code> means the store did not try to validate the credentials at all. In most situations that status is set when the store in question doesnt&#8217;t handle a given credential. I.e. it only handles say <code>JWTCredentials</code> and not <code>UsernamePasswordCredential</code>.</p>
</div>
<div class="paragraph">
<p><code>INVALID</code> means the store tried to validate the credentials, and validation failed. For example the username and password were wrong.</p>
</div>
<div class="paragraph">
<p>In our custom handler code here we return an <code>INVALID_RESULT</code> for the first store that fails, as we want all stores to validate successfully here. If validation does succeed (the outcome is <code>VALID</code> then) we grab the groups it returned and store in a set.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Identity stores also have a capability to query it for roles directly, without validating credentials. We haven&#8217;t used that feature here.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Eventually we return a result based on the <code>CallerPrincipal</code> from the last successful validation result, and all the collected groups.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In our example it doesn&#8217;t matter from which validation result we grab the <code>CallerPrincipal</code> as it&#8217;s all the one with name "pete" here. In general identity stores may transform the name from the input credential (for example "pete") to something else (for example "Pete Anderson").
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_test_the_application_5"><a class="anchor" href="#_test_the_application_5"></a>Test the application</h4>
<div class="paragraph">
<p>It&#8217;s now time to test our application. A ready-to-test version is available from the Jakarta EE Examples project at <a href="https://github.com/eclipse-ee4j/jakartaee-examples" class="bare">https://github.com/eclipse-ee4j/jakartaee-examples</a>.</p>
</div>
<div class="paragraph">
<p>Download or clone this repo, then cd into the <code>focused</code> folder and execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">mvn clean install -pl :restBasicAuthCustomStoreHandler</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will run a test associated with the project, printing something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">john : true,true,true
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 7.634 s - in jakartaee.examples.focused.security.restbasicauthcustomstorehandler.RestBasicAuthCustomStoreHandlerIT</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resource that we defined above required only two roles to access it (<code>user</code> and <code>caller2</code>), but our custom identity store also returned <code>caller1</code>. The resource we created tests for this, and as it appears, we indeed had this role.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If we hadn&#8217;t declared <code>caller1</code> in <code>web.xml</code> (or via an annotation), the test for <code>caller1</code> might have returned false. This is however server dependent.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_securing_an_endpoint_with_a_custom_authentication_mechanism_and_a_custom_identity_store"><a class="anchor" href="#_securing_an_endpoint_with_a_custom_authentication_mechanism_and_a_custom_identity_store"></a>Securing an endpoint with a custom authentication mechanism and a custom identity store</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the following example, we&#8217;ll be securing a REST endpoint using a custom authentication mechanism. A custom authentication mechanism is one we provide ourselves, instead of using one provided by Jakarta Security (such as the Basic HTTP authentication mechanism).</p>
</div>
<div class="paragraph">
<p>You&#8217;ll learn how to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#specifying-security-constraints" class="external" target="_blank" rel="noopener">Define security constraints</a></p>
</li>
<li>
<p>Define (and implicitly set) a custom authentication mechanism</p>
</li>
<li>
<p>Define (and implicitly set) a custom identity store</p>
</li>
<li>
<p>Use the Jakarta Security <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a></p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_write_the_application_6"><a class="anchor" href="#_write_the_application_6"></a>Write the application</h3>
<div class="paragraph">
<p>Let&#8217;s start with defining a simple REST resource class for a <code>/rest/resource</code> endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/resource")
@RequestScoped
public class Resource {

    @Inject
    private SecurityContext securityContext;

    @GET
    @Produces(TEXT_PLAIN)
    public String getCallerAndRole() {
        return
            securityContext.getCallerPrincipal().getName() + " : " +
            securityContext.isCallerInRole("user");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This resource uses the injected Jakarta EE <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> to obtain access to the current authenticated caller, which is represented by a <code>Principal</code> instance.</p>
</div>
<div class="paragraph">
<p>If this resource were available to unauthenticated callers, <code>getCallerPrincipal()</code> would return <code>null</code> for unauthenticated requests, so we&#8217;d have to check for <code>null</code>. Our example, however, requires authentication for this resource, so we can skip that check.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a Jakarta REST-specific type that is also named <a href="https://jakarta.ee/specifications/restful-ws/3.1/apidocs/jakarta.ws.rs/jakarta/ws/rs/core/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> and has similar methods as the ones we used here. From the Jakarta EE perspective, that is a discouraged type and the Jakarta Security version is to be preferred.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_define_the_authentication_mechanism"><a class="anchor" href="#_define_the_authentication_mechanism"></a>Define the authentication mechanism</h4>
<div class="paragraph">
<p>Let&#8217;s now define a simple authentication mechanism that the security system can use to interact with the caller who tries to access a resource:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class CustomAuthenticationMechanism implements HttpAuthenticationMechanism {

    @Inject
    private IdentityStoreHandler identityStoreHandler;

    @Override
    public AuthenticationStatus validateRequest(
        HttpServletRequest request,
        HttpServletResponse response,
        HttpMessageContext httpMessageContext) throws AuthenticationException {

        var callerName = request.getHeader("callername"); <i class="conum" data-value="1"></i><b>(1)</b>
        var password = request.getHeader("callerpassword");

        if (callerName == null || password == null) { <i class="conum" data-value="2"></i><b>(2)</b>
            return httpMessageContext.doNothing();
        }

        var result = identityStoreHandler.validate( <i class="conum" data-value="4"></i><b>(4)</b>
            new UsernamePasswordCredential(callerName, password)); <i class="conum" data-value="3"></i><b>(3)</b>

        if (result.getStatus() != VALID) {
            return httpMessageContext.responseUnauthorized();
        }

        return httpMessageContext.notifyContainerAboutLogin( <i class="conum" data-value="5"></i><b>(5)</b>
            result.getCallerPrincipal(),
            result.getCallerGroups());
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This custom authentication mechanism interacts with the caller by grabbing two headers from the request: <code>callername</code> and <code>callerpassword</code>. (1) In case any of them are <code>null</code>, we return a special status; the "do nothing" status. (2) This means there has been no request or attempt to do authentication. If the resource the caller is trying to access is not protected, the caller can access it anonymously. If it is proteced, the caller will not be able to access it.</p>
</div>
<div class="paragraph">
<p>When the two required headers are provided by the caller, we create a <code>UsernamePasswordCredential</code> out of their values (3) and pass that into the injected <code>IdentityStoreHandler</code>. (4) We saw how this type of handler worked in the example <a href="#_securing_an_endpoint_with_basic_authentication_and_a_custom_algorithm_for_handling_multiple_identity_stores">Securing an endpoint with Basic authentication and a custom algorithm for handling multiple identity stores</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An authentication mechanism in Jakarta Security is not strictly required to delegate the credential validation to the identity store handler. However not doing so is considered bad practice, as it would restrict developers from things like inserting extra identity stores into the chain that can do things like adding extra groups.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the credentials validated correctly, we use the <code>HttpMessageContext</code> to communicate the details of the authenticated caller to the container. (5)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In Jakarta Security the two basic items that make up an "authenticated identity" are just a caller principal (of type <code>Principal</code>) and a set of groups (of type <code>String</code>). Via a <a href="https://en.wikipedia.org/wiki/Service_provider_interface" class="external" target="_blank" rel="noopener">Service Provider Interface</a> a specific Jakarta EE product (such as WildFly or GlassFish) is able to receive these two items and then stores it internally in some way.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The authentication mechanism is installed and used by the security system just by the virtue of being there; it picks up all enabled CDI beans that implement <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/httpauthenticationmechanism" class="external" target="_blank" rel="noopener">HttpAuthenticationMechanism</a>. Such beans can be enabled by the security system itself (following some configuration annotation), or can be programmatically added using the appropriate CDI APIs. Where the bean comes from doesn&#8217;t matter for Jakarta Security, only the fact that it&#8217;s there.</p>
</div>
</div>
<div class="sect3">
<h4 id="_define_the_identity_store_3"><a class="anchor" href="#_define_the_identity_store_3"></a>Define the identity store</h4>
<div class="paragraph">
<p>Finally, let&#8217;s define a simple identity store that the security system can use to validate provided credentials for Basic authentication:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class TestIdentityStore implements IdentityStore {

    public CredentialValidationResult validate(UsernamePasswordCredential usernamePasswordCredential) {
        if (usernamePasswordCredential.compareTo("john", "secret1")) {
            return new CredentialValidationResult("john", Set.of("user", "caller"));
        }

        return INVALID_RESULT;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This identity store only validates the single identity (user) "john", with password "secret1" and roles "user" and "caller". Defining this kind of identity store is often the simplest way to get started.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Jakarta Security doesn&#8217;t provide a simple identity store out of the box. The reason is that everything in Jakarta Security promotes best practices, and it&#8217;s not clear if a simple identity store fits in with those best practices.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The identity store is installed and used by the security system just by the virtue of being there; it picks up all enabled CDI beans that implement <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/identitystore" class="external" target="_blank" rel="noopener">IdentityStore</a>. Such beans can be enabled by the security system itself (following some configuration annotation), or can be programmatically added using the appropriate CDI APIs. Where the bean comes from doesn&#8217;t matter for Jakarta Security, only the fact that it&#8217;s there.</p>
</div>
</div>
<div class="sect3">
<h4 id="_test_the_application_6"><a class="anchor" href="#_test_the_application_6"></a>Test the application</h4>
<div class="paragraph">
<p>It&#8217;s now time to test our application. A ready-to-test version is available from the Jakarta EE Examples project at <a href="https://github.com/eclipse-ee4j/jakartaee-examples" class="bare">https://github.com/eclipse-ee4j/jakartaee-examples</a>.</p>
</div>
<div class="paragraph">
<p>Download or clone this repo, then cd into the <code>focused</code> folder and execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">mvn clean install -pl :restCustomAuthCustomStore</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will run a test associated with the project, printing something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">john : true
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4.591 s - in jakartaee.examples.focused.security.restcustomauthcustomstore.RestCustomAuthCustomStoreIT</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s take a quick look at the actual test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(Arquillian.class)
@RunAsClient
public class RestCustomAuthCustomStoreIT extends ITBase {

    @ArquillianResource
    private URL baseUrl;

    /**
     * Test the call to a protected REST service
     *
     * @throws Exception when a serious error occurs.
     */
    @RunAsClient
    @Test
    public void testRestCall() throws Exception {
        webClient.addRequestHeader("callername", "john");
        webClient.addRequestHeader("callerpassword", "secret1");

        TextPage page = webClient.getPage(baseUrl + "rest/resource");
        String content = page.getContent();

        System.out.println(content);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The test starts a server and deploys the output of the build process (a .war file) to it. The test runs in the integration test phase, rather than the unit test phase, to make sure this build output is available when it runs. The test then sends a request to the server using the provided HtmlUnit <code>webClient</code>. Note that the <code>webClient</code> can be used for any other HTTP requests your test requires.</p>
</div>
<div class="paragraph">
<p>If you want to inspect the app yourself, you can manually deploy the WAR file (<code>security/restCustomAuthCustomStore/target/restCustomAuthCustomStore.war</code>) to the server of your choice (e.g. <a href="https://projects.eclipse.org/projects/ee4j.glassfish" class="external" target="_blank" rel="noopener">GlassFish 7</a>), and request the URL via a browser or a commandline util such as <code>curl</code>.</p>
</div>
<div class="paragraph">
<p>The <code>webClient.addRequestHeader()</code> calls used here make sure that the headers for our custom authentication mechanism are added to the request. The authentication mechanism that we defined for our applications reads those headers, extracts the username and password from them, and consults our identity store with them.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_securing_an_endpoint_with_form_authentication_and_remember_me"><a class="anchor" href="#_securing_an_endpoint_with_form_authentication_and_remember_me"></a>Securing an endpoint with Form authentication and remember-me</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the following example, we&#8217;ll secure a REST endpoint using Form authentication and remember-me.</p>
</div>
<div class="paragraph">
<p>Remember-me is a facility where an authenticated identity can be remembered beyond the scope of an HTTP session. This happens via
a separate cookie that has a longer life-time than the cookie used for the HTTP session (and the session itself on the server).</p>
</div>
<div class="paragraph">
<p>You&#8217;ll learn how to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#specifying-security-constraints" class="external" target="_blank" rel="noopener">Define security constraints</a></p>
</li>
<li>
<p>Use the <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/formauthenticationmechanismdefinition" class="external" target="_blank" rel="noopener">Form authentication mechanism</a></p>
</li>
<li>
<p>Enable the <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/rememberme" class="external" target="_blank" rel="noopener">remember-me</a> feature</p>
</li>
<li>
<p>How to define (and implicitly set) a custom <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/remembermeidentitystore" class="external" target="_blank" rel="noopener">remember-me identity store</a></p>
</li>
<li>
<p>How to define (and implicitly set) a custom <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/package-summary.html" class="external" target="_blank" rel="noopener">identity store</a></p>
</li>
<li>
<p>Use the Jakarta Security <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a></p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_write_the_application_7"><a class="anchor" href="#_write_the_application_7"></a>Write the application</h3>
<div class="paragraph">
<p>Let&#8217;s start with defining a simple REST resource class for a <code>/rest/resource</code> endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/resource")
@RequestScoped
public class Resource {

    @Inject
    private SecurityContext securityContext;

    @GET
    @Produces(TEXT_PLAIN)
    public String getCallerAndRole() {
        return
            securityContext.getCallerPrincipal().getName() + " : " +
            securityContext.isCallerInRole("user");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This resource uses the injected Jakarta EE <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> to obtain access to the current authenticated caller, which is represented by a <code>Principal</code> instance.</p>
</div>
<div class="paragraph">
<p>If this resource were available to unauthenticated callers, <code>getCallerPrincipal()</code> would return <code>null</code> for unauthenticated requests, so we&#8217;d have to check for <code>null</code>. Our example, however, requires authentication for this resource, so we can skip that check.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a Jakarta REST-specific type that is also named <a href="https://jakarta.ee/specifications/restful-ws/3.1/apidocs/jakarta.ws.rs/jakarta/ws/rs/core/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> and has similar methods as the ones we used here. From the Jakarta EE perspective, that is a discouraged type and the Jakarta Security version is to be preferred.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_declare_the_security_constraints_3"><a class="anchor" href="#_declare_the_security_constraints_3"></a>Declare the security constraints</h4>
<div class="paragraph">
<p>Next we&#8217;ll define the security constraints in <code>web.xml</code>, which tell the security system that access to a given URL or URL pattern is protected, and hence authentication is required:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="6.0"
    xmlns="https://jakarta.ee/xml/ns/jakartaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"&gt;

    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;protected&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;user&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
    &lt;/security-constraint&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This XML essentially says that to access any URL that starts with "/rest" requires the caller to have the role "user". Roles are opaque strings; merely identifiers. It&#8217;s fully up to the application how broad or fine-grained they are.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In Jakarta EE, internally these XML constraints are transformed into <code>Permission</code> instances and made available via a specific type of permission store. Knowledge about this transformation is only needed for very advanced use cases.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The observant reader may wonder if XML is really the only option here, given the strong feelings that exist in parts of the community around XML. The answer is yes and no. Jakarta EE does define the <a href="https://jakarta.ee/specifications/annotations/2.1/annotations-spec-2.1.html#jakarta-annotation-security-rolesallowed" class="external" target="_blank" rel="noopener">@RolesAllowed</a> annotation that could be used to replace the XML shown above, but only the legacy Enterprise Beans has specified a behaviour for this when put on an Enterprise Bean. Jakarta REST has done no such thing, although the <a href="https://microprofile.io/project/eclipse/microprofile-jwt-auth/spec/src/main/asciidoc/configuration.asciidoc" class="external" target="_blank" rel="noopener">JWT API in MicroProfile</a> has defined this for REST resources. In Jakarta EE, however, this remains a vendor-specific extension. There are also a number of <a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#programmatic-security-policy-configuration" class="external" target="_blank" rel="noopener">annotations and APIs</a> in Jakarta EE to set these kinds of constraints for individual Servlets, but those won&#8217;t help us much either here.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_declare_the_authentication_mechanism_3"><a class="anchor" href="#_declare_the_authentication_mechanism_3"></a>Declare the authentication mechanism</h4>
<div class="paragraph">
<p>We&#8217;ll use the same authentication mechanism declaration as we used for <a href="#_securing_an_endpoint_with_form_authentication">Securing an endpoint with Form authentication</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_enable_remember_me"><a class="anchor" href="#_enable_remember_me"></a>Enable remember-me</h4>
<div class="paragraph">
<p>In Jakarta Security, there are several services available through CDI Interceptors <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup>, one of which is the remember-me service. Remember-me can be transparently applied to basically every authentication mechanism. In CDI, it&#8217;s trivial to add Interceptors to beans that we define ourselves, but a little less trivial to add to provided beans. In this section we explain how to do this via a CDI extension.</p>
</div>
<div class="paragraph">
<p>For this example, we&#8217;ll add the CDI extension interface (1) to our application config class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@FormAuthenticationMechanismDefinition(
    loginToContinue = @LoginToContinue(
        loginPage="/login.html",
        errorPage="/login-error.html"
    )
)
@ApplicationPath("/rest")
public class ApplicationConfig extends Application
    implements BuildCompatibleExtension { <i class="conum" data-value="1"></i><b>(1)</b>

    @Enhancement(
        types = HttpAuthenticationMechanism.class,
        withSubtypes = true) <i class="conum" data-value="2"></i><b>(2)</b>
    public void addRememberMe(ClassConfig httpAuthenticationMechanism) {
        httpAuthenticationMechanism.addAnnotation(
            RememberMe.Literal.INSTANCE); <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>CDI allows us to enhance classes using a method annotated with the <code>@Enhancement</code> annotation and as attribute the class we&#8217;re seeking to enhance. For our example that will be a sub-type of the <code>HttpAuthenticationMechanism</code> interface (we know the bean enabled by <code>FormAuthenticationMechanismDefinition</code> will implement the <code>HttpAuthenticationMechanism</code> interface), hence we set the <code>withSubtypes</code> attribute to <code>true</code>. (2)</p>
</div>
<div class="paragraph">
<p>Within the method we can then programmatically add the <code>@RememberMe</code> annotation used to bind the remember-me interceptor to a class. In the example here we use the default instance (which has all attributes set to their defaults). There are attributes for setting various aspects of the cookie, such as its name, whether it should be secure and http only, and perhaps most importantly the max age of the cookie (default is one day).</p>
</div>
</div>
<div class="sect3">
<h4 id="_define_the_remember_me_identity_store"><a class="anchor" href="#_define_the_remember_me_identity_store"></a>Define the remember-me identity store</h4>
<div class="paragraph">
<p>For remember-me to work a token has to be created that is used as a credential to authenticate right away instead of invoking the authentication mechanism that is being intercepted. Jakarta Security uses a special identity store for this; the <code>RememberMeIdentityStore</code>. This type of identity store is exclusively used by the remember-me feature, hence it&#8217;s a different type from <code>IdentityStore</code>.</p>
</div>
<div class="paragraph">
<p>Jakarta Security does not ship with any provided remember-me identity store, but for demonstration purposes we can easily create one ourselves.</p>
</div>
<div class="paragraph">
<p>The following shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class CustomRememberMeIdentityStore implements RememberMeIdentityStore {

    private final Map&lt;String, CredentialValidationResult&gt; tokenToIdentityMap =
        new ConcurrentHashMap&lt;&gt;();

    @Override
    public String generateLoginToken(
        CallerPrincipal callerPrincipal, Set&lt;String&gt; groups) { <i class="conum" data-value="1"></i><b>(1)</b>
        var token = UUID.randomUUID().toString();

        tokenToIdentityMap.put(
            token,
            new CredentialValidationResult(callerPrincipal, groups));

        return token;
    }

    @Override
    public CredentialValidationResult validate(
        RememberMeCredential credential) { <i class="conum" data-value="2"></i><b>(2)</b>
        if (tokenToIdentityMap.containsKey(credential.getToken())) {
            return tokenToIdentityMap.get(credential.getToken());
        }

        return INVALID_RESULT;
    }

    @Override
    public void removeLoginToken(String token) { <i class="conum" data-value="3"></i><b>(3)</b>
        tokenToIdentityMap.remove(token);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>RememberMeIdentityStore</code> needs to perform 3 tasks.</p>
</div>
<div class="paragraph">
<p>It first needs to generate a token representing a caller principal and a set of groups. The caller principal and the set of groups are the ones set by the authentication mechanism right after the caller successfully authenticated. In our example (1) here we&#8217;re generating a random UUID that&#8217;s used as a key in an application scoped map.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Storing the authenticated identity (principal and groups) in an application scoped map is just an example. Other options could be storing it in a database or key-value store, encrypting the principal and groups, or generating some kind of JSON Web Token (JWT).
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When storing the Principal, care must be taken that the Principal could be an elaborate custom Principal containing many more fields than just <code>name</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The next thing that must be done is essentially similar to what a normal identity store does: validating a <code>Credential</code>. For a <code>RememberMeIdentityStore</code> this will always be of type <code>RememberMeCredential</code> with <code>getToken()</code> returning a token of the kind that was generated in <code>generateLoginToken()</code>. In our example (2) we&#8217;re just using the token as key in our map.</p>
</div>
<div class="paragraph">
<p>Finally we can provide behaviour to remove the login token (and essentially invalidate it) via the <code>removeLoginToken</code> method. This method is called when a caller explicitly logs out. In our example (3) we just remove the token from our map.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When storing the principal and groups in a token that we send to the client we can&#8217;t always easily invalidate it when the caller logs out; the caller can always keep the token and send it again.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_define_the_identity_store_4"><a class="anchor" href="#_define_the_identity_store_4"></a>Define the identity store</h4>
<div class="paragraph">
<p>Finally, let&#8217;s define a simple identity store that the security system can use to validate provided credentials for Basic authentication:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class TestIdentityStore implements IdentityStore {

    public CredentialValidationResult validate(UsernamePasswordCredential usernamePasswordCredential) {
        if (usernamePasswordCredential.compareTo("john", "secret1")) {
            return new CredentialValidationResult("john", Set.of("user", "caller"));
        }

        return INVALID_RESULT;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This identity store only validates the single identity (user) "john", with password "secret1" and roles "user" and "caller". Defining this kind of identity store is often the simplest way to get started.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Jakarta Security doesn&#8217;t provide a simple identity store out of the box. The reason is that everything in Jakarta Security promotes best practices, and it&#8217;s not clear if a simple identity store fits in with those best practices.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The identity store is installed and used by the security system just by the virtue of being there; it picks up all enabled CDI beans that implement <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/identitystore" class="external" target="_blank" rel="noopener">IdentityStore</a>. Such beans can be enabled by the security system itself (following some configuration annotation), or can be programmatically added using the appropriate CDI APIs. Where the bean comes from doesn&#8217;t matter for Jakarta Security, only the fact that it&#8217;s there.</p>
</div>
</div>
<div class="sect3">
<h4 id="_test_the_application_7"><a class="anchor" href="#_test_the_application_7"></a>Test the application</h4>
<div class="paragraph">
<p>It&#8217;s now time to test our application. A ready-to-test version is available from the Jakarta EE Examples project at <a href="https://github.com/eclipse-ee4j/jakartaee-examples" class="bare">https://github.com/eclipse-ee4j/jakartaee-examples</a>.</p>
</div>
<div class="paragraph">
<p>Download or clone this repo, then cd into the <code>focused</code> folder and execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">mvn clean install -pl :restFormAuthCustomStoreRememberMe</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will run a test associated with the project, printing something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">john : true
john : true
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.702 s - in jakartaee.examples.focused.security.restformauthcustomatorerememberme.RestFormAuthCustomStoreIT</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s take a quick look at the actual test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(Arquillian.class)
@RunAsClient
public class RestFormAuthCustomStoreRememberMeIT extends ITBase {

    @ArquillianResource
    private URL baseUrl;

    /**
     * Test the call to a protected REST service
     *
     * @throws Exception when a serious error occurs.
     */
    @RunAsClient
    @Test
    public void testRestCall() throws Exception {
        // Initial request
        HtmlPage loginPage = webClient.getPage(baseUrl + "/rest/resource");
        System.out.println(loginPage.asXml());

        // Response is login form, so we can authenticate
        HtmlForm form = loginPage.getForms()
                                 .get(0);

        form.getInputByName("j_username")
            .setValueAttribute("john");

        form.getInputByName("j_password")
            .setValueAttribute("secret1");

        // After logging in, we should get the actual resource response
        TextPage page = form.getInputByValue("Submit")
                   .click();

        System.out.println(page.getContent());

        // Remove all cookies (specially the JSESSONID), except for the
        // JREMEMBERMEID cookie which carries the token to login again
        for (Cookie cookie : webClient.getCookieManager().getCookies()) {
            if (!"JREMEMBERMEID".equals(cookie.getName())) {
                webClient.getCookieManager().removeCookie(cookie);
            }
        }

        // Should get the resource response, and not the login form
        TextPage pageAgain = webClient.getPage(baseUrl + "/rest/resource");

        System.out.println(pageAgain.getContent());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The test starts a server and deploys the output of the build process (a .war file) to it. The test runs in the integration test phase, rather than the unit test phase, to make sure this build output is available when it runs. The test then sends a request to the server using the provided HtmlUnit <code>webClient</code>. Note that the <code>webClient</code> can be used for any other HTTP requests your test requires.</p>
</div>
<div class="paragraph">
<p>If you want to inspect the app yourself, you can manually deploy the WAR file (<code>security/restFormAuthCustomStoreRememberMe/target/restFormAuthCustomStoreRememberMe.war</code>) to the server of your choice (e.g. <a href="https://projects.eclipse.org/projects/ee4j.glassfish" class="external" target="_blank" rel="noopener">GlassFish 7</a>), and request the URL via a browser or a commandline util such as <code>curl</code>.</p>
</div>
<div class="paragraph">
<p>The test first sends a request here to the protected resource, and the server responds with the HTML form we defined above. Using the <code>HtmlUnit</code> API, it&#8217;s easy to navigate the HTML DOM, fill out the username and password in the form, and programmatically click the Submit button. The form posts back to a special "j_security_check" URL, where the authentication mechanism receives the request and retrieves the username and password from the POST data, much like the Basic authentication mechanism retrieves them from the HTTP headers.</p>
</div>
<div class="paragraph">
<p>Then we delete all cookies, specifically the <code>JSESSIONID</code> cookie that keeps the session that the form authentication mechanism uses to remember the authenticated identity. The test then does another request, and this time the value from the <code>JREMEMBERMEID</code> cookie is used to login.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_securing_an_endpoint_with_a_custom_authentication_mechanism_a_custom_identity_store_and_remember_me"><a class="anchor" href="#_securing_an_endpoint_with_a_custom_authentication_mechanism_a_custom_identity_store_and_remember_me"></a>Securing an endpoint with a custom authentication mechanism, a custom identity store and remember-me</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the following example, we&#8217;ll secure a REST endpoint using custom authentication and remember-me.</p>
</div>
<div class="paragraph">
<p>Remember-me is a facility where an authenticated identity can be remembered beyond the scope of an HTTP session. This happens via
a separate cookie that has a longer life-time than the cookie used for the HTTP session (and the session itself on the server).</p>
</div>
<div class="paragraph">
<p>You&#8217;ll learn how to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#specifying-security-constraints" class="external" target="_blank" rel="noopener">Define security constraints</a></p>
</li>
<li>
<p>Define (and implicitly set) a custom authentication mechanism with remember-me</p>
</li>
<li>
<p>How to define (and implicitly set) a custom remember-me identity store</p>
</li>
<li>
<p>Define (and implicitly set) a custom identity store</p>
</li>
<li>
<p>Use the Jakarta Security <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a></p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_write_the_application_8"><a class="anchor" href="#_write_the_application_8"></a>Write the application</h3>
<div class="paragraph">
<p>Let&#8217;s start with defining a simple REST resource class for a <code>/rest/resource</code> endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/resource")
@RequestScoped
public class Resource {

    @Inject
    private SecurityContext securityContext;

    @GET
    @Produces(TEXT_PLAIN)
    public String getCallerAndRole() {
        return
            securityContext.getCallerPrincipal().getName() + " : " +
            securityContext.isCallerInRole("user");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This resource uses the injected Jakarta EE <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> to obtain access to the current authenticated caller, which is represented by a <code>Principal</code> instance.</p>
</div>
<div class="paragraph">
<p>If this resource were available to unauthenticated callers, <code>getCallerPrincipal()</code> would return <code>null</code> for unauthenticated requests, so we&#8217;d have to check for <code>null</code>. Our example, however, requires authentication for this resource, so we can skip that check.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a Jakarta REST-specific type that is also named <a href="https://jakarta.ee/specifications/restful-ws/3.1/apidocs/jakarta.ws.rs/jakarta/ws/rs/core/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> and has similar methods as the ones we used here. From the Jakarta EE perspective, that is a discouraged type and the Jakarta Security version is to be preferred.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_define_the_authentication_mechanism_2"><a class="anchor" href="#_define_the_authentication_mechanism_2"></a>Define the authentication mechanism</h4>
<div class="paragraph">
<p>Let&#8217;s now define a simple authentication mechanism that the security system can use to interact with the caller who tries to access a resource and specifically make sure the RememberMe feature is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RememberMe <i class="conum" data-value="6"></i><b>(6)</b>
@ApplicationScoped
public class CustomAuthenticationMechanism implements HttpAuthenticationMechanism {

    @Inject
    private IdentityStoreHandler identityStoreHandler;

    @Override
    public AuthenticationStatus validateRequest(
        HttpServletRequest request,
        HttpServletResponse response,
        HttpMessageContext httpMessageContext) throws AuthenticationException {

        var callerName = request.getHeader("callername"); <i class="conum" data-value="1"></i><b>(1)</b>
        var password = request.getHeader("callerpassword");

        if (callerName == null || password == null) { <i class="conum" data-value="2"></i><b>(2)</b>
            return httpMessageContext.doNothing();
        }

        var result = identityStoreHandler.validate( <i class="conum" data-value="4"></i><b>(4)</b>
            new UsernamePasswordCredential(callerName, password)); <i class="conum" data-value="3"></i><b>(3)</b>

        if (result.getStatus() != VALID) {
            return httpMessageContext.responseUnauthorized();
        }

        return httpMessageContext.notifyContainerAboutLogin( <i class="conum" data-value="5"></i><b>(5)</b>
            result.getCallerPrincipal(),
            result.getCallerGroups());
    }

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is the same custom authentication mechanism that was used in <a href="#_securing_an_endpoint_with_a_custom_authentication_mechanism_and_a_custom_identity_store">Securing an endpoint with a custom authentication mechanism and a custom identity store</a>, but with the <code>@RememberMe</code> annotation added.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This custom authentication mechanism interacts with the caller by grabbing two headers from the request: <code>callername</code> and <code>callerpassword</code>. (1) In case any of them are <code>null</code>, we return a special status; the "do nothing" status. (2) This means there has been no request or attempt to do authentication. If the resource the caller is trying to access is not protected, the caller can access it anonymously. If it is proteced, the caller will not be able to access it.</p>
</div>
<div class="paragraph">
<p>When the two required headers are provided by the caller, we create a <code>UsernamePasswordCredential</code> out of their values (3) and pass that into the injected <code>IdentityStoreHandler</code>. (4) We&#8217;ve seen how such handler worked in the example <a href="#_securing_an_endpoint_with_basic_authentication_and_a_custom_algorithm_for_handling_multiple_identity_stores">Securing an endpoint with Basic authentication and a custom algorithm for handling multiple identity stores</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
An authentication mechanism in Jakarta Security is not strictly required to delegate the credential validation to the identity store handler. However not doing so is considered bad practice, as it would restrict developers from things like inserting extra identity stores into the chain that can do things like adding extra groups.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the credentials validated correctly, we use the <code>HttpMessageContext</code> to communicate the details of the authenticated caller to the container. (5)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In Jakarta Security the two basic items that make up an "authenticated identity" are just a caller principal (of type <code>Principal</code>) and a set of groups (of type <code>String</code>). Via a <a href="https://en.wikipedia.org/wiki/Service_provider_interface" class="external" target="_blank" rel="noopener">Service Provider Interface</a> a specific Jakarta EE product (such as WildFly or GlassFish) is able to receive these two items and then stores it internally in some way.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We annotate our custom authentication mechanism with the <code>@RememberMe</code> annotation to enable the remember-me feature for use with this authentication mechanism. In the example here we don&#8217;t set any attributes (all of them have default values). There are attributes for setting various aspects of the cookie used for remember-me, such as its name, whether it should be secure and http only, and perhaps most importantly the max age of the cookie (default is one day).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Instead of using the <code>@RememberMe</code> annotation here, we could also have used the same extension that was used in <a href="#_securing_an_endpoint_with_form_authentication_and_remember_me">Securing an endpoint with Form authentication and remember-me</a> to enable the remember-me feature. The annotation however is a little bit easier to use.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The authentication mechanism is installed and used by the security system just by the virtue of being there; it picks up all enabled CDI beans that implement <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/httpauthenticationmechanism" class="external" target="_blank" rel="noopener">HttpAuthenticationMechanism</a>. Such beans can be enabled by the security system itself (following some configuration annotation), or can be programmatically added using the appropriate CDI APIs. Where the bean comes from doesn&#8217;t matter for Jakarta Security, only the fact that it&#8217;s there.</p>
</div>
</div>
<div class="sect3">
<h4 id="_define_the_identity_store_5"><a class="anchor" href="#_define_the_identity_store_5"></a>Define the identity store</h4>
<div class="paragraph">
<p>Finally, let&#8217;s define a simple identity store that the security system can use to validate provided credentials for Basic authentication:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class TestIdentityStore implements IdentityStore {

    public CredentialValidationResult validate(UsernamePasswordCredential usernamePasswordCredential) {
        if (usernamePasswordCredential.compareTo("john", "secret1")) {
            return new CredentialValidationResult("john", Set.of("user", "caller"));
        }

        return INVALID_RESULT;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This identity store only validates the single identity (user) "john", with password "secret1" and roles "user" and "caller". Defining this kind of identity store is often the simplest way to get started.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Jakarta Security doesn&#8217;t provide a simple identity store out of the box. The reason is that everything in Jakarta Security promotes best practices, and it&#8217;s not clear if a simple identity store fits in with those best practices.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The identity store is installed and used by the security system just by the virtue of being there; it picks up all enabled CDI beans that implement <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/identitystore" class="external" target="_blank" rel="noopener">IdentityStore</a>. Such beans can be enabled by the security system itself (following some configuration annotation), or can be programmatically added using the appropriate CDI APIs. Where the bean comes from doesn&#8217;t matter for Jakarta Security, only the fact that it&#8217;s there.</p>
</div>
</div>
<div class="sect3">
<h4 id="_define_the_remember_me_identity_store_2"><a class="anchor" href="#_define_the_remember_me_identity_store_2"></a>Define the remember-me identity store</h4>
<div class="paragraph">
<p>We&#8217;ll use the same remember-me identity store as we used for the <a href="#_securing_an_endpoint_with_form_authentication_and_remember_me">Securing an endpoint with Form authentication and remember-me</a> example.</p>
</div>
</div>
<div class="sect3">
<h4 id="_test_the_application_8"><a class="anchor" href="#_test_the_application_8"></a>Test the application</h4>
<div class="paragraph">
<p>It&#8217;s now time to test our application. A ready-to-test version is available from the Jakarta EE Examples project at <a href="https://github.com/eclipse-ee4j/jakartaee-examples" class="bare">https://github.com/eclipse-ee4j/jakartaee-examples</a>.</p>
</div>
<div class="paragraph">
<p>Download or clone this repo, then cd into the <code>focused</code> folder and execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">mvn clean install -pl :restCustomAuthCustomStoreRememberMe</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will run a test associated with the project, printing something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">john : true
john : true
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 5.287 s - in jakartaee.examples.focused.security.restcustomauthcustomstorerememberme.RestCustomAuthCustomStoreRememberMeIT</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s take a quick look at the actual test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(Arquillian.class)
@RunAsClient
public class RestFormAuthCustomStoreRememberMeIT extends ITBase {

    @ArquillianResource
    private URL baseUrl;

    /**
     * Test the call to a protected REST service
     *
     * @throws Exception when a serious error occurs.
     */
    @RunAsClient
    @Test
    public void testRestCall() throws Exception {
        // Initial request
        HtmlPage loginPage = webClient.getPage(baseUrl + "/rest/resource");
        System.out.println(loginPage.asXml());

        // Response is login form, so we can authenticate
        HtmlForm form = loginPage.getForms()
                                 .get(0);

        form.getInputByName("j_username")
            .setValueAttribute("john");

        form.getInputByName("j_password")
            .setValueAttribute("secret1");

        // After logging in, we should get the actual resource response
        TextPage page = form.getInputByValue("Submit")
                   .click();

        System.out.println(page.getContent());

        // Remove all cookies (specially the JSESSONID), except for the
        // JREMEMBERMEID cookie which carries the token to login again
        for (Cookie cookie : webClient.getCookieManager().getCookies()) {
            if (!"JREMEMBERMEID".equals(cookie.getName())) {
                webClient.getCookieManager().removeCookie(cookie);
            }
        }

        // Should get the resource response, and not the login form
        TextPage pageAgain = webClient.getPage(baseUrl + "/rest/resource");

        System.out.println(pageAgain.getContent());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The test starts a server and deploys the output of the build process (a .war file) to it. The test runs in the integration test phase, rather than the unit test phase, to make sure this build output is available when it runs. The test then sends a request to the server using the provided HtmlUnit <code>webClient</code>. Note that the <code>webClient</code> can be used for any other HTTP requests your test requires.</p>
</div>
<div class="paragraph">
<p>If you want to inspect the app yourself, you can manually deploy the WAR file (<code>security/restCustomAuthCustomStoreRememberMe/target/restCustomAuthCustomStoreRememberMe.war</code>) to the server of your choice (e.g. <a href="https://projects.eclipse.org/projects/ee4j.glassfish" class="external" target="_blank" rel="noopener">GlassFish 7</a>), and request the URL via a browser or a commandline util such as <code>curl</code>.</p>
</div>
<div class="paragraph">
<p>The <code>webClient.addRequestHeader()</code> calls used here make sure that the headers for our custom authentication mechanism are added to the request. The authentication mechanism that we defined for our applications reads those headers, extracts the username and password from them, and consults our identity store with them.</p>
</div>
<div class="paragraph">
<p>The test sends a request here to the protected resource along with the headers we mentioned above, and the server responds with the right content.</p>
</div>
<div class="paragraph">
<p>Then we delete all cookies, except for the <code>JREMEMBERMEID</code> cookie, and we unset all headers that we used before. The test then does another request, and this time the value from the <code>JREMEMBERMEID</code> cookie is used to login.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_securing_an_endpoint_with_openid_connect_authentication"><a class="anchor" href="#_securing_an_endpoint_with_openid_connect_authentication"></a>Securing an endpoint with OpenID Connect authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the following example, we&#8217;ll be securing a REST endpoint using OpenID Connect authentication.</p>
</div>
<div class="paragraph">
<p>With <a href="https://en.wikipedia.org/wiki/OpenID" class="external" target="_blank" rel="noopener">OpenID Connect</a> authentication a caller is redirected to a third party server, typically a public one such as Google, Facebook, Linkedin, Apple, and more, but it can be a private one as well. The caller authenticates with that third party server, and is then redirected back along with a token. Our server than validates that token, and if it&#8217;s valid the caller is considered authenticated.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll learn how to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#specifying-security-constraints" class="external" target="_blank" rel="noopener">Define security constraints</a></p>
</li>
<li>
<p>Use the <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/openidauthenticationmechanismdefinition" class="external" target="_blank" rel="noopener">OpenID Connect authentication mechanism</a></p>
</li>
<li>
<p>Define (and implicitly set) a custom identity store used for authorization only</p>
</li>
<li>
<p>Use the Jakarta Security <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a></p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_write_the_application_9"><a class="anchor" href="#_write_the_application_9"></a>Write the application</h3>
<div class="paragraph">
<p>Let&#8217;s start with defining a simple REST resource class for a <code>/rest/resource</code> endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/resource")
@RequestScoped
public class Resource {

    @Inject
    private SecurityContext securityContext;

    @GET
    @Produces(TEXT_PLAIN)
    public String getCallerAndRole() {
        return
            securityContext.getCallerPrincipal().getName() + " : " +
            securityContext.isCallerInRole("user");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This resource uses the injected Jakarta EE <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> to obtain access to the current authenticated caller, which is represented by a <code>Principal</code> instance.</p>
</div>
<div class="paragraph">
<p>If this resource were available to unauthenticated callers, <code>getCallerPrincipal()</code> would return <code>null</code> for unauthenticated requests, so we&#8217;d have to check for <code>null</code>. Our example, however, requires authentication for this resource, so we can skip that check.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a Jakarta REST-specific type that is also named <a href="https://jakarta.ee/specifications/restful-ws/3.1/apidocs/jakarta.ws.rs/jakarta/ws/rs/core/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> and has similar methods as the ones we used here. From the Jakarta EE perspective, that is a discouraged type and the Jakarta Security version is to be preferred.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_declare_the_security_constraints_4"><a class="anchor" href="#_declare_the_security_constraints_4"></a>Declare the security constraints</h4>
<div class="paragraph">
<p>Next we&#8217;ll define the security constraints in <code>web.xml</code>, which tell the security system that access to a given URL or URL pattern is protected, and hence authentication is required:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="6.0"
    xmlns="https://jakarta.ee/xml/ns/jakartaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"&gt;

    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;protected&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;user&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
    &lt;/security-constraint&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This XML essentially says that to access any URL that starts with "/rest" requires the caller to have the role "user". Roles are opaque strings; merely identifiers. It&#8217;s fully up to the application how broad or fine-grained they are.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In Jakarta EE, internally these XML constraints are transformed into <code>Permission</code> instances and made available via a specific type of permission store. Knowledge about this transformation is only needed for very advanced use cases.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The observant reader may wonder if XML is really the only option here, given the strong feelings that exist in parts of the community around XML. The answer is yes and no. Jakarta EE does define the <a href="https://jakarta.ee/specifications/annotations/2.1/annotations-spec-2.1.html#jakarta-annotation-security-rolesallowed" class="external" target="_blank" rel="noopener">@RolesAllowed</a> annotation that could be used to replace the XML shown above, but only the legacy Enterprise Beans has specified a behaviour for this when put on an Enterprise Bean. Jakarta REST has done no such thing, although the <a href="https://microprofile.io/project/eclipse/microprofile-jwt-auth/spec/src/main/asciidoc/configuration.asciidoc" class="external" target="_blank" rel="noopener">JWT API in MicroProfile</a> has defined this for REST resources. In Jakarta EE, however, this remains a vendor-specific extension. There are also a number of <a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#programmatic-security-policy-configuration" class="external" target="_blank" rel="noopener">annotations and APIs</a> in Jakarta EE to set these kinds of constraints for individual Servlets, but those won&#8217;t help us much either here.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_declare_the_authentication_mechanism_4"><a class="anchor" href="#_declare_the_authentication_mechanism_4"></a>Declare the authentication mechanism</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@OpenIdAuthenticationMechanismDefinition(
    providerURI = "https://localhost:8443/openid-connect-server-webapp", <i class="conum" data-value="1"></i><b>(1)</b>
    clientId = "client", <i class="conum" data-value="2"></i><b>(2)</b>
    clientSecret = "secret", <i class="conum" data-value="3"></i><b>(3)</b>
    redirectToOriginalResource = true <i class="conum" data-value="4"></i><b>(4)</b>
)
@ApplicationScoped
@ApplicationPath("/rest")
public class ApplicationConfig extends Application {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To declare the usage of a specific authentication mechanism, Jakarta EE provides <code>[XYZ]MechanismDefinition</code> annotations. Such an annotation is picked up by the security system, and in response to it a CDI bean that implements the <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/httpauthenticationmechanism" class="external" target="_blank" rel="noopener">HttpAuthenticationMechanism</a> is enabled for it.</p>
</div>
<div class="paragraph">
<p>The annotation can be put on any bean, but in a REST application it fits particularly well on the <code>Application</code> subclass because it also declares the path for REST resources.</p>
</div>
<div class="paragraph">
<p>Contrary to the Basic HTTP authentication mechanism and the Form authentication mechanism, the OpenID Connect authentication mechanism requires a third party server that performs the actual authentication. Such third party server is called the OpenID Connect Provider (OIDC provider or OpenID Provider are also used). After authentication this provider handles user consent and and issues a token. The client requesting a user&#8217;s authentication is called a Relying Party. In the case of Jakarta EE and Jakarta Security, the Jakarta EE server running the OpenID Connect authentication mechanism is a Relying Party.</p>
</div>
<div class="paragraph">
<p>To use this authentication mechanism, Jakarta Security provides the <code>@OpenIdAuthenticationMechanismDefinition</code> annotation, for which we typically need 3 mandatory configuration items as shown in the example code above.</p>
</div>
<div class="paragraph">
<p>The first is the <code>providerURI</code> (1), which points to the third party OpenID Connect Provider. In this example we use <code><a href="https://localhost:8443/openid-connect-server-webapp" class="bare">https://localhost:8443/openid-connect-server-webapp</a></code>, which is the URL on which the example code has installed and started a local OpenID Connect provider called "Mitre". Whenever a caller accesses a protected resource, that caller is redirected to that OpenID Connect Provider.</p>
</div>
<div class="paragraph">
<p>The OpenId authentication mechanism needs to identify itself to the OpenID Connect Provider via a username/password (called <code>clientId</code> (2) and <code>clientSecret</code> (3)). We use "client" respectively "secret" here for those, which are the credentials for a default client that is available in Mitre.</p>
</div>
<div class="paragraph">
<p>After a caller successfully authenticates with the OpenID Connect Provider, that caller is redirected back to a URL on the Relying Party (our Jakarta EE server). This is called the "callback URL" and can be set via the <code>redirectURI</code> attribute. The default value is <code>${baseURL}/Callback</code>, where <code>${baseURL}</code> expands to the context-root of the application that uses Jakarta Security, for example <code><a href="https://localhost:8080/openid-client" class="bare">https://localhost:8080/openid-client</a></code> in our example. This exact URI must be known to Mitre. Mitre (and any OpenID Connect Provider in general) never redirects to unknown URIs.</p>
</div>
<div class="paragraph">
<p>By default, after the caller is redirected back to the Relying Party (our Jakarta EE server), the resource behind <code>/Callback</code> is invoked. When the attribute <code>redirectToOriginalResource</code> (4) is set to <code>true</code> however, the caller is once again redirected to the URL originally requested and which triggered the authentication process.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When <code>redirectToOriginalResource</code> is set to to <code>true</code> it&#8217;s not necessary to actually map anything to the callback URL (for example a Servlet or a REST resource). The authentication mechanism is invoked before the resource mapped to the callback URL is invoked, so if the authentication mechanism always redirects it never invokes this resource and the resource therefore doesn&#8217;t need to actually exist.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_define_the_identity_store_6"><a class="anchor" href="#_define_the_identity_store_6"></a>Define the identity store</h4>
<div class="paragraph">
<p>In many cases the OpenID Connect Provider has no knowledge of the application for which it authenticates the caller, and therefore does not normally provide any logical groups for the authenticated user. Those groups are application specific after all. We therefore define an additional identity store that does provide those groups for a caller.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Despite not being typical, Jakarta Security supports getting the groups via the <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/openidauthenticationmechanismdefinition#claimsDefinition()" class="external" target="_blank" rel="noopener">claimsDefinition</a> attribute of the <code>@OpenIdAuthenticationMechanismDefinition</code> annotation. This can be used to set a claim name (default is "groups"). Jakarta Security then tries to find this name in the <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/openid/accesstoken" class="external" target="_blank" rel="noopener">AccessToken</a>, <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/openid/identitytoken" class="external" target="_blank" rel="noopener">IdentityToken</a>, or in the info returned by the <code>/userinfo</code> endpoint of the OpenId Connect Provider. Providers often need special configuration to return group claims.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class AuthorizationIdentityStore implements IdentityStore {

    private Map&lt;String, Set&lt;String&gt;&gt; groupsPerCaller =
        Map.of("user", Set.of("user")); <i class="conum" data-value="2"></i><b>(2)</b>

    @Override
    public Set&lt;ValidationType&gt; validationTypes() {
        return EnumSet.of(PROVIDE_GROUPS); <i class="conum" data-value="1"></i><b>(1)</b>
    }

    @Override
    public Set&lt;String&gt; getCallerGroups(
        CredentialValidationResult validationResult) { <i class="conum" data-value="3"></i><b>(3)</b>
        return groupsPerCaller.get(validationResult.getCallerPrincipal().getName());
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This identity store is set to <code>PROVIDE_GROUPS</code> (1) only, which means the default <code>IdentityStoreHandler</code> will consult this identity store for groups after another identity store has successfully validated the credentials. For our example here we create a <code>Map</code> (2) with as key the caller principal name, and as value the set of groups. When the <code>IdentityStoreHandler</code> comes asking for the groups (3) of caller "user", a set with just the group "user" is returned.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As validation of the <code>IdentityToken</code> that&#8217;s returned by the OpenID Connect Provider is integral to the OpenID Connect flow and not application specific, developers don&#8217;t have to provide or define an identity store explicitly for this. Such a store is provided by Jakarta Security as an implementation detail, and automatically activated when the OpenID Connect authentication mechanism is activated.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The identity store is installed and used by the security system just by the virtue of being there; it picks up all enabled CDI beans that implement <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/identitystore" class="external" target="_blank" rel="noopener">IdentityStore</a>. Such beans can be enabled by the security system itself (following some configuration annotation), or can be programmatically added using the appropriate CDI APIs. Where the bean comes from doesn&#8217;t matter for Jakarta Security, only the fact that it&#8217;s there.</p>
</div>
</div>
<div class="sect3">
<h4 id="_install_and_configure_mitre"><a class="anchor" href="#_install_and_configure_mitre"></a>Install and configure Mitre</h4>
<div class="paragraph">
<p>Installing and configuring the OpenID Connect provider Mitre is outside the scope of Jakarta Security itself, but for completeness sake we&#8217;ll briefly discuss it by illustration of Maven pom fragments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;

    &lt;!--
        Unpack and install Tomcat + Mitre

        Mitre is a Spring based OpenID Connect Server that best runs on a javax based Tomcat.
    --&gt;
    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;unpack&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;artifactItems&gt;
                    &lt;artifactItem&gt;
                        &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;
                        &lt;artifactId&gt;tomcat&lt;/artifactId&gt;
                        &lt;version&gt;9.0.76&lt;/version&gt;
                        &lt;type&gt;zip&lt;/type&gt;
                        &lt;outputDirectory&gt;${tomcat.root}&lt;/outputDirectory&gt;
                    &lt;/artifactItem&gt;
                    &lt;artifactItem&gt;
                        &lt;groupId&gt;org.mitre&lt;/groupId&gt;
                        &lt;artifactId&gt;openid-connect-server-webapp&lt;/artifactId&gt;
                        &lt;version&gt;1.3.4&lt;/version&gt;
                        &lt;type&gt;war&lt;/type&gt;
                        &lt;outputDirectory&gt;${tomcat.dir}/webapps/openid-connect-server-webapp&lt;/outputDirectory&gt;
                    &lt;/artifactItem&gt;
                &lt;/artifactItems&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mitre is a Spring application that uses the <code>javax.*</code> namespace. We therefore need a Tomcat from the 9.x series, which is available as a zip file from the Maven coordinates <code>org.apache.tomcat:tomcat:9.0.76</code>. Likewise, Mitre is available from <code>org.mitre:openid-connect-server-webapp:1.3.4</code>. We simply need to unzip Tomcat, and unzip Mitre into its <code>webapps</code> folder. We also need to update Tomcat with the JAXB standalone libraries (see full example code).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!--
    Configure Tomcat to use HTTPS, as Open ID Connect strictly speaking requires this.
    Some servers may refuse to use Open ID Connect if not running on a secure connection.

    Also configure Mitre to use the callback of our client.

    Then start Tomcat and with it Mitre.
--&gt;
&lt;plugin&gt;
    &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;run&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;target&gt;
                    &lt;echo level="info"&gt;Replacing in ${tomcat.dir}&lt;/echo&gt;

                    &lt;!-- Configure Mitre to let it know its running on HTTPS  --&gt;
                    &lt;replace token="http://localhost:8080" value="https://localhost:8443" dir="${tomcat.dir}/webapps/openid-connect-server-webapp/WEB-INF" summary="yes"&gt;
                        &lt;include name="server-config.xml" /&gt;
                    &lt;/replace&gt;

                    &lt;!-- Configure Mitre to let it know where the Open ID callback needs to go to --&gt;
                    &lt;replace token="http://localhost/" value="http://localhost:8080/openid-client/Callback" dir="${tomcat.dir}/webapps/openid-connect-server-webapp/WEB-INF/classes/db/hsql" summary="yes"&gt;
                        &lt;include name="clients.sql" /&gt;
                    &lt;/replace&gt;

                    &lt;!-- Configure Tomcat using our pre-configured server.xml (which sets https) --&gt;
                    &lt;copy file="src/test/resources/server.xml" todir="${tomcat.dir}/conf"/&gt;
                    &lt;copy file="src/test/resources/localhost-rsa.jks" todir="${tomcat.dir}/conf"/&gt;

                    &lt;chmod dir="${tomcat.dir}/bin" perm="ugo+rx" includes="*" /&gt;

                    &lt;!-- Start Tomcat and Mitre --&gt;
                    &lt;exec executable="${tomcat.dir}/bin/startup.sh" dir="${tomcat.dir}" &gt;
                        &lt;env key="CATALINA_PID" value="${tomcat.pidfile}" /&gt;
                    &lt;/exec&gt;
                &lt;/target&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Out of the box Mitre runs on HTTP, but since we&#8217;re using HTTPS instead we need to configure it to run on HTTPS using the <code>server-config.xml</code> file. We also need to tell it about the exact callback URL that we discussed above (<code><a href="http://localhost:8080/openid-client/Callback" class="bare">http://localhost:8080/openid-client/Callback</a></code>), which can be done in <code>clients.sql</code>. Tomcat has to be configured to run on HTTPS as well, which requires updating <code>server.xml</code> and providing it with a keystore.</p>
</div>
<div class="paragraph">
<p>Tomcat, and with it Mitre, can be started by executing <code>[tomcat dir]/bin/startup.sh</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_test_the_application_9"><a class="anchor" href="#_test_the_application_9"></a>Test the application</h4>
<div class="paragraph">
<p>It&#8217;s now time to test our application. A ready-to-test version is available from the Jakarta EE Examples project at <a href="https://github.com/eclipse-ee4j/jakartaee-examples" class="bare">https://github.com/eclipse-ee4j/jakartaee-examples</a>.</p>
</div>
<div class="paragraph">
<p>Download or clone this repo, then cd into the <code>focused</code> folder and execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">mvn clean install -pl :restOpenIdConnectAuth</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will run a test associated with the project, printing something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">user : true
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 22.324 s - in jakartaee.examples.focused.security.restopenidconnectauth.RestOpenIdConnectAuthIT</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s take a quick look at the actual test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(Arquillian.class)
@RunAsClient
public class RestOpenIdConnectAuthIT extends ITBase {

    @ArquillianResource
    private URL baseUrl;

    /**
     * Test the call to a protected REST service
     *
     * @throws Exception when a serious error occurs.
     */
    @RunAsClient
    @Test
    public void testRestCall() throws Exception {
        HtmlPage page = webClient.getPage(baseUrl + "/rest/resource"); <i class="conum" data-value="1"></i><b>(1)</b>

        // Authenticate with the OpenId Provider using the
        // username and password for a default user
        page.getElementById("j_username")
            .setAttribute("value", "user");

        page.getElementById("j_password")
            .setAttribute("value", "password"); <i class="conum" data-value="2"></i><b>(2)</b>

        // Submit
        HtmlPage confirmationPage =
            page.getElementByName("submit")
                .click(); <i class="conum" data-value="3"></i><b>(3)</b>

        // Confirm
        TextPage originalResource =
            confirmationPage.getElementByName("authorize")
                            .click(); <i class="conum" data-value="4"></i><b>(4)</b>

        System.out.println(originalResource.getContent());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The test starts a server and deploys the output of the build process (a .war file) to it. The test runs in the integration test phase, rather than the unit test phase, to make sure this build output is available when it runs. The test then sends a request to the server using the provided HtmlUnit <code>webClient</code>. Note that the <code>webClient</code> can be used for any other HTTP requests your test requires.</p>
</div>
<div class="paragraph">
<p>If you want to inspect the app yourself, you can manually deploy the WAR file (<code>security/restOpenIdConnectAuth/target/restOpenIdConnectAuth.war</code>) to the server of your choice (e.g. <a href="https://projects.eclipse.org/projects/ee4j.glassfish" class="external" target="_blank" rel="noopener">GlassFish 7</a>), and request the URL via a browser or a commandline util such as <code>curl</code>.</p>
</div>
<div class="paragraph">
<p>After the test requests our protected resource at "/rest/resource" (1), the OpenID Connect authentication mechanism redirects to Mitre, which will respond with a login page. The test programmically sets the fields <code>j_username</code> and <code>j_password</code>, (2) and then clicks submits (3). After confirming (4), Mitre will redirect the test code back to the <code>/Callback</code> URL, which will redirect back to the original resource at "/rest/resource".</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_securing_an_endpoint_with_basic_authentication_and_an_ldap_identity_store"><a class="anchor" href="#_securing_an_endpoint_with_basic_authentication_and_an_ldap_identity_store"></a>Securing an endpoint with Basic authentication and an LDAP identity store</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the following example, we&#8217;ll secure a REST endpoint using Basic authentication and the LDAP identity store that is provided by Jakarta Security.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll learn how to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#specifying-security-constraints" class="external" target="_blank" rel="noopener">Define security constraints</a></p>
</li>
<li>
<p>Use the provided <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/basicauthenticationmechanismdefinition" class="external" target="_blank" rel="noopener">BasicAuthenticationMechanismDefinition</a></p>
</li>
<li>
<p>Use the provided <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/ldapidentitystoredefinition" class="external" target="_blank" rel="noopener">LdapIdentityStoreDefinition</a></p>
</li>
<li>
<p>Populate and configure the identity store</p>
</li>
<li>
<p>Use the Jakarta Security <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a></p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_write_the_application_10"><a class="anchor" href="#_write_the_application_10"></a>Write the application</h3>
<div class="paragraph">
<p>Let&#8217;s start with defining a simple REST resource class for a <code>/rest/resource</code> endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/resource")
@RequestScoped
public class Resource {

    @Inject
    private SecurityContext securityContext;

    @GET
    @Produces(TEXT_PLAIN)
    public String getCallerAndRole() {
        return
            securityContext.getCallerPrincipal().getName() + " : " +
            securityContext.isCallerInRole("user");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This resource uses the injected Jakarta EE <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> to obtain access to the current authenticated caller, which is represented by a <code>Principal</code> instance.</p>
</div>
<div class="paragraph">
<p>If this resource were available to unauthenticated callers, <code>getCallerPrincipal()</code> would return <code>null</code> for unauthenticated requests, so we&#8217;d have to check for <code>null</code>. Our example, however, requires authentication for this resource, so we can skip that check.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a Jakarta REST-specific type that is also named <a href="https://jakarta.ee/specifications/restful-ws/3.1/apidocs/jakarta.ws.rs/jakarta/ws/rs/core/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> and has similar methods as the ones we used here. From the Jakarta EE perspective, that is a discouraged type and the Jakarta Security version is to be preferred.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_declare_the_authentication_mechanism_and_identity_store_4"><a class="anchor" href="#_declare_the_authentication_mechanism_and_identity_store_4"></a>Declare the authentication mechanism and identity store</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@BasicAuthenticationMechanismDefinition(
    realmName = "basicAuth"
)
@LdapIdentityStoreDefinition(
    url = "ldap://localhost:40000",
    callerBaseDn = "ou=caller,dc=jakartaee",
    groupSearchBase = "ou=group,dc=jakartaee",
    groupSearchFilter = "(&amp;(member=%s)(objectclass=groupofnames))"
)
@ApplicationPath("/rest")
public class ApplicationConfig extends Application {</code></pre>
</div>
</div>
<div class="paragraph">
<p>To declare the usage of a specific authentication mechanism, Jakarta EE provides <code>[XYZ]MechanismDefinition</code> annotations. Such an annotation is picked up by the security system, and in response to it a CDI bean that implements the <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/httpauthenticationmechanism" class="external" target="_blank" rel="noopener">HttpAuthenticationMechanism</a> is enabled for it.</p>
</div>
<div class="paragraph">
<p>The annotation can be put on any bean, but in a REST application it fits particularly well on the <code>Application</code> subclass because it also declares the path for REST resources.</p>
</div>
<div class="paragraph">
<p>Likewise, to declare the usage of a specific identity store, Jakarta EE provides <code>[XYZ]StoreDefinition</code> annotations.</p>
</div>
<div class="paragraph">
<p>The annotations can be put on any bean, but in a REST application it fits particularly well on the <code>Application</code> subclass that also declares the path for REST resources.</p>
</div>
<div class="paragraph">
<p>You can use the provided <code>@LdapIdentityStoreDefinition</code> with any authentication mechanism that validates username/password credentials. LDAP structures are very open-ended, and there&#8217;s a lot of possible ways to model callers, their passwords, and their groups. We&#8217;ll present one way here, where we&#8217;ll define a <code>caller.jakartaee</code> object, that contains the caller name and password, and a <code>group.jakartaee</code> object that contains the group name and a list of all callers in that group.</p>
</div>
<div class="paragraph">
<p>For this structure we need 3 attributes to be defined:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>callerBaseDn</code> - Used for credential validation using "direct binding", with the default caller name being "uid".</p>
</li>
<li>
<p><code>groupSearchBase</code> - The object root used to search for groups of the caller</p>
</li>
<li>
<p><code>groupSearchFilter</code> - The subtree to search for groups</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_populating_the_identity_store_4"><a class="anchor" href="#_populating_the_identity_store_4"></a>Populating the identity store</h4>
<div class="paragraph">
<p>In order to use the identity store, we need to put some data in an LDAP server. The following code shows one way how to do that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@BasicAuthenticationMechanismDefinition(
    realmName = "basicAuth"
)
@LdapIdentityStoreDefinition(
    url = "ldap://localhost:40000",
    callerBaseDn = "ou=caller,dc=jakartaee",
    groupSearchBase = "ou=group,dc=jakartaee",
    groupSearchFilter = "(&amp;(member=%s)(objectclass=groupofnames))"
)
@DeclareRoles("user")
@ApplicationPath("/rest")
public class ApplicationConfig extends Application {

    private InMemoryDirectoryServer directoryServer;

    public void onStart(@Observes @Initialized(ApplicationScoped.class) Object applicationContext) {
        try {
            InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig("dc=jakartaee");
            config.setListenerConfigs(
                new InMemoryListenerConfig("myListener", null, 40000, null, null, null));

            directoryServer = new InMemoryDirectoryServer(config);

            directoryServer.importFromLDIF(true,
                new LDIFReader(new ByteArrayInputStream("""

                        # Define caller.jakartaee and group.jakartaee structure

                        dn: dc=jakartaee
                        objectclass: top
                        objectclass: dcObject
                        objectclass: organization
                        dc: jakartaee
                        o: jakartaee

                        dn: ou=caller,dc=jakartaee
                        objectclass: top
                        objectclass: organizationalUnit
                        ou: caller

                        dn: ou=group,dc=jakartaee
                        objectclass: top
                        objectclass: organizationalUnit
                        ou: group


                        # Add caller john:secret1 and group user with member john

                        dn: uid=john,ou=caller,dc=jakartaee
                        objectclass: top
                        objectclass: uidObject
                        objectclass: person
                        uid: john
                        cn: John Smith
                        sn: John
                        userPassword: secret1

                        dn: cn=user,ou=group,dc=jakartaee
                        objectclass: top
                        objectclass: groupOfNames
                        cn: user
                        member: uid=john,ou=caller,dc=jakartaee

                        """.getBytes())));

            directoryServer.startListening();
        } catch (LDAPException e) {
            throw new IllegalStateException(e);
        }
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code above uses an in-memory LDAP server called Unboundid that we start on port 40000. We populate it using embedded LDIF, which is a popular format to configure LDAP servers.</p>
</div>
<div class="paragraph">
<p>In-depth explanation of LDAP itself is beyond the scope of this tutorial, but we&#8217;ll briefly explain the process here. When a caller authenticates with username "john" and password "secret1", our LDAP identity store will construct the full name "uid=john,ou=caller,dc=jakartaee" using <code>callerNameAttribute</code> ("uid" as a default), and <code>callerBaseDn</code> ("ou=caller,dc=jakartaee" here). The store then uses the LDAP 'Bind' operation and directly attempts to "log in" as that user to the LDAP server. Unlike the Database identity store, the LDAP store doesn&#8217;t look up and compare the passwords. If the aforementioned login succeeds, the credentials are assumed to be correct.</p>
</div>
<div class="paragraph">
<p>The LDAP store will then search for groups using the <code>javax.naming.directory.DirContext.search()</code> method, with the <code>groupSearchBase</code> value ("ou=group,dc=jakartaee") and the formatted value from <code>groupSearchFilter</code> ("(&amp;(member=uid=john,ou=caller,dc=jakartaee)(objectclass=groupofnames))") as parameters. The LDAP server will subsequently return "cn=user,ou=group,dc=jakartaee" for our example. From this the value of <code>groupNameAttribute</code> (defaults to "cn") is taken, which resolves to "user" here.</p>
</div>
</div>
<div class="sect3">
<h4 id="_test_the_application_10"><a class="anchor" href="#_test_the_application_10"></a>Test the application</h4>
<div class="paragraph">
<p>It&#8217;s now time to test our application. A ready-to-test version is available from the Jakarta EE Examples project at <a href="https://github.com/eclipse-ee4j/jakartaee-examples" class="bare">https://github.com/eclipse-ee4j/jakartaee-examples</a>.</p>
</div>
<div class="paragraph">
<p>Download or clone this repo, then cd into the <code>focused</code> folder and execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">mvn clean install -pl :restBasicAuthLdapStore</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will run a test associated with the project, printing something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">john : true
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 8.247 s - in jakartaee.examples.focused.security.restBasicAuthLdapStore.RestBasicAuthLdapStoreIT</code></pre>
</div>
</div>
<div class="paragraph">
<p>The test itself is basically the same as that for the <a href="#_securing_an_endpoint_with_basic_authentication">Securing an endpoint with Basic authentication</a> example.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_securing_an_endpoint_with_custom_form_authentication"><a class="anchor" href="#_securing_an_endpoint_with_custom_form_authentication"></a>Securing an endpoint with Custom Form authentication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the following example, we&#8217;ll secure a REST endpoint using Custom Form authentication.</p>
</div>
<div class="paragraph">
<p>You&#8217;ll learn how to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#specifying-security-constraints" class="external" target="_blank" rel="noopener">Define security constraints</a></p>
</li>
<li>
<p>Use the <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/customformauthenticationmechanismdefinition" class="external" target="_blank" rel="noopener">Custom Form authentication mechanism</a></p>
</li>
<li>
<p>Use Jakarta Faces and Jakarta Validation to customize the Form used for Form authentication</p>
</li>
<li>
<p>How to define (and implicitly set) a custom <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/package-summary.html" class="external" target="_blank" rel="noopener">identity store</a></p>
</li>
<li>
<p>Use the Jakarta Security <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a></p>
</li>
</ol>
</div>
<div class="sect2">
<h3 id="_write_the_application_11"><a class="anchor" href="#_write_the_application_11"></a>Write the application</h3>
<div class="paragraph">
<p>Let&#8217;s start with defining a simple REST resource class for a <code>/rest/resource</code> endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Path("/resource")
@RequestScoped
public class Resource {

    @Inject
    private SecurityContext securityContext;

    @GET
    @Produces(TEXT_PLAIN)
    public String getCallerAndRole() {
        return
            securityContext.getCallerPrincipal().getName() + " : " +
            securityContext.isCallerInRole("user");
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This resource uses the injected Jakarta EE <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> to obtain access to the current authenticated caller, which is represented by a <code>Principal</code> instance.</p>
</div>
<div class="paragraph">
<p>If this resource were available to unauthenticated callers, <code>getCallerPrincipal()</code> would return <code>null</code> for unauthenticated requests, so we&#8217;d have to check for <code>null</code>. Our example, however, requires authentication for this resource, so we can skip that check.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a Jakarta REST-specific type that is also named <a href="https://jakarta.ee/specifications/restful-ws/3.1/apidocs/jakarta.ws.rs/jakarta/ws/rs/core/securitycontext" class="external" target="_blank" rel="noopener">SecurityContext</a> and has similar methods as the ones we used here. From the Jakarta EE perspective, that is a discouraged type and the Jakarta Security version is to be preferred.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_declare_the_security_constraints_5"><a class="anchor" href="#_declare_the_security_constraints_5"></a>Declare the security constraints</h4>
<div class="paragraph">
<p>Next we&#8217;ll define the security constraints in <code>web.xml</code>, which tell the security system that access to a given URL or URL pattern is protected, and hence authentication is required:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="6.0"
    xmlns="https://jakarta.ee/xml/ns/jakartaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd"&gt;

    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;protected&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/rest/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;user&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
    &lt;/security-constraint&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This XML essentially says that to access any URL that starts with "/rest" requires the caller to have the role "user". Roles are opaque strings; merely identifiers. It&#8217;s fully up to the application how broad or fine-grained they are.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In Jakarta EE, internally these XML constraints are transformed into <code>Permission</code> instances and made available via a specific type of permission store. Knowledge about this transformation is only needed for very advanced use cases.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The observant reader may wonder if XML is really the only option here, given the strong feelings that exist in parts of the community around XML. The answer is yes and no. Jakarta EE does define the <a href="https://jakarta.ee/specifications/annotations/2.1/annotations-spec-2.1.html#jakarta-annotation-security-rolesallowed" class="external" target="_blank" rel="noopener">@RolesAllowed</a> annotation that could be used to replace the XML shown above, but only the legacy Enterprise Beans has specified a behaviour for this when put on an Enterprise Bean. Jakarta REST has done no such thing, although the <a href="https://microprofile.io/project/eclipse/microprofile-jwt-auth/spec/src/main/asciidoc/configuration.asciidoc" class="external" target="_blank" rel="noopener">JWT API in MicroProfile</a> has defined this for REST resources. In Jakarta EE, however, this remains a vendor-specific extension. There are also a number of <a href="https://jakarta.ee/specifications/servlet/6.0/jakarta-servlet-spec-6.0.html#programmatic-security-policy-configuration" class="external" target="_blank" rel="noopener">annotations and APIs</a> in Jakarta EE to set these kinds of constraints for individual Servlets, but those won&#8217;t help us much either here.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_declare_the_authentication_mechanism_5"><a class="anchor" href="#_declare_the_authentication_mechanism_5"></a>Declare the authentication mechanism</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
@CustomFormAuthenticationMechanismDefinition(
    loginToContinue = @LoginToContinue(
        loginPage="/login.xhtml",
        errorPage=""
    )
)
@DeclareRoles({ "user", "caller" })
@FacesConfig
@ApplicationPath("/rest")
public class ApplicationConfig extends Application {

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To declare the usage of a specific authentication mechanism, Jakarta EE provides <code>[XYZ]MechanismDefinition</code> annotations. Such an annotation is picked up by the security system, and in response to it a CDI bean that implements the <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/authentication/mechanism/http/httpauthenticationmechanism" class="external" target="_blank" rel="noopener">HttpAuthenticationMechanism</a> is enabled for it.</p>
</div>
<div class="paragraph">
<p>The annotation can be put on any bean, but in a REST application it fits particularly well on the <code>Application</code> subclass because it also declares the path for REST resources.</p>
</div>
<div class="paragraph">
<p>Contrary to the Basic HTTP authentication mechanism, the Form authentication mechanism allows us to customize the login dialog (the process between the caller and the authentication mechanism) and to keep track of the authenticated session on the server (using a cookie). This also allows us to logout, something that for unknown reasons has never been specified for Basic HTTP authentication.</p>
</div>
<div class="paragraph">
<p>Contrary to the regular Form authentication mechanism, the Custom Form authentication mechanism lets us customize the login dialog even more by having the ability to execute custom code between the postback of a login form and the form authentication mechanism taking the provided credentials.</p>
</div>
<div class="paragraph">
<p>To use this authentication method, we need to designate a path to a resource that is relative to our application. The authentication mechanism will redirect the caller to this resource when authentication is required. The resource can be anything, but a postback should eventually lead to some code being executed that continues the authentication dialog. For example a plain .html file or .jsp file combined with  a Filter, or a Faces view with a backing bean.</p>
</div>
</div>
<div class="sect3">
<h4 id="_define_the_authentication_mechanisms_view_and_backing_code"><a class="anchor" href="#_define_the_authentication_mechanisms_view_and_backing_code"></a>Define the authentication mechanism&#8217;s view and backing code</h4>
<div class="paragraph">
<p>For this example we&#8217;ll use a Faces view with a backing bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!DOCTYPE html&gt;
&lt;html lang="en" xmlns:h="jakarta.faces.html" &gt;
    &lt;h:head/&gt;

    &lt;h:body&gt;
        &lt;h1&gt;
            Login to continue
        &lt;/h1&gt;

        &lt;h:messages /&gt;

        &lt;h:form id="form"&gt;
            &lt;div&gt;
                &lt;h:outputLabel for="username" value="Username" /&gt;
                &lt;h:inputText id="username" value="#{loginBacking.username}"/&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;h:outputLabel for="password" value="Password" /&gt;
                &lt;h:inputSecret id="password" value="#{loginBacking.password}"/&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;h:commandButton value="Login" type="submit" action="#{loginBacking.login}" /&gt;
            &lt;/div&gt;
        &lt;/h:form&gt;
    &lt;/h:body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Named
@RequestScoped
public class LoginBacking {

    @Inject
    private SecurityContext securityContext;

    @Inject
    private FacesContext facesContext;

    @NotNull
    @Size(min = 3, max = 15, message="Username must be between 3 and 15 characters")
    private String username;

    @NotNull
    @Size(min = 5, max = 50, message="Password must be between 5 and 50 characters")
    private String password;

    public void login() {
        switch (
            // Continue the authentication dialog manually by invoking the authenticate()
            // method. The form authentication picks this up, just like a post to j_security does.
            securityContext.authenticate(
                getRequest(),
                getResponse(),
                withParams()
                    .credential(new UsernamePasswordCredential(username, new Password(password))))) {

            case SEND_CONTINUE:

                // Authentication mechanism has send a redirect, should not
                // send anything to response from Faces now.
                facesContext.responseComplete();
                return;

            case SEND_FAILURE:

                addError("Login failed");
                return;

            default:
        }
    }

    // getters/setters + utility methods omitted
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The view itself is quite similar to the HTML page we used for the form in <a href="#_securing_an_endpoint_with_form_authentication">Securing an endpoint with Form authentication</a>. The main difference is bindings of the form fields to a (CDI) backing bean. The bean side of the binding has Jakarta Validation constraints applied to it; this allows for fine-grained validation of some general requirements of the credentials without actually attempting authentication.</p>
</div>
<div class="paragraph">
<p>If this initial validation passes, we arrive in the <code>login()</code> method. For our example the only thing we need to do here is signaling that we want to continue the authentication dialog (the process or interaction between the caller and the authentication mechanism), and when doing so provide the credentials that we earlier obtained in a custom way.</p>
</div>
<div class="paragraph">
<p>We have two important outcomes to handle. <code>SEND_CONTINUE</code> effectively means the credentials were validated successfully, and the caller is therefore directed to the resource that was originally requested. <code>SEND_FAILURE</code> means the opposite; the credentials were not validated successfully. By just returning from our callback method in the last case the form will be redisplayed, albeit with the error message added.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>NOT_DONE</code> and <code>SUCCESS</code> are two other outcomes, but we don&#8217;t have to handle them here. <code>NOT_DONE</code> only applies to pre-emptive authentication, but we&#8217;re doing explicit (forced, mandatory) authentication here. <code>SUCCESS</code> means we can go ahead and render the page, which is exactly what happens if we don&#8217;t do anything.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See <a href="../web/webapp/webapp.html#_getting_started_with_web_applications" class="xref page">Getting Started with Web Applications</a> for more information on running <code>.xhtml</code> files and their backing beans.</p>
</div>
</div>
<div class="sect3">
<h4 id="_define_the_identity_store_7"><a class="anchor" href="#_define_the_identity_store_7"></a>Define the identity store</h4>
<div class="paragraph">
<p>Finally, let&#8217;s define a basic identity store that the security system can use to validate provided credentials for Form authentication:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class CustomIdentityStore implements IdentityStore {

    public CredentialValidationResult validate(UsernamePasswordCredential usernamePasswordCredential) {
        if (usernamePasswordCredential.compareTo("john", "secret1")) {
            return new CredentialValidationResult("john", Set.of("user", "caller"));
        }

        return INVALID_RESULT;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This identity store only validates the single identity (user) "john", with password "secret1" and roles "user" and "caller". Defining this kind of identity store is often the simplest way to get started. Note that Jakarta Security doesn&#8217;t define a simple identity store out of the box, because there are questions about whether that would promote security best practices.</p>
</div>
<div class="paragraph">
<p>The identity store is installed and used by the security system just by the virtue of being there; it picks up all enabled CDI beans that implement <a href="https://jakarta.ee/specifications/security/3.0/apidocs/jakarta.security/jakarta/security/enterprise/identitystore/identitystore" class="external" target="_blank" rel="noopener">IdentityStore</a>. Such beans can be enabled by the security system itself (following some configuration annotation), or can be programmatically added using the appropriate CDI APIs. Where the bean comes from doesn&#8217;t matter for Jakarta Security, only the fact that it&#8217;s there.</p>
</div>
</div>
<div class="sect3">
<h4 id="_test_the_application_11"><a class="anchor" href="#_test_the_application_11"></a>Test the application</h4>
<div class="paragraph">
<p>It&#8217;s now time to test our application. A ready-to-test version is available from the Jakarta EE Examples project at <a href="https://github.com/eclipse-ee4j/jakartaee-examples" class="bare">https://github.com/eclipse-ee4j/jakartaee-examples</a>.</p>
</div>
<div class="paragraph">
<p>Download or clone this repo, then cd into the <code>focused</code> folder and execute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">mvn clean install -pl :restCustomFormAuthCustomStore</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will run a test associated with the project, printing something like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">john : true
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 9.272 s - in jakartaee.examples.focused.security.restCustomFormAuthCustomStore.RestCustomFormAuthCustomStoreIT</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s take a quick look at the actual test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@RunWith(Arquillian.class)
@RunAsClient
public class RestCustomFormAuthCustomStoreIT extends ITBase {

    @ArquillianResource
    private URL baseUrl;

    /**
     * Test the call to a protected REST service
     *
     * @throws Exception when a serious error occurs.
     */
    @RunAsClient
    @Test
    public void testRestCall() throws Exception {
        HtmlPage loginPage = webClient.getPage(baseUrl + "/rest/resource");
        System.out.println(loginPage.asXml());

        HtmlForm form = loginPage.getForms()
                                 .get(0);

        form.getInputByName("form:username")
            .setValueAttribute("john");

        form.getInputByName("form:password")
            .setValueAttribute("secret1");

        TextPage page = form.getInputByValue("Login")
                            .click();

        System.out.println(page.getContent());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The test starts a server and deploys the output of the build process (a .war file) to it. The test runs in the integration test phase, rather than the unit test phase, to make sure this build output is available when it runs. The test then sends a request to the server using the provided HtmlUnit <code>webClient</code>. Note that the <code>webClient</code> can be used for any other HTTP requests your test requires.</p>
</div>
<div class="paragraph">
<p>If you want to inspect the app yourself, you can manually deploy the WAR file (<code>security/restCustomFormAuthCustomStore/target/restCustomFormAuthCustomStore.war</code>) to the server of your choice (e.g. <a href="https://projects.eclipse.org/projects/ee4j.glassfish" class="external" target="_blank" rel="noopener">GlassFish 7</a>), and request the URL via a browser or a commandline util such as <code>curl</code>.</p>
</div>
<div class="paragraph">
<p>The test first sends a request here to the protected resource, and the server responds with the rendered version of the Faces view form we defined above. Using the <code>HtmlUnit</code> API, it&#8217;s easy to navigate the HTML DOM, fill out the username and password in the form, and programmatically click the <code>Login</code> button. The form posts back to the same URL it was requested from. Faces will detect this postback and will orchestrate the validation using Jakarta Validation and invoking the CDI based backing bean.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Technically Jakarta Interceptors is an API separate from CDI, but in modern applications they are used exclusively with CDI, hence we use the term "CDI Interceptors" here.
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
