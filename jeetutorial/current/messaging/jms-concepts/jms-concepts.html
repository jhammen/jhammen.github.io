<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Jakarta Messaging Concepts :: Jakarta EE Documentation</title>
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <script>var uiRootPath = '../../../../_'</script>
    <script>!function (theme) {
        if (theme === 'dark') document.documentElement.classList.add('theme-dark')
      }(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)') && 'dark'))
    </script>
      </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a id="site-title" class="navbar-item" href="../../../..">Jakarta EE Documentation</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
<!--
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
 -->
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="../../../../jakartaee-tutorial/10/jakarta-ee-tutorial.pdf">Download</a>
          </span>
        </div>
      </div>
      <div class="navbar-theme-switcher">
        <span class="switch" title="Switch between Light and Dark Theme">
          <input id="theme-switcher-checkbox" type="checkbox" />
          <label for="theme-switcher-checkbox">Dark Theme</label>
        </span>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="jakartaee-tutorial" data-version="10">
  <div class="toolbar"></div>
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../index.html">Jakarta EE Tutorial</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Introduction</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../index.html">Preface</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../intro/overview/overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../intro/usingexamples/usingexamples.html">Using the Tutorial Examples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Core Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta CDI Lite</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-basic/cdi-basic.html">Introduction to Jakarta Contexts and Dependency Injection</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-basicexamples/cdi-basicexamples.html">Running the Basic Contexts and Dependency Injection Examples</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../supporttechs/interceptors/interceptors.html">Using Jakarta EE Interceptors</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta REST</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../websvcs/jaxrs/jaxrs.html">Building RESTful Web Services with Jakarta REST</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../websvcs/jaxrs-client/jaxrs-client.html">Accessing REST Resources with the Jakarta REST Client API</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../websvcs/jaxrs-advanced/jaxrs-advanced.html">Jakarta REST: Advanced Topics and an Example</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta JSON</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/jsonb/jsonb.html">JSON Binding</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/jsonp/jsonp.html">JSON Processing</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Web Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta CDI Full</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-adv/cdi-adv.html">Jakarta Contexts and Dependency Injection: Advanced Topics</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-bootstrap-se8/cdi-bootstrap-se8.html">Bootstrapping a CDI Container in Java SE</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-adv-examples/cdi-adv-examples.html">Running the Advanced Contexts and Dependency Injection Examples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Validation</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../beanvalidation/bean-validation/bean-validation.html">Introduction to Jakarta Bean Validation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../beanvalidation/bean-validation-advanced/bean-validation-advanced.html">Bean Validation: Advanced Topics</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../security/security.html">Jakarta Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Servlets</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/webapp/webapp.html">Getting Started with Web Applications</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/servlets/servlets.html">Jakarta Servlet Technology</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Faces</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/faces-intro/faces-intro.html">Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/faces-facelets/faces-facelets.html">Introduction to Facelets</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/faces-page/faces-page.html">Using Jakarta Faces Technology in Web Pages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/faces-page-core/faces-page-core.html">Using Converters, Listeners, and Validators</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/faces-develop/faces-develop.html">Developing with Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/faces-ajax/faces-ajax.html">Using Ajax with Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/faces-advanced-cc/faces-advanced-cc.html">Composite Components: Advanced Topics and an Example</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/faces-custom/faces-custom.html">Creating Custom UI Components and Other Custom Objects</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/faces-configure/faces-configure.html">Configuring Jakarta Faces Applications</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/faces-ws/faces-ws.html">Using WebSockets with Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/webi18n/webi18n.html">Internationalizing and Localizing Web Applications</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../web/websocket/websocket.html">Jakarta WebSocket</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Persistence</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-intro/persistence-intro.html">Introduction to Jakarta Persistence</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-basicexamples/persistence-basicexamples.html">Running the Persistence Examples</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-querylanguage/persistence-querylanguage.html">The Jakarta Persistence Query Language</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-criteria/persistence-criteria.html">Using the Criteria API to Create Queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-string-queries/persistence-string-queries.html">Creating and Using String-Based Criteria Queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-locking/persistence-locking.html">Controlling Concurrent Access to Entity Data with Locking</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-entitygraphs/persistence-entitygraphs.html">Creating Fetch Plans with Entity Graphs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-cache/persistence-cache.html">Using a Second-Level Cache with Jakarta Persistence Applications</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Enterprise Beans Lite</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-intro/ejb-intro.html">Enterprise Beans</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-gettingstarted/ejb-gettingstarted.html">Getting Started with Enterprise Beans</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-basicexamples/ejb-basicexamples.html">Running the Enterprise Bean Examples</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-async/ejb-async.html">Using Asynchronous Method Invocation in Session Beans</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Platform</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../mail-api/mail-api.html">Jakarta Mail</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Messaging</span>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="jms-concepts.html">Jakarta Messaging Concepts</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../jms-examples/jms-examples.html">Jakarta Messaging Examples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../supporttechs/batch-processing/batch-processing.html">Jakarta Batch</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Advanced</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Web Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../security/security-authentication/security-authentication.html">Jakarta Authentication</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../security/security-authorization/security-authorization.html">Jakarta Authorization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../supporttechs/transactions/transactions.html">Jakarta Transactions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../supporttechs/concurrency-utilities/concurrency-utilities.html">Jakarta Concurrency</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Platform</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../supporttechs/connectors/connectors.html">Jakarta Connectors</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Optional Components</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/faces-el/faces-el.html">Jakarta Expression Language</a>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Jakarta XML Binding</span>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Archived</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Web Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/jakarta-pages/jakarta-pages.html">Jakarta Pages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../web/jakarta-tags/jakarta-tags.html">Jakarta Tags</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Platform</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../websvcs/xml-websvcs/xml-websvcs.html">XML Web Services</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-full/ejb-full.html">Jakarta Enterprise Beans Full</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Jakarta EE Tutorial</span>
    <span class="version">10</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../../index.html">Jakarta EE Tutorial</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../index.html">10</a>
        </li>
        <li class="version">
          <a href="../../../9.1/index.html">9.1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../index.html">Jakarta EE Tutorial</a></li>
    <li>Jakarta EE Platform</li>
    <li>Jakarta Messaging</li>
    <li><a href="jms-concepts.html">Jakarta Messaging Concepts</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">10</button>
  <div class="version-menu">
    <a class="version is-current" href="jms-concepts.html">10</a>
    <a class="version" href="../../../9.1/messaging/jms-concepts/jms-concepts.html">9.1</a>
  </div>
</div>
  <div class="edit-this-page"><a href="https://github.com/jhammen/jakartaee-tutorial/edit/main/src/main/antora/modules/messaging/pages/jms-concepts/jms-concepts.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Jakarta Messaging Concepts</h1>
<div id="preamble">
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We are working on a fresh, updated Jakarta EE Tutorial. This section hasn&#8217;t yet been updated.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This chapter provides an introduction to Jakarta Messaging, a Java API that allows applications to create, send, receive, and read messages using reliable, asynchronous, loosely coupled communication.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jakarta_messaging_overview"><a class="anchor" href="#_jakarta_messaging_overview"></a>Jakarta Messaging Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This overview defines the concept of messaging, describes Jakarta Messaging and where it can be used, and explains how Jakarta Messaging works within the Jakarta EE platform.</p>
</div>
<div class="sect2">
<h3 id="_what_is_messaging"><a class="anchor" href="#_what_is_messaging"></a>What Is Messaging?</h3>
<div class="paragraph">
<p>Messaging is a method of communication between software components or applications.
A messaging system is a peer-to-peer facility: A messaging client can send messages to, and receive messages from, any other client.
Each client connects to a messaging agent that provides facilities for creating, sending, receiving, and reading messages.</p>
</div>
<div class="paragraph">
<p>Messaging enables distributed communication that is loosely coupled.
A component sends a message to a destination, and the recipient can retrieve the message from the destination.
What makes the communication loosely coupled is that the destination is all that the sender and receiver have in common.
The sender and the receiver do not have to be available at the same time in order to communicate.
In fact, the sender does not need to know anything about the receiver; nor does the receiver need to know anything about the sender.
The sender and the receiver need to know only which message format and which destination to use.
In this respect, messaging differs from tightly coupled technologies, such as Remote Method Invocation (RMI), which require an application to know a remote application&#8217;s methods.</p>
</div>
<div class="paragraph">
<p>Messaging also differs from electronic mail (email), which is a method of communication between people or between software applications and people.
Messaging is used for communication between software applications or software components.</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_is_jakarta_messaging"><a class="anchor" href="#_what_is_jakarta_messaging"></a>What Is Jakarta Messaging?</h3>
<div class="paragraph">
<p>Jakarta Messaging is a Java API that allows applications to create, send, receive, and read messages.
Jakarta Messaging defines a common set of interfaces and associated semantics that allow programs written in the Java programming language to communicate with other messaging implementations.</p>
</div>
<div class="paragraph">
<p>Jakarta Messaging minimizes the set of concepts a programmer must learn in order to use messaging products but provides enough features to support sophisticated messaging applications.
It also strives to maximize the portability of Messaging applications across providers.</p>
</div>
<div class="paragraph">
<p>Jakarta Messaging enables communication that is not only loosely coupled but also</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Asynchronous: A receiving client does not have to receive messages at the same time the sending client sends them.
The sending client can send them and go on to other tasks; the receiving client can receive them much later.</p>
</li>
<li>
<p>Reliable: A messaging provider that implements Jakarta Messaging can ensure that a message is delivered once and only once.
Lower levels of reliability are available for applications that can afford to miss messages or to receive duplicate messages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The current version of the Jakarta Messaging specification is Version 3.0.</p>
</div>
</div>
<div class="sect2">
<h3 id="_when_can_you_use_jakarta_messaging"><a class="anchor" href="#_when_can_you_use_jakarta_messaging"></a>When Can You Use Jakarta Messaging?</h3>
<div class="paragraph">
<p>An enterprise application provider is likely to choose a messaging API over a tightly coupled API, such as a remote procedure call (RPC), under the following circumstances.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The provider wants the components not to depend on information about other components' interfaces, so components can be easily replaced.</p>
</li>
<li>
<p>The provider wants the application to run whether or not all components are up and running simultaneously.</p>
</li>
<li>
<p>The application business model allows a component to send information to another and to continue to operate without receiving an immediate response.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, components of an enterprise application for an automobile manufacturer can use Jakarta Messaging in situations like the following.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The inventory component can send a message to the factory component when the inventory level for a product goes below a certain level so the factory can make more cars.</p>
</li>
<li>
<p>The factory component can send a message to the parts components so the factory can assemble the parts it needs.</p>
</li>
<li>
<p>The parts components in turn can send messages to their own inventory and order components to update their inventories and to order new parts from suppliers.</p>
</li>
<li>
<p>Both the factory and the parts components can send messages to the accounting component to update budget numbers.</p>
</li>
<li>
<p>The business can publish updated catalog items to its sales force.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using messaging for these tasks allows the various components to interact with one another efficiently, without tying up network or other resources.
<a href="#_messaging_in_an_enterpise_application">Figure 1, &#8220;Messaging in an Enterprise Application&#8221;</a> illustrates how this simple example might work.</p>
</div>
<div id="_messaging_in_an_enterpise_application" class="imageblock">
<div class="content">
<img src="../../common/_images/jakartaeett_dt_026.svg" alt="Diagram showing messaging between various departments in an enterprise">
</div>
<div class="title">Figure 1. Messaging in an Enterprise Application</div>
</div>
<div class="paragraph">
<p>Manufacturing is only one example of how an enterprise can use the Jakarta Messaging API.
Retail applications, financial services applications, health services applications, and many others can make use of messaging.</p>
</div>
</div>
<div class="sect2">
<h3 id="_how_does_jakarta_messaging_work_with_the_jakarta_ee_platform"><a class="anchor" href="#_how_does_jakarta_messaging_work_with_the_jakarta_ee_platform"></a>How Does Jakarta Messaging Work with the Jakarta EE Platform?</h3>
<div class="paragraph">
<p>When JMS was first introduced, its most important purpose was to allow Java applications to access existing messaging-oriented middleware (MOM) systems.
Since that time, many vendors have adopted and implemented JMS, so a Jakarta Messaging product can now provide a complete messaging capability for an enterprise.</p>
</div>
<div class="paragraph">
<p>Jakarta Messaging is an integral part of the Jakarta EE platform, and application developers can use messaging with Jakarta EE components. Jakarta Messaging 2.0 is part of the Jakarta EE 8 release.</p>
</div>
<div class="paragraph">
<p>Jakarta Messaging in the Jakarta EE platform has the following features.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Application clients, Jakarta Enterprise Beans components, and web components can send or synchronously receive a Jakarta Messaging message.
Application clients can in addition set a message listener that allows Jakarta Messaging messages to be delivered to it asynchronously by being notified when a message is available.</p>
</li>
<li>
<p>Message-driven beans, which are a kind of enterprise bean, enable the asynchronous consumption of messages in the enterprise bean container.
An application server typically pools message-driven beans to implement concurrent processing of messages.</p>
</li>
<li>
<p>Message send and receive operations can participate in Jakarta transactions, which allow Jakarta Messaging operations and database accesses to take place within a single transaction.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Jakarta Messaging enhances the other parts of the Jakarta EE platform by simplifying enterprise development, allowing loosely coupled, reliable, asynchronous interactions among Jakarta EE components and legacy systems capable of messaging.
A developer can easily add new behavior to a Jakarta EE application that has existing business events by adding a new message-driven bean to operate on specific business events.
The Jakarta EE platform, moreover, enhances Jakarta Messaging by providing support for Jakarta Transactions and allowing for the concurrent consumption of messages.
For more information, see the Jakarta Enterprise Beans specification, v4.0.</p>
</div>
<div class="paragraph">
<p>The Jakarta Messaging provider can be integrated with the application server using the Jakarta Connectors.
You access the Messaging provider through a resource adapter.
This capability allows vendors to create Messaging providers that can be plugged in to multiple application servers, and it allows application servers to support multiple Messaging providers.
For more information, see the Jakarta Connectors specification, v2.0.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic_jakarta_messaging_concepts"><a class="anchor" href="#_basic_jakarta_messaging_concepts"></a>Basic Jakarta Messaging Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section introduces the most basic Jakarta Messaging concepts, the ones you must know to get started writing simple application clients that use the Jakarta Messaging.</p>
</div>
<div class="paragraph">
<p>The next section introduces the Jakarta Messaging programming model.
Later sections cover more advanced concepts, including the ones you need in order to write applications that use message-driven beans.</p>
</div>
<div class="sect2">
<h3 id="_jakarta_messaging_architecture"><a class="anchor" href="#_jakarta_messaging_architecture"></a>Jakarta Messaging Architecture</h3>
<div class="paragraph">
<p>A Jakarta Messaging application is composed of the following parts.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A Jakarta Messaging provider is a messaging system that implements the Messaging interfaces and provides administrative and control features.
A Jakarta EE implementation that supports the Jakarta EE Platform also includes a Messaging provider.</p>
</li>
<li>
<p>Jakarta Messaging clients are the programs or components, written in the Java programming language, that produce and consume messages.
Any Jakarta EE application component can act as a Messaging client.</p>
<div class="paragraph">
<p>Java SE applications can also act as Jakarta Messaging clients; the Message Queue Developer&#8217;s Guide for Java Clients in the GlassFish Server documentation (<a href="https://glassfish.org/documentation" class="bare" target="_blank" rel="noopener">https://glassfish.org/documentation</a>) explains how to make this work.</p>
</div>
</li>
<li>
<p>Messages are the objects that communicate information between Jakarta Messaging clients.</p>
</li>
<li>
<p>Administered objects are Jakarta Messaging objects configured for the use of clients.
The two kinds of Jakarta Messaging administered objects are destinations and connection factories, described in <a href="#_jakarta_messaging_administered_objects">Jakarta Messaging Administered Objects</a>.
An administrator can create objects that are available to all applications that use a particular installation of GlassFish Server; alternatively, a developer can use annotations to create objects that are specific to a particular application.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#_jakarta_messaging_architecture_2">Figure 2, &#8220;Jakarta Messaging Architecture&#8221;</a> illustrates the way these parts interact.
Administrative tools or annotations allow you to bind destinations and connection factories into a JNDI namespace.
A Messaging client can then use resource injection to access the administered objects in the namespace and then establish a logical connection to the same objects through the Jakarta Messaging provider.</p>
</div>
<div id="_jakarta_messaging_architecture_2" class="imageblock">
<div class="content">
<img src="../../common/_images/jakartaeett_dt_027.svg" alt="Diagram of Jakarta Messaging architecture, showing administrative tool, Jakarta Messaging client, JNDI namespace, and JMS provider">
</div>
<div class="title">Figure 2. Jakarta Messaging Architecture</div>
</div>
</div>
<div class="sect2">
<h3 id="_messaging_styles"><a class="anchor" href="#_messaging_styles"></a>Messaging Styles</h3>
<div class="paragraph">
<p>Before the Jakarta Messaging existed, most messaging products supported either the point-to-point or the publish/subscribe style of messaging.
The Jakarta Messaging specification defines compliance for each style.
A Messaging provider must implement both styles, and the Jakarta Messaging provides interfaces that are specific to each.
The following subsections describe these messaging styles.</p>
</div>
<div class="paragraph">
<p>Jakarta Messaging, however, makes it unnecessary to use only one of the two styles.
It allows you to use the same code to send and receive messages using either the PTP or the pub/sub style.
The destinations you use remain specific to one style, and the behavior of the application will depend in part on whether you are using a queue or a topic.
However, the code itself can be common to both styles, making your applications flexible and reusable.
This tutorial describes and illustrates this coding approach, using the greatly simplified API provided by Jakarta Messaging 2.0.</p>
</div>
<div class="sect3">
<h4 id="_point_to_point_messaging_style"><a class="anchor" href="#_point_to_point_messaging_style"></a>Point-to-Point Messaging Style</h4>
<div class="paragraph">
<p>A point-to-point (PTP) product or application is built on the concept of message queues, senders, and receivers.
Each message is addressed to a specific queue, and receiving clients extract messages from the queues established to hold their messages.
Queues retain all messages sent to them until the messages are consumed or expire.</p>
</div>
<div class="paragraph">
<p>PTP messaging, illustrated in <a href="#_point_to_point_messaging">Figure 3, &#8220;Point-to-Point Messaging&#8221;</a>, has the following characteristics.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each message has only one consumer.</p>
</li>
<li>
<p>The receiver can fetch the message whether or not it was running when the client sent the message.</p>
</li>
</ul>
</div>
<div id="_point_to_point_messaging" class="imageblock">
<div class="content">
<img src="../../common/_images/jakartaeett_dt_028.svg" alt="Diagram of point-to-point messaging, showing Client 1 sending a message to a queue, and Client 2 consuming and acknowledging the message">
</div>
<div class="title">Figure 3. Point-to-Point Messaging</div>
</div>
<div class="paragraph">
<p>Use PTP messaging when every message you send must be processed successfully by one consumer.</p>
</div>
</div>
<div class="sect3">
<h4 id="_publishsubscribe_messaging_style"><a class="anchor" href="#_publishsubscribe_messaging_style"></a>Publish/Subscribe Messaging Style</h4>
<div class="paragraph">
<p>In a publish/subscribe (pub/sub) product or application, clients address messages to a topic, which functions somewhat like a bulletin board.
Publishers and subscribers can dynamically publish or subscribe to the topic.
The system takes care of distributing the messages arriving from a topic&#8217;s multiple publishers to its multiple subscribers.
Topics retain messages only as long as it takes to distribute them to subscribers.</p>
</div>
<div class="paragraph">
<p>With pub/sub messaging, it is important to distinguish between the consumer that subscribes to a topic (the subscriber) and the subscription that is created.
The consumer is a Jakarta Messaging object within an application, while the subscription is an entity within the Jakarta Messaging provider.
Normally, a topic can have many consumers, but a subscription has only one subscriber.
It is possible, however, to create shared subscriptions; see <a href="#_creating_shared_subscriptions">Creating Shared Subscriptions</a> for details.
See <a href="#_consuming_messages_from_topics">Consuming Messages from Topics</a> for details on the semantics of pub/sub messaging.</p>
</div>
<div class="paragraph">
<p>Pub/sub messaging has the following characteristics.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each message can have multiple consumers.</p>
</li>
<li>
<p>A client that subscribes to a topic can consume only messages sent after the client has created a subscription, and the consumer must continue to be active in order for it to consume messages.</p>
<div class="paragraph">
<p>The Jakarta Messaging relaxes this requirement to some extent by allowing applications to create durable subscriptions, which receive messages sent while the consumers are not active.
Durable subscriptions provide the flexibility and reliability of queues but still allow clients to send messages to many recipients.
For more information about durable subscriptions, see <a href="#_creating_durable_subscriptions">Creating Durable Subscriptions</a>.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Use pub/sub messaging when each message can be processed by any number of consumers (or none). <a href="#_publish_subscribe_messaging">Figure 4, &#8220;Publish/Subscribe Messaging&#8221;</a> illustrates pub/sub messaging.</p>
</div>
<div id="_publish_subscribe_messaging" class="imageblock">
<div class="content">
<img src="../../common/_images/jakartaeett_dt_029.svg" alt="Diagram of pub/sub messaging, showing Client 1 sending a message to a topic, and the message being delivered to two consumers to the topic">
</div>
<div class="title">Figure 4. Publish/Subscribe Messaging</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_message_consumption"><a class="anchor" href="#_message_consumption"></a>Message Consumption</h3>
<div class="paragraph">
<p>Messaging products are inherently asynchronous: There is no fundamental timing dependency between the production and the consumption of a message.
However, the Jakarta Messaging specification uses this term in a more precise sense.
Messages can be consumed in either of two ways.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Synchronously: A consumer explicitly fetches the message from the destination by calling the <code>receive</code> method.
The <code>receive</code> method can block until a message arrives or can time out if a message does not arrive within a specified time limit.</p>
</li>
<li>
<p>Asynchronously: An application client or a Java SE client can register a message listener with a consumer.
A message listener is similar to an event listener.
Whenever a message arrives at the destination, the JMS provider delivers the message by calling the listener&#8217;s <code>onMessage</code> method, which acts on the contents of the message.
In a Jakarta EE application, a message-driven bean serves as a message listener (it too has an <code>onMessage</code> method), but a client does not need to register it with a consumer.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jakarta_messaging_programming_model"><a class="anchor" href="#_jakarta_messaging_programming_model"></a>Jakarta Messaging Programming Model</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The basic building blocks of a Jakarta Messaging application are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Administered objects: connection factories and destinations</p>
</li>
<li>
<p>Connections</p>
</li>
<li>
<p>Sessions</p>
</li>
<li>
<p><code>JMSContext</code> objects, which combine a connection and a session in one object</p>
</li>
<li>
<p>Message producers</p>
</li>
<li>
<p>Message consumers</p>
</li>
<li>
<p>Messages</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#_jakarta_messaging_programming_model_2">Figure 5, &#8220;Jakarta Messaging Programming Model&#8221;</a> shows how all these objects fit together in a Messaging client application.</p>
</div>
<div id="_jakarta_messaging_programming_model_2" class="imageblock">
<div class="content">
<img src="../../common/_images/jakartaeett_dt_030.svg" alt="Diagram of Jakarta Messaging programming model: connection factory, JMSContext, connection, session, message producer, message consumer, messages, and destinations">
</div>
<div class="title">Figure 5. Jakarta Messaging Programming Model</div>
</div>
<div class="paragraph">
<p>Jakarta Messaging also provides queue browsers, objects that allow an application to browse messages on a queue.</p>
</div>
<div class="paragraph">
<p>This section describes all these objects briefly and provides sample commands and code snippets that show how to create and use the objects.
The last subsection briefly describes Jakarta Messaging API exception handling.</p>
</div>
<div class="paragraph">
<p>Examples that show how to combine all these objects in applications appear in <a href="../jms-examples/jms-examples.html#_jakarta_messaging_examples" class="xref page">Jakarta Messaging Examples</a> beginning with <a href="../jms-examples/jms-examples.html#_writing_simple_jakarta_messaging_applications" class="xref page">Writing Simple Jakarta Messaging Applications</a>.
For more detail, see Jakarta Messaging documentation, part of the Jakarta EE API documentation.</p>
</div>
<div class="sect2">
<h3 id="_jakarta_messaging_administered_objects"><a class="anchor" href="#_jakarta_messaging_administered_objects"></a>Jakarta Messaging Administered Objects</h3>
<div class="paragraph">
<p>Two parts of a Jakarta Messaging application, destinations and connection factories, are commonly maintained administratively rather than programmatically.
The technology underlying these objects is likely to be very different from one implementation of Jakarta Messaging to another.
Therefore, the management of these objects belongs with other administrative tasks that vary from provider to provider.</p>
</div>
<div class="paragraph">
<p>Messaging clients access administered objects through interfaces that are portable, so a client application can run with little or no change on more than one implementation of Jakarta Messaging.
Ordinarily, an administrator configures administered objects in a JNDI namespace, and Messaging clients then access them by using resource injection.</p>
</div>
<div class="paragraph">
<p>With GlassFish Server, you can use the <code>asadmin create-jms-resource</code> command or the Administration Console to create Jakarta Messaging administered objects in the form of connector resources.
You can also specify the resources in a file named <code>glassfish-resources.xml</code> that you can bundle with an application.</p>
</div>
<div class="paragraph">
<p>NetBeans IDE provides a wizard that allows you to create Jakarta Messaging resources for GlassFish Server.
See <a href="../jms-examples/jms-examples.html#_creating_jakarta_messaging_administered_objects" class="xref page">Creating Jakarta Messaging Administered Objects</a> for details.</p>
</div>
<div class="paragraph">
<p>The Jakarta EE platform specification allows a developer to create administered objects using annotations or deployment descriptor elements.
Objects created in this way are specific to the application for which they are created.
See <a href="#_creating_resources_for_jakarta_ee_applications">Creating Resources for Jakarta EE Applications</a> for details.
Definitions in a deployment descriptor override those specified by annotations.</p>
</div>
<div class="sect3">
<h4 id="_jakarta_messaging_connection_factories"><a class="anchor" href="#_jakarta_messaging_connection_factories"></a>Jakarta Messaging Connection Factories</h4>
<div class="paragraph">
<p>A connection factory is the object a client uses to create a connection to a provider.
A connection factory encapsulates a set of connection configuration parameters that has been defined by an administrator.
Each connection factory is an instance of the <code>ConnectionFactory</code>, <code>QueueConnectionFactory</code>, or <code>TopicConnectionFactory</code> interface.
To learn how to create connection factories, see <a href="../jms-examples/jms-examples.html#_creating_jakarta_messaging_administered_objects" class="xref page">Creating Jakarta Messaging Administered Objects</a>.</p>
</div>
<div class="paragraph">
<p>At the beginning of a Messaging client program, you usually inject a connection factory resource into a <code>ConnectionFactory</code> object.
A Jakarta EE server must provide a Jakarta Messaging connection factory with the logical JNDI name <code>java:comp/DefaultJMSConnectionFactory</code>.
The actual JNDI name will be implementation-specific.</p>
</div>
<div class="paragraph">
<p>For example, the following code fragment looks up the default Jakarta Messaging connection factory and assigns it to a <code>ConnectionFactory</code> object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Resource(lookup = "java:comp/DefaultJMSConnectionFactory")
private static ConnectionFactory connectionFactory;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_jakarta_messaging_destinations"><a class="anchor" href="#_jakarta_messaging_destinations"></a>Jakarta Messaging Destinations</h4>
<div class="paragraph">
<p>A destination is the object a client uses to specify the target of messages it produces and the source of messages it consumes.
In the PTP messaging style, destinations are called queues.
In the pub/sub messaging style, destinations are called topics.
A Jakarta Messaging application can use multiple queues or topics (or both).
To learn how to create destination resources, see <a href="../jms-examples/jms-examples.html#_creating_jakarta_messaging_administered_objects" class="xref page">Creating Jakarta Messaging Administered Objects</a>.</p>
</div>
<div class="paragraph">
<p>To create a destination using GlassFish Server, you create a Jakarta Messaging destination resource that specifies a JNDI name for the destination.</p>
</div>
<div class="paragraph">
<p>In the GlassFish Server implementation of Jakarta Messaging, each destination resource refers to a physical destination.
You can create a physical destination explicitly, but if you do not, the Application Server creates it when it is needed and deletes it when you delete the destination resource.</p>
</div>
<div class="paragraph">
<p>In addition to injecting a connection factory resource into a client program, you usually inject a destination resource.
Unlike connection factories, destinations are specific to either the PTP or pub/sub messaging style.
To create an application that allows you to use the same code for both topics and queues, you assign the destination to a <code>Destination</code> object.</p>
</div>
<div class="paragraph">
<p>The following code specifies two resources, a queue and a topic.
The resource names are mapped to destination resources created in the JNDI namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Resource(lookup = "jms/MyQueue")
private static Queue queue;

@Resource(lookup = "jms/MyTopic")
private static Topic topic;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In a Jakarta EE application, Jakarta Messaging administered objects are normally placed in the <code>jms</code> naming subcontext.</p>
</div>
<div class="paragraph">
<p>With the common interfaces, you can mix or match connection factories and destinations.
That is, in addition to using the <code>ConnectionFactory</code> interface, you can inject a <code>QueueConnectionFactory</code> resource and use it with a <code>Topic</code>, and you can inject a <code>TopicConnectionFactory</code> resource and use it with a <code>Queue</code>.
The behavior of the application will depend on the kind of destination you use and not on the kind of connection factory you use.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_connections"><a class="anchor" href="#_connections"></a>Connections</h3>
<div class="paragraph">
<p>A connection encapsulates a virtual connection with a Messaging provider.
For example, a connection could represent an open TCP/IP socket between a client and a provider service daemon.
You use a connection to create one or more sessions.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the Jakarta EE platform, the ability to create multiple sessions from a single connection is limited to application clients.
In web and enterprise bean components, a connection can create no more than one session.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You normally create a connection by creating a <code>JMSContext</code> object.
See <a href="#_jmscontext_objects">JMSContext Objects</a> for details.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sessions"><a class="anchor" href="#_sessions"></a>Sessions</h3>
<div class="paragraph">
<p>A session is a single-threaded context for producing and consuming messages.</p>
</div>
<div class="paragraph">
<p>You normally create a session (as well as a connection) by creating a <code>JMSContext</code> object.
See <a href="#_jmscontext_objects">JMSContext Objects</a> for details.
You use sessions to create message producers, message consumers, messages, queue browsers, and temporary destinations.</p>
</div>
<div class="paragraph">
<p>Sessions serialize the execution of message listeners; for details, see <a href="#_jakarta_messaging_message_listeners">Jakarta Messaging Message Listeners</a>.</p>
</div>
<div class="paragraph">
<p>A session provides a transactional context with which to group a set of sends and receives into an atomic unit of work.
For details, see <a href="#_using_jakarta_messaging_local_transactions">Using Jakarta Messaging Local Transactions</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jmscontext_objects"><a class="anchor" href="#_jmscontext_objects"></a>JMSContext Objects</h3>
<div class="paragraph">
<p>A <code>JMSContext</code> object combines a connection and a session in a single object.
That is, it provides both an active connection to a Messaging provider and a single-threaded context for sending and receiving messages.</p>
</div>
<div class="paragraph">
<p>You use the <code>JMSContext</code> to create the following objects:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Message producers</p>
</li>
<li>
<p>Message consumers</p>
</li>
<li>
<p>Messages</p>
</li>
<li>
<p>Queue browsers</p>
</li>
<li>
<p>Temporary queues and topics (see <a href="#_creating_temporary_destinations">Creating Temporary Destinations</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can create a <code>JMSContext</code> in a <code>try</code>-with-resources block.</p>
</div>
<div class="paragraph">
<p>To create a <code>JMSContext</code>, call the <code>createContext</code> method on the connection factory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">JMSContext context = connectionFactory.createContext();</code></pre>
</div>
</div>
<div class="paragraph">
<p>When called with no arguments from an application client or a Java SE client, or from the Jakarta EE web or Enterprise Beans container when there is no active Jakarta Transactions transaction in progress, the <code>createContext</code> method creates a non-transacted session with an acknowledgment mode of <code>JMSContext.AUTO_ACKNOWLEDGE</code>.
When called with no arguments from the web or Enterprise Beans container when there is an active JTA transaction in progress, the <code>createContext</code> method creates a transacted session.
For information about the way Jakarta Messaging transactions work in Jakarta EE applications, see <a href="#_using_jakarta_messaging_in_jakarta_ee_applications">Using Jakarta Messaging in Jakarta EE Applications</a>.</p>
</div>
<div class="paragraph">
<p>From an application client or a Java SE client, you can also call the <code>createContext</code> method with the argument <code>JMSContext.SESSION_TRANSACTED</code> to create a transacted session:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">JMSContext context =
        connectionFactory.createContext(JMSContext.SESSION_TRANSACTED);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The session uses local transactions; see <a href="#_using_jakarta_messaging_local_transactions">Using Jakarta Messaging Local Transactions</a> for details.</p>
</div>
<div class="paragraph">
<p>Alternatively, you can specify a non-default acknowledgment mode; see <a href="#_controlling_message_acknowledgment">Controlling Message Acknowledgment</a> for more information.</p>
</div>
<div class="paragraph">
<p>When you use a <code>JMSContext</code>, message delivery normally begins as soon as you create a consumer.
See <a href="#_jakarta_messaging_message_consumers">Jakarta Messaging Message Consumers</a> for more information.</p>
</div>
<div class="paragraph">
<p>If you create a <code>JMSContext</code> in a <code>try</code>-with-resources block, you do not need to close it explicitly.
It will be closed when the <code>try</code> block comes to an end.
Make sure that your application completes all its Jakarta Messaging activity within the <code>try</code>-with-resources block.
If you do not use a <code>try</code>-with-resources block, you must call the <code>close</code> method on the <code>JMSContext</code> to close the connection when the application has finished its work.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jakarta_messaging_message_producers"><a class="anchor" href="#_jakarta_messaging_message_producers"></a>Jakarta Messaging Message Producers</h3>
<div class="paragraph">
<p>A message producer is an object that is created by a <code>JMSContext</code> or a session and used for sending messages to a destination.
A message producer created by a <code>JMSContext</code> implements the <code>JMSProducer</code> interface.
You could create it this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try (JMSContext context = connectionFactory.createContext();) {
    JMSProducer producer = context.createProducer();
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, a <code>JMSProducer</code> is a lightweight object that does not consume significant resources.
For this reason, you do not need to save the <code>JMSProducer</code> in a variable; you can create a new one each time you send a message.
You send messages to a specific destination by using the <code>send</code> method.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">context.createProducer().send(dest, message);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can create the message in a variable before sending it, as shown here, or you can create it within the <code>send</code> call.
See <a href="#_jakarta_messaging_messages">Jakarta Messaging Messages</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jakarta_messaging_message_consumers"><a class="anchor" href="#_jakarta_messaging_message_consumers"></a>Jakarta Messaging Message Consumers</h3>
<div class="paragraph">
<p>A message consumer is an object that is created by a <code>JMSContext</code> or a session and used for receiving messages sent to a destination.
A message producer created by a <code>JMSContext</code> implements the <code>JMSConsumer</code> interface.
The simplest way to create a message consumer is to use the <code>JMSContext.createConsumer</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try (JMSContext context = connectionFactory.createContext();) {
    JMSConsumer consumer = context.createConsumer(dest);
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A message consumer allows a Messaging client to register interest in a destination with a Messaging provider.
The Jakarta Messaging provider manages the delivery of messages from a destination to the registered consumers of the destination.</p>
</div>
<div class="paragraph">
<p>When you use a <code>JMSContext</code> to create a message consumer, message delivery begins as soon as you have created the consumer.
You can disable this behavior by calling <code>setAutoStart(false)</code> when you create the <code>JMSContext</code> and then calling the <code>start</code> method explicitly to start message delivery.
If you want to stop message delivery temporarily without closing the connection, you can call the <code>stop</code> method; to restart message delivery, call <code>start</code>.</p>
</div>
<div class="paragraph">
<p>You use the <code>receive</code> method to consume a message synchronously.
You can use this method at any time after you create the consumer.</p>
</div>
<div class="paragraph">
<p>If you specify no arguments or an argument of <code>0</code>, the method blocks indefinitely until a message arrives:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message m = consumer.receive();
Message m = consumer.receive(0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a simple client, this may not matter.
But if it is possible that a message might not be available, use a synchronous receive with a timeout: Call the <code>receive</code> method with a timeout argument greater than <code>0</code>.
One second is a recommended timeout value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message m = consumer.receive(1000); // time out after a second</code></pre>
</div>
</div>
<div class="paragraph">
<p>To enable asynchronous message delivery from an application client or a Java SE client, you use a message listener, as described in the next section.</p>
</div>
<div class="paragraph">
<p>You can use the <code>JMSContext.createDurableConsumer</code> method to create a durable topic subscription.
This method is valid only if you are using a topic.
For details, see <a href="#_creating_durable_subscriptions">Creating Durable Subscriptions</a>.
For topics, you can also create shared consumers; see <a href="#_creating_shared_subscriptions">Creating Shared Subscriptions</a>.</p>
</div>
<div class="sect3">
<h4 id="_jakarta_messaging_message_listeners"><a class="anchor" href="#_jakarta_messaging_message_listeners"></a>Jakarta Messaging Message Listeners</h4>
<div class="paragraph">
<p>A message listener is an object that acts as an asynchronous event handler for messages.
This object implements the <code>MessageListener</code> interface, which contains one method, <code>onMessage</code>.
In the <code>onMessage</code> method, you define the actions to be taken when a message arrives.</p>
</div>
<div class="paragraph">
<p>From an application client or a Java SE client, you register the message listener with a specific message consumer by using the <code>setMessageListener</code> method.
For example, if you define a class named <code>Listener</code> that implements the <code>MessageListener</code> interface, you can register the message listener as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Listener myListener = new Listener();
consumer.setMessageListener(myListener);</code></pre>
</div>
</div>
<div class="paragraph">
<p>When message delivery begins, the Messaging provider automatically calls the message listener&#8217;s <code>onMessage</code> method whenever a message is delivered.
The <code>onMessage</code> method takes one argument of type <code>Message</code>, which your implementation of the method can cast to another message subtype as needed (see <a href="#_message_bodies">Message Bodies</a>).</p>
</div>
<div class="paragraph">
<p>In the Jakarta EE web or Enterprise Beans container, you use message-driven beans for asynchronous message delivery.
A message-driven bean also implements the <code>MessageListener</code> interface and contains an <code>onMessage</code> method.
For details, see <a href="#_using_message_driven_beans_to_receive_messages_asynchronously">Using Message-Driven Beans to Receive Messages Asynchronously</a>.</p>
</div>
<div class="paragraph">
<p>Your <code>onMessage</code> method should handle all exceptions.
Throwing a <code>RuntimeException</code> is considered a programming error.</p>
</div>
<div class="paragraph">
<p>For a simple example of the use of a message listener, see <a href="../jms-examples/jms-examples.html#_using_a_message_listener_for_asynchronous_message_delivery" class="xref page">Using a Message Listener for Asynchronous Message Delivery</a>.
<a href="../jms-examples/jms-examples.html#_jakarta_messaging_examples" class="xref page">Jakarta Messaging Examples</a> contains several more examples of message listeners and message-driven beans.</p>
</div>
</div>
<div class="sect3">
<h4 id="_jakarta_messaging_message_selectors"><a class="anchor" href="#_jakarta_messaging_message_selectors"></a>Jakarta Messaging Message Selectors</h4>
<div class="paragraph">
<p>If your messaging application needs to filter the messages it receives, you can use a Jakarta Messaging message selector, which allows a message consumer for a destination to specify the messages that interest it.
Message selectors assign the work of filtering messages to the Messaging provider rather than to the application.
For an example of an application that uses a message selector, see <a href="../jms-examples/jms-examples.html#_sending_messages_from_a_session_bean_to_an_mdb" class="xref page">Sending Messages from a Session Bean to an MDB</a>.</p>
</div>
<div class="paragraph">
<p>A message selector is a <code>String</code> that contains an expression.
The syntax of the expression is based on a subset of the SQL92 conditional expression syntax.
The message selector in the example selects any message that has a <code>NewsType</code> property that is set to the value <code>'Sports'</code> or <code>'Opinion'</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">NewsType = 'Sports' OR NewsType = 'Opinion'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>createConsumer</code> and <code>createDurableConsumer</code> methods, as well as the methods for creating shared consumers, allow you to specify a message selector as an argument when you create a message consumer.</p>
</div>
<div class="paragraph">
<p>The message consumer then receives only messages whose headers and properties match the selector.
(See <a href="#_message_headers">Message Headers</a> and <a href="#_message_properties">Message Properties</a>.)
A message selector cannot select messages on the basis of the content of the message body.</p>
</div>
</div>
<div class="sect3">
<h4 id="_consuming_messages_from_topics"><a class="anchor" href="#_consuming_messages_from_topics"></a>Consuming Messages from Topics</h4>
<div class="paragraph">
<p>The semantics of consuming messages from topics are more complex than the semantics of consuming messages from queues.</p>
</div>
<div class="paragraph">
<p>An application consumes messages from a topic by creating a subscription on that topic and creating a consumer on that subscription.
Subscriptions may be durable or nondurable, and they may be shared or unshared.</p>
</div>
<div class="paragraph">
<p>A subscription may be thought of as an entity within the Messaging provider itself, whereas a consumer is a Jakarta Messaging object within the application.</p>
</div>
<div class="paragraph">
<p>A subscription will receive a copy of every message that is sent to the topic after the subscription is created, unless a message selector is specified.
If a message selector is specified, only those messages whose properties match the message selector will be added to the subscription.</p>
</div>
<div class="paragraph">
<p>Unshared subscriptions are restricted to a single consumer.
In this case, all the messages in the subscription are delivered to that consumer.
Shared subscriptions allow multiple consumers.
In this case, each message in the subscription is delivered to only one consumer.
Jakarta Messaging does not define how messages are distributed between multiple consumers on the same subscription.</p>
</div>
<div class="paragraph">
<p>Subscriptions may be durable or nondurable.</p>
</div>
<div class="paragraph">
<p>A nondurable subscription exists only as long as there is an active consumer on the subscription.
This means that any messages sent to the topic will be added to the subscription only while a consumer exists and is not closed.</p>
</div>
<div class="paragraph">
<p>A nondurable subscription may be either unshared or shared.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An unshared nondurable subscription does not have a name and may have only a single consumer object associated with it.
It is created automatically when the consumer object is created.
It is not persisted and is deleted automatically when the consumer object is closed.</p>
<div class="paragraph">
<p>The <code>JMSContext.createConsumer</code> method creates a consumer on an unshared nondurable subscription if a topic is specified as the destination.</p>
</div>
</li>
<li>
<p>A shared nondurable subscription is identified by name and an optional client identifier, and may have several consumer objects consuming messages from it.
It is created automatically when the first consumer object is created.
It is not persisted and is deleted automatically when the last consumer object is closed.
See <a href="#_creating_shared_subscriptions">Creating Shared Subscriptions</a> for more information.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>At the cost of higher overhead, a subscription may be durable.
A durable subscription is persisted and continues to accumulate messages until explicitly deleted, even if there are no consumer objects consuming messages from it.
See <a href="#_creating_durable_subscriptions">Creating Durable Subscriptions</a> for details.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_durable_subscriptions"><a class="anchor" href="#_creating_durable_subscriptions"></a>Creating Durable Subscriptions</h4>
<div class="paragraph">
<p>To ensure that a pub/sub application receives all sent messages, use durable subscriptions for the consumers on the topic.</p>
</div>
<div class="paragraph">
<p>Like a nondurable subscription, a durable subscription may be either unshared or shared.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An unshared durable subscription is identified by name and client identifier (which must be set) and may have only a single consumer object associated with it.</p>
</li>
<li>
<p>A shared durable subscription is identified by name and an optional client identifier, and may have several consumer objects consuming messages from it.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A durable subscription that exists but that does not currently have a non-closed consumer object associated with it is described as being inactive.</p>
</div>
<div class="paragraph">
<p>You can use the <code>JMSContext.createDurableConsumer</code> method to create a consumer on an unshared durable subscription.
An unshared durable subscription can have only one active consumer at a time.</p>
</div>
<div class="paragraph">
<p>A consumer identifies the durable subscription from which it consumes messages by specifying a unique identity that is retained by the Messaging provider.
Subsequent consumer objects that have the same identity resume the subscription in the state in which it was left by the preceding consumer.
If a durable subscription has no active consumer, the Messaging provider retains the subscription&#8217;s messages until they are received by the subscription or until they expire.</p>
</div>
<div class="paragraph">
<p>You establish the unique identity of an unshared durable subscription by setting the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A client ID for the connection</p>
</li>
<li>
<p>A topic and a subscription name for the subscription</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can set the client ID administratively for a client-specific connection factory using either the command line or the Administration Console.
(In an application client or a Java SE client, you can instead call <code>JMSContext.setClientID</code>.)</p>
</div>
<div class="paragraph">
<p>After using this connection factory to create the <code>JMSContext</code>, you call the <code>createDurableConsumer</code> method with two arguments: the topic and a string that specifies the name of the subscription:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String subName = "MySub";
JMSConsumer consumer = context.createDurableConsumer(myTopic, subName);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The subscription becomes active after you create the consumer.
Later, you might close the consumer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">consumer.close();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Messaging provider stores the messages sent to the topic, as it would store messages sent to a queue.
If the program or another application calls <code>createDurableConsumer</code> using the same connection factory and its client ID, the same topic, and the same subscription name, then the subscription is reactivated and the Messaging provider delivers the messages that were sent while the subscription was inactive.</p>
</div>
<div class="paragraph">
<p>To delete a durable subscription, first close the consumer, then call the <code>unsubscribe</code> method with the subscription name as the argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">consumer.close();
context.unsubscribe(subName);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>unsubscribe</code> method deletes the state the provider maintains for the subscription.</p>
</div>
<div class="paragraph">
<p><a href="#_consumers_on_a_durable_subscription">Figure 7, &#8220;Consumers on a Durable Subscription&#8221;</a> show the difference between a nondurable and a durable subscription.
With an ordinary, nondurable subscription, the consumer and the subscription begin and end at the same point and are, in effect, identical.
When the consumer is closed, the subscription also ends.
Here, <code>create</code> stands for a call to <code>JMSContext.createConsumer</code> with a <code>Topic</code> argument, and <code>close</code> stands for a call to <code>JMSConsumer.close</code>.
Any messages sent to the topic between the time of the first <code>close</code> and the time of the second <code>create</code> are not added to either subscription.
In <a href="#_nondurable_subscriptions_and_consumers">Figure 6, &#8220;Nondurable Subscriptions and Consumers&#8221;</a>, the consumers receive messages M1, M2, M5, and M6, but they do not receive messages M3 and M4.</p>
</div>
<div id="_nondurable_subscriptions_and_consumers" class="imageblock">
<div class="content">
<img src="../../common/_images/jakartaeett_dt_031.svg" alt="Diagram showing messages being lost when nondurable subscriptions are used">
</div>
<div class="title">Figure 6. Nondurable Subscriptions and Consumers</div>
</div>
<div class="paragraph">
<p>With a durable subscription, the consumer can be closed and re-created, but the subscription continues to exist and to hold messages until the application calls the <code>unsubscribe</code> method.
In <a href="#_consumers_on_a_durable_subscription">Figure 7, &#8220;Consumers on a Durable Subscription&#8221;</a>, <code>create</code> stands for a call to <code>JMSContext.createDurableConsumer</code>, <code>close</code> stands for a call to <code>JMSConsumer.close</code>, and <code>unsubscribe</code> stands for a call to <code>JMSContext.unsubscribe</code>.
Messages sent after the first consumer is closed are received when the second consumer is created (on the same durable subscription), so even though messages M2, M4, and M5 arrive while there is no consumer, they are not lost.</p>
</div>
<div id="_consumers_on_a_durable_subscription" class="imageblock">
<div class="content">
<img src="../../common/_images/jakartaeett_dt_032.svg" alt="Diagram showing messages being preserved when durable subscriptions are used">
</div>
<div class="title">Figure 7. Consumers on a Durable Subscription</div>
</div>
<div class="paragraph">
<p>A shared durable subscription allows you to use multiple consumers to receive messages from a durable subscription.
If you use a shared durable subscription, the connection factory you use does not need to have a client identifier.
To create a shared durable subscription, call the <code>JMSContext.createSharedDurableConsumer</code> method, specifying the topic and subscription name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">JMSConsumer consumer =
        context.createSharedDurableConsumer(topic, "MakeItLast");</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="../jms-examples/jms-examples.html#_acknowledging_messages" class="xref page">Acknowledging Messages</a>, <a href="../jms-examples/jms-examples.html#_using_durable_subscriptions" class="xref page">Using Durable Subscriptions</a>, <a href="../jms-examples/jms-examples.html#_using_shared_durable_subscriptions" class="xref page">Using Shared Durable Subscriptions</a>, and <a href="../jms-examples/jms-examples.html#_sending_messages_from_a_session_bean_to_an_mdb" class="xref page">Sending Messages from a Session Bean to an MDB</a> for examples of Jakarta EE applications that use durable subscriptions.</p>
</div>
</div>
<div class="sect3">
<h4 id="_creating_shared_subscriptions"><a class="anchor" href="#_creating_shared_subscriptions"></a>Creating Shared Subscriptions</h4>
<div class="paragraph">
<p>A topic subscription created by the <code>createConsumer</code> or <code>createDurableConsumer</code> method can have only one consumer (although a topic can have many).
Multiple clients consuming from the same topic have, by definition, multiple subscriptions to the topic, and all the clients receive all the messages sent to the topic (unless they filter them with message selectors).</p>
</div>
<div class="paragraph">
<p>It is, however, possible to create a nondurable shared subscription to a topic by using the <code>createSharedConsumer</code> method and specifying not only a destination but a subscription name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">consumer = context.createSharedConsumer(topicName, "SubName");</code></pre>
</div>
</div>
<div class="paragraph">
<p>With a shared subscription, messages will be distributed among multiple clients that use the same topic and subscription name.
Each message sent to the topic will be added to every subscription (subject to any message selectors), but each message added to a subscription will be delivered to only one of the consumers on that subscription, so it will be received by only one of the clients.
A shared subscription can be useful if you want to share the message load among several consumers on the subscription rather than having just one consumer on the subscription receive each message.
This feature can improve the scalability of Jakarta EE application client applications and Java SE applications.
(Message-driven beans share the work of processing messages from a topic among multiple threads.)</p>
</div>
<div class="paragraph">
<p>See <a href="../jms-examples/jms-examples.html#_using_shared_nondurable_subscriptions" class="xref page">Using Shared Nondurable Subscriptions</a> for a simple example of using shared nondurable consumers.</p>
</div>
<div class="paragraph">
<p>You can also create shared durable subscriptions by using the <code>JMSContext.createSharedDurableConsumer</code> method.
For details, see <a href="#_creating_durable_subscriptions">Creating Durable Subscriptions</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jakarta_messaging_messages"><a class="anchor" href="#_jakarta_messaging_messages"></a>Jakarta Messaging Messages</h3>
<div class="paragraph">
<p>The ultimate purpose of a Jakarta Messaging application is to produce and consume messages that can then be used by other software applications.
Jakarta Messaging messages have a basic format that is simple but highly flexible, allowing you to create messages that match formats used by non-Jakarta Messaging applications on heterogeneous platforms.</p>
</div>
<div class="paragraph">
<p>A Jakarta Messaging message can have three parts: a header, properties, and a body.
Only the header is required.
The following sections describe these parts.</p>
</div>
<div class="paragraph">
<p>For complete documentation of message headers, properties, and bodies, see the documentation of the <code>Message</code> interface in the API documentation.
For a list of possible message types, see <a href="#_message_bodies">Message Bodies</a>.</p>
</div>
<div class="sect3">
<h4 id="_message_headers"><a class="anchor" href="#_message_headers"></a>Message Headers</h4>
<div class="paragraph">
<p>A Jakarta Messaging message header contains a number of predefined fields that contain values used by both clients and providers to identify and route messages.
<a href="#_how_jakarta_messaging_message_header_field_values_are_set">How Jakarta Messaging Message Header Field Values Are Set</a> lists and describes the Jakarta Messaging message header fields and indicates how their values are set.
For example, every message has a unique identifier, which is represented in the header field <code>JMSMessageID</code>.
The value of another header field, <code>JMSDestination</code>, represents the queue or the topic to which the message is sent.
Other fields include a timestamp and a priority level.</p>
</div>
<div class="paragraph">
<p>Each header field has associated setter and getter methods, which are documented in the description of the <code>Message</code> interface.
Some header fields are intended to be set by a client, but many are set automatically by the <code>send</code> method, which overrides any client-set values.</p>
</div>
<table id="_how_jakarta_messaging_message_header_field_values_are_set" class="tableblock frame-all grid-all" style="width: 99%;">
<caption class="title">How Jakarta Messaging Message Header Field Values Are Set</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 60%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Header Field</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Set By</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMSDestination</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Destination to which the message is being sent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JMS provider <code>send</code> method</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMSDeliveryMode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Delivery mode specified when the message was sent (see <a href="#_specifying_message_persistence">Specifying Message Persistence</a>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Messaging provider <code>send</code> method</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMSDeliveryTime</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time the message was sent plus the delivery delay specified when the message was sent (see <a href="#_specifying_a_delivery_delay">Specifying a Delivery Delay</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JMS provider <code>send</code> method</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMSExpiration</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Expiration time of the message (see <a href="#_allowing_messages_to_expire">Allowing Messages to Expire</a>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JMS provider <code>send</code> method</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMSPriority</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The priority of the message (see <a href="#_setting_message_priority_levels">Setting Message Priority Levels</a>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jakarta Messaging provider <code>send</code> method</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMSMessageID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value that uniquely identifies each message sent by a provider</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Messaging provider <code>send</code> method</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMSTimestamp</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time the message was handed off to a provider to be sent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Messaging provider <code>send</code> method</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMSCorrelationID</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value that links one message to another; commonly the <code>JMSMessageID</code> value is used</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client application</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMSReplyTo</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Destination where replies to the message should be sent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client application</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMSType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Type identifier supplied by client application</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Client application</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JMSRedelivered</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether the message is being redelivered</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jakarta Messaging provider prior to delivery</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_message_properties"><a class="anchor" href="#_message_properties"></a>Message Properties</h4>
<div class="paragraph">
<p>You can create and set properties for messages if you need values in addition to those provided by the header fields.
You can use properties to provide compatibility with other messaging systems, or you can use them to create message selectors (see <a href="#_jakarta_messaging_message_selectors">Jakarta Messaging Message Selectors</a>).
For an example of setting a property to be used as a message selector, see <a href="../jms-examples/jms-examples.html#_sending_messages_from_a_session_bean_to_an_mdb" class="xref page">Sending Messages from a Session Bean to an MDB</a>.</p>
</div>
<div class="paragraph">
<p>Jakarta Messaging provides some predefined property names that begin with <code>JMSX</code>.
A Messaging provider is required to implement only one of these, <code>JMSXDeliveryCount</code> (which specifies the number of times a message has been delivered); the rest are optional.
The use of these predefined properties or of user-defined properties in applications is optional.</p>
</div>
</div>
<div class="sect3">
<h4 id="_message_bodies"><a class="anchor" href="#_message_bodies"></a>Message Bodies</h4>
<div class="paragraph">
<p>Jakarta Messaging defines six different types of messages.
Each message type corresponds to a different message body.
These message types allow you to send and receive data in many different forms.
<a href="#_jakarta_messaging_message_types">Jakarta Messaging Message Types</a> describes these message types.</p>
</div>
<table id="_jakarta_messaging_message_types" class="tableblock frame-all grid-all" style="width: 75%;">
<caption class="title">Jakarta Messaging Message Types</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Message Type</th>
<th class="tableblock halign-left valign-top">Body Contains</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TextMessage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <code>java.lang.String</code> object (for example, the contents of an XML file).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MapMessage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A set of name-value pairs, with names as <code>String</code> objects and values as primitive types in the Java programming language.
The entries can be accessed sequentially by enumerator or randomly by name.
The order of the entries is undefined.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BytesMessage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A stream of uninterpreted bytes.
This message type is for literally encoding a body to match an existing message format.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StreamMessage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A stream of primitive values in the Java programming language, filled and read sequentially.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ObjectMessage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A <code>Serializable</code> object in the Java programming language.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Message</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nothing.
Composed of header fields and properties only.
This message type is useful when a message body is not required.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Jakarta Messaging provides methods for creating messages of each type and for filling in their contents.
For example, to create and send a <code>TextMessage</code>, you might use the following statements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">TextMessage message = context.createTextMessage();
message.setText(msg_text);     // msg_text is a String
context.createProducer().send(message);</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the consuming end, a message arrives as a generic <code>Message</code> object.
You can then cast the object to the appropriate message type and use more specific methods to access the body and extract the message contents (and its headers and properties if needed).
For example, you might use the stream-oriented read methods of <code>BytesMessage</code>.
You must always cast to the appropriate message type to retrieve the body of a <code>StreamMessage</code>.</p>
</div>
<div class="paragraph">
<p>Instead of casting the message to a message type, you can call the <code>getBody</code> method on the <code>Message</code>, specifying the type of the message as an argument.
For example, you can retrieve a <code>TextMessage</code> as a <code>String</code>.
The following code fragment uses the <code>getBody</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Message m = consumer.receive();
if (m instanceof TextMessage) {
    String message = m.getBody(String.class);
    System.out.println("Reading message: " + message);
} else {
    // Handle error or process another message type
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jakarta Messaging provides shortcuts for creating and receiving a <code>TextMessage</code>, <code>BytesMessage</code>, <code>MapMessage</code>, or <code>ObjectMessage</code>.
For example, you do not have to wrap a string in a <code>TextMessage</code>; instead, you can send and receive the string directly.
For example, you can send a string as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String message = "This is a message";
context.createProducer().send(dest, message);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can receive the message by using the <code>receiveBody</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String message = receiver.receiveBody(String.class);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the <code>receiveBody</code> method to receive any type of message except <code>StreamMessage</code> and <code>Message</code>, as long as the body of the message can be assigned to a particular type.</p>
</div>
<div class="paragraph">
<p>An empty <code>Message</code> can be useful if you want to send a message that is simply a signal to the application.
Some of the examples in <a href="../jms-examples/jms-examples.html#_jakarta_messaging_examples" class="xref page">Jakarta Messaging Examples</a>, send an empty message after sending a series of text messages.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">context.createProducer().send(dest, context.createMessage());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The consumer code can then interpret a non-text message as a signal that all the messages sent have now been received.</p>
</div>
<div class="paragraph">
<p>The examples in <a href="../jms-examples/jms-examples.html#_jakarta_messaging_examples" class="xref page">Jakarta Messaging Examples</a>, use messages of type <code>TextMessage</code>, <code>MapMessage</code>, and <code>Message</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jakarta_messaging_queue_browsers"><a class="anchor" href="#_jakarta_messaging_queue_browsers"></a>Jakarta Messaging Queue Browsers</h3>
<div class="paragraph">
<p>Messages sent to a queue remain in the queue until the message consumer for that queue consumes them.
Jakarta Messaging provides a <code>QueueBrowser</code> object that allows you to browse the messages in the queue and display the header values for each message.
To create a <code>QueueBrowser</code> object, use the <code>JMSContext.createBrowser</code> method.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">QueueBrowser browser = context.createBrowser(queue);</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="../jms-examples/jms-examples.html#_browsing_messages_on_a_queue" class="xref page">Browsing Messages on a Queue</a> for an example of using a <code>QueueBrowser</code> object.</p>
</div>
<div class="paragraph">
<p>The <code>createBrowser</code> method allows you to specify a message selector as a second argument when you create a <code>QueueBrowser</code>.
For information on message selectors, see <a href="#_jakarta_messaging_message_selectors">Jakarta Messaging Message Selectors</a>.</p>
</div>
<div class="paragraph">
<p>Jakarta Messaging provides no mechanism for browsing a topic.
Messages usually disappear from a topic as soon as they appear: If there are no message consumers to consume them, the Messaging provider removes them.
Although durable subscriptions allow messages to remain on a topic while the message consumer is not active, Jakarta Messaging does not define any facility for examining them.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jakarta_messaging_exception_handling"><a class="anchor" href="#_jakarta_messaging_exception_handling"></a>Jakarta Messaging Exception Handling</h3>
<div class="paragraph">
<p>The root class for all checked exceptions in Jakarta Messaging is <code>JMSException</code>.
The root cause for all unchecked exceptions in the Jakarta Messaging API is <code>JMSRuntimeException</code>.</p>
</div>
<div class="paragraph">
<p>Catching <code>JMSException</code> and <code>JMSRuntimeException</code> provides a generic way of handling all exceptions related to Jakarta Messaging.</p>
</div>
<div class="paragraph">
<p>The <code>JMSException</code> and <code>JMSRuntimeException</code> classes include the following subclasses, described in the API documentation:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IllegalStateException</code>, <code>IllegalStateRuntimeException</code></p>
</li>
<li>
<p><code>InvalidClientIDException</code>, <code>InvalidClientIDRuntimeException</code></p>
</li>
<li>
<p><code>InvalidDestinationException</code>, <code>InvalidDestinationRuntimeException</code></p>
</li>
<li>
<p><code>InvalidSelectorException</code>, <code>InvalidSelectorRuntimeException</code></p>
</li>
<li>
<p><code>JMSSecurityException</code>, <code>JMSSecurityRuntimeException</code></p>
</li>
<li>
<p><code>MessageEOFException</code></p>
</li>
<li>
<p><code>MessageFormatException</code>, <code>MessageFormatRuntimeException</code></p>
</li>
<li>
<p><code>MessageNotReadableException</code></p>
</li>
<li>
<p><code>MessageNotWriteableException</code>, <code>MessageNotWriteableRuntimeException</code></p>
</li>
<li>
<p><code>ResourceAllocationException</code>, <code>ResourceAllocationRuntimeException</code></p>
</li>
<li>
<p><code>TransactionInProgressException</code>, <code>TransactionInProgressRuntimeException</code></p>
</li>
<li>
<p><code>TransactionRolledBackException</code>, <code>TransactionRolledBackRuntimeException</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All the examples in the tutorial catch and handle <code>JMSException</code> or <code>JMSRuntimeException</code> when it is appropriate to do so.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_advanced_jakarta_messaging_features"><a class="anchor" href="#_using_advanced_jakarta_messaging_features"></a>Using Advanced Jakarta Messaging Features</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section explains how to use features of Jakarta Messaging to achieve the level of reliability and performance your application requires.
Many people use Jakarta Messaging in their applications because they cannot tolerate dropped or duplicate messages and because they require that every message be received once and only once.
Jakarta Messaging provides this functionality.</p>
</div>
<div class="paragraph">
<p>The most reliable way to produce a message is to send a <code>PERSISTENT</code> message, and to do so within a transaction.</p>
</div>
<div class="paragraph">
<p>Jakarta Messaging messages are <code>PERSISTENT</code> by default; <code>PERSISTENT</code> messages will not be lost in the event of Messaging provider failure.
For details, see <a href="#_specifying_message_persistence">Specifying Message Persistence</a>.</p>
</div>
<div class="paragraph">
<p>Transactions allow multiple messages to be sent or received in an atomic operation.In the Jakarta EE platform they also allow message sends and receives to be combined with database reads and writes in an atomic transaction.
A transaction is a unit of work into which you can group a series of operations, such as message sends and receives, so that the operations either all succeed or all fail.
For details, see <a href="#_using_jakarta_messaging_local_transactions">Using Jakarta Messaging Local Transactions</a>.</p>
</div>
<div class="paragraph">
<p>The most reliable way to consume a message is to do so within a transaction, either from a queue or from a durable subscription to a topic.
For details, see <a href="#_creating_durable_subscriptions">Creating Durable Subscriptions</a>, <a href="#_creating_temporary_destinations">Creating Temporary Destinations</a>, and <a href="#_using_jakarta_messaging_local_transactions">Using Jakarta Messaging Local Transactions</a>.</p>
</div>
<div class="paragraph">
<p>Some features primarily allow an application to improve performance.
For example, you can set messages to expire after a certain length of time (see <a href="#_allowing_messages_to_expire">Allowing Messages to Expire</a>), so that consumers do not receive unnecessary outdated information.
You can send messages asynchronously; see <a href="#_sending_messages_asynchronously">Sending Messages Asynchronously</a>.</p>
</div>
<div class="paragraph">
<p>You can also specify various levels of control over message acknowledgment; see <a href="#_controlling_message_acknowledgment">Controlling Message Acknowledgment</a>.</p>
</div>
<div class="paragraph">
<p>Other features can provide useful capabilities unrelated to reliability.
For example, you can create temporary destinations that last only for the duration of the connection in which they are created.
See <a href="#_creating_temporary_destinations">Creating Temporary Destinations</a> for details.</p>
</div>
<div class="paragraph">
<p>The following sections describe these features as they apply to application clients or Java SE clients.
Some of the features work differently in the Jakarta EE web or enterprise bean container; in these cases, the differences are noted here and are explained in detail in <a href="#_using_jakarta_messaging_in_jakarta_ee_applications">Using Jakarta Messaging in Jakarta EE Applications</a>.</p>
</div>
<div class="sect2">
<h3 id="_controlling_message_acknowledgment"><a class="anchor" href="#_controlling_message_acknowledgment"></a>Controlling Message Acknowledgment</h3>
<div class="paragraph">
<p>Until a Jakarta Messaging message has been acknowledged, it is not considered to be successfully consumed.
The successful consumption of a message ordinarily takes place in three stages.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The client receives the message.</p>
</li>
<li>
<p>The client processes the message.</p>
</li>
<li>
<p>The message is acknowledged.<br>
Acknowledgment is initiated either by the Messaging provider or by the client, depending on the session acknowledgment mode.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In locally transacted sessions (see <a href="#_using_jakarta_messaging_local_transactions">Using Jakarta Messaging Local Transactions</a>), a message is acknowledged when the session is committed.
If a transaction is rolled back, all consumed messages are redelivered.</p>
</div>
<div class="paragraph">
<p>In a Jakarta transaction (in the Jakarta EE web or enterprise bean container) a message is acknowledged when the transaction is committed.</p>
</div>
<div class="paragraph">
<p>In nontransacted sessions, when and how a message is acknowledged depend on a value that may be specified as an argument of the <code>createContext</code> method.
The possible argument values are as follows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JMSContext.AUTO_ACKNOWLEDGE</code>: This setting is the default for application clients and Java SE clients.
The <code>JMSContext</code> automatically acknowledges a client&#8217;s receipt of a message either when the client has successfully returned from a call to <code>receive</code> or when the <code>MessageListener</code> it has called to process the message returns successfully.</p>
<div class="paragraph">
<p>A synchronous receive in a <code>JMSContext</code> that is configured to use auto-acknowledgment is the one exception to the rule that message consumption is a three-stage process as described earlier.
In this case, the receipt and acknowledgment take place in one step, followed by the processing of the message.</p>
</div>
</li>
<li>
<p><code>JMSContext.CLIENT_ACKNOWLEDGE</code>: A client acknowledges a message by calling the message&#8217;s <code>acknowledge</code> method.
In this mode, acknowledgment takes place on the session level: Acknowledging a consumed message automatically acknowledges the receipt of all messages that have been consumed by its session.
For example, if a message consumer consumes ten messages and then acknowledges the fifth message delivered, all ten messages are acknowledged.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In the Jakarta EE platform, the <code>JMSContext.CLIENT_ACKNOWLEDGE</code> setting can be used only in an application client, not in a web component or enterprise bean.
</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>JMSContext.DUPS_OK_ACKNOWLEDGE</code>: This option instructs the <code>JMSContext</code> to lazily acknowledge the delivery of messages.
This is likely to result in the delivery of some duplicate messages if the Messaging provider fails, so it should be used only by consumers that can tolerate duplicate messages.
(If the Messaging provider redelivers a message, it must set the value of the <code>JMSRedelivered</code> message header to <code>true</code>.)
This option can reduce session overhead by minimizing the work the session does to prevent duplicates.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If messages have been received from a queue but not acknowledged when a <code>JMSContext</code> is closed, the Messaging provider retains them and redelivers them when a consumer next accesses the queue.
The provider also retains unacknowledged messages if an application closes a <code>JMSContext</code> that has been consuming messages from a durable subscription.
(See <a href="#_creating_durable_subscriptions">Creating Durable Subscriptions</a>.)
Unacknowledged messages that have been received from a nondurable subscription will be dropped when the <code>JMSContext</code> is closed.</p>
</div>
<div class="paragraph">
<p>If you use a queue or a durable subscription, you can use the <code>JMSContext.recover</code> method to stop a nontransacted <code>JMSContext</code> and restart it with its first unacknowledged message.
In effect, the <code>JMSContext</code>'s series of delivered messages is reset to the point after its last acknowledged message.
The messages it now delivers may be different from those that were originally delivered, if messages have expired or if higher-priority messages have arrived.
For a consumer on a nondurable subscription, the provider may drop unacknowledged messages when the <code>JMSContext.recover</code> method is called.</p>
</div>
<div class="paragraph">
<p>The sample program in <a href="../jms-examples/jms-examples.html#_acknowledging_messages" class="xref page">Acknowledging Messages</a> demonstrates two ways to ensure that a message will not be acknowledged until processing of the message is complete.</p>
</div>
</div>
<div class="sect2">
<h3 id="_specifying_options_for_sending_messages"><a class="anchor" href="#_specifying_options_for_sending_messages"></a>Specifying Options for Sending Messages</h3>
<div class="paragraph">
<p>You can set a number of options when you send a message.
These options enable you to perform the tasks described in the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#_specifying_message_persistence">Specifying Message Persistence</a> - Specify that messages are persistent, meaning they must not be lost in the event of a provider failure.</p>
</li>
<li>
<p><a href="#_setting_message_priority_levels">Setting Message Priority Levels</a> - Set priority levels for messages, which can affect the order in which the messages are delivered.</p>
</li>
<li>
<p><a href="#_allowing_messages_to_expire">Allowing Messages to Expire</a> - Specify an expiration time for messages so they will not be delivered if they are obsolete.</p>
</li>
<li>
<p><a href="#_specifying_a_delivery_delay">Specifying a Delivery Delay</a> - Specify a delivery delay for messages so that they will not be delivered until a specified amount of time has expired.</p>
</li>
<li>
<p><a href="#_using_jmsproducer_method_chaining">Using JMSProducer Method Chaining</a> - Method chaining allows you to specify more than one of these options when you create a producer and call the <code>send</code> method.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_specifying_message_persistence"><a class="anchor" href="#_specifying_message_persistence"></a>Specifying Message Persistence</h4>
<div class="paragraph">
<p>Jakarta Messaging supports two delivery modes specifying whether messages are lost if the Messaging provider fails.
These delivery modes are fields of the <code>DeliveryMode</code> interface.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The default delivery mode, <code>PERSISTENT</code>, instructs the Messaging provider to take extra care to ensure that a message is not lost in transit in case of a Messaging provider failure.
A message sent with this delivery mode is logged to stable storage when it is sent.</p>
</li>
<li>
<p>The <code>NON_PERSISTENT</code> delivery mode does not require the Messaging provider to store the message or otherwise guarantee that it is not lost if the provider fails.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To specify the delivery mode, use the <code>setDeliveryMode</code> method of the <code>JMSProducer</code> interface to set the delivery mode for all messages sent by that producer.</p>
</div>
<div class="paragraph">
<p>You can use method chaining to set the delivery mode when you create a producer and send a message.
The following call creates a producer with a <code>NON_PERSISTENT</code> delivery mode and uses it to send a message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">context.createProducer()
       .setDeliveryMode(DeliveryMode.NON_PERSISTENT).send(dest, msg);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do not specify a delivery mode, the default is <code>PERSISTENT</code>.
Using the <code>NON_PERSISTENT</code> delivery mode may improve performance and reduce storage overhead, but you should use it only if your application can afford to miss messages.</p>
</div>
</div>
<div class="sect3">
<h4 id="_setting_message_priority_levels"><a class="anchor" href="#_setting_message_priority_levels"></a>Setting Message Priority Levels</h4>
<div class="paragraph">
<p>You can use message priority levels to instruct the Messaging provider to deliver urgent messages first.
Use the <code>setPriority</code> method of the <code>JMSProducer</code> interface to set the priority level for all messages sent by that producer.</p>
</div>
<div class="paragraph">
<p>You can use method chaining to set the priority level when you create a producer and send a message.
For example, the following call sets a priority level of 7 for a producer and then sends a message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">context.createProducer().setPriority(7).send(dest, msg);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The ten levels of priority range from 0 (lowest) to 9 (highest).
If you do not specify a priority level, the default level is 4.
A Messaging provider tries to deliver higher-priority messages before lower-priority ones, but does not have to deliver messages in exact order of priority.</p>
</div>
</div>
<div class="sect3">
<h4 id="_allowing_messages_to_expire"><a class="anchor" href="#_allowing_messages_to_expire"></a>Allowing Messages to Expire</h4>
<div class="paragraph">
<p>By default, a message never expires.
If a message will become obsolete after a certain period, however, you may want to set an expiration time.
Use the <code>setTimeToLive</code> method of the <code>JMSProducer</code> interface to set a default expiration time for all messages sent by that producer.</p>
</div>
<div class="paragraph">
<p>For example, a message that contains rapidly changing data such as a stock price will become obsolete after a few minutes, so you might configure messages to expire after that time.</p>
</div>
<div class="paragraph">
<p>You can use method chaining to set the time to live when you create a producer and send a message.
For example, the following call sets a time to live of five minutes for a producer and then sends a message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">context.createProducer().setTimeToLive(300000).send(dest, msg);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the specified <code>timeToLive</code> value is <code>0</code>, the message never expires.</p>
</div>
<div class="paragraph">
<p>When the message is sent, the specified <code>timeToLive</code> is added to the current time to give the expiration time.
Any message not delivered before the specified expiration time is destroyed.
The destruction of obsolete messages conserves storage and computing resources.</p>
</div>
</div>
<div class="sect3">
<h4 id="_specifying_a_delivery_delay"><a class="anchor" href="#_specifying_a_delivery_delay"></a>Specifying a Delivery Delay</h4>
<div class="paragraph">
<p>You can specify a length of time that must elapse after a message is sent before the Messaging provider delivers the message.
Use the <code>setDeliveryDelay</code> method of the <code>JMSProducer</code> interface to set a delivery delay for all messages sent by that producer.</p>
</div>
<div class="paragraph">
<p>You can use method chaining to set the delivery delay when you create a producer and send a message.
For example, the following call sets a delivery delay of 3 seconds for a producer and then sends a message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">context.createProducer().setDeliveryDelay(3000).send(dest, msg);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_jmsproducer_method_chaining"><a class="anchor" href="#_using_jmsproducer_method_chaining"></a>Using JMSProducer Method Chaining</h4>
<div class="paragraph">
<p>The setter methods on the <code>JMSProducer</code> interface return <code>JMSProducer</code> objects, so you can use method chaining to create a producer, set multiple properties, and send a message.
For example, the following chained method calls create a producer, set a user-defined property, set the expiration, delivery mode, and priority for the message, and then send a message to a queue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">context.createProducer()
        .setProperty("MyProperty", "MyValue")
        .setTimeToLive(10000)
        .setDeliveryMode(NON_PERSISTENT)
        .setPriority(2)
        .send(queue, body);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also call the <code>JMSProducer</code> methods to set properties on a message and then send the message in a separate <code>send</code> method call.
You can also set message properties directly on a message.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_temporary_destinations"><a class="anchor" href="#_creating_temporary_destinations"></a>Creating Temporary Destinations</h3>
<div class="paragraph">
<p>Normally, you create JMS destinations (queues and topics) administratively rather than programmatically.
Your Messaging provider includes a tool to create and remove destinations, and it is common for destinations to be long-lasting.</p>
</div>
<div class="paragraph">
<p>Jakarta Messaging also enables you to create destinations (<code>TemporaryQueue</code> and <code>TemporaryTopic</code> objects) that last only for the duration of the connection in which they are created.
You create these destinations dynamically using the <code>JMSContext.createTemporaryQueue</code> and the <code>JMSContext.createTemporaryTopic</code> methods, as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">TemporaryTopic replyTopic = context.createTemporaryTopic();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The only message consumers that can consume from a temporary destination are those created by the same connection that created the destination.
Any message producer can send to the temporary destination.
If you close the connection to which a temporary destination belongs, the destination is closed and its contents are lost.</p>
</div>
<div class="paragraph">
<p>You can use temporary destinations to implement a simple request/reply mechanism.
If you create a temporary destination and specify it as the value of the <code>JMSReplyTo</code> message header field when you send a message, then the consumer of the message can use the value of the <code>JMSReplyTo</code> field as the destination to which it sends a reply.
The consumer can also reference the original request by setting the <code>JMSCorrelationID</code> header field of the reply message to the value of the <code>JMSMessageID</code> header field of the request.
For example, an <code>onMessage</code> method can create a <code>JMSContext</code> so that it can send a reply to the message it receives.
It can use code such as the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">replyMsg = context.createTextMessage("Consumer processed message: "
        + msg.getText());
replyMsg.setJMSCorrelationID(msg.getJMSMessageID());
context.createProducer().send((Topic) msg.getJMSReplyTo(), replyMsg);</code></pre>
</div>
</div>
<div class="paragraph">
<p>For an example, see <a href="../jms-examples/jms-examples.html#_using_an_entity_to_join_messages_from_two_mdbs" class="xref page">Using an Entity to Join Messages from Two MDBs</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_jakarta_messaging_local_transactions"><a class="anchor" href="#_using_jakarta_messaging_local_transactions"></a>Using Jakarta Messaging Local Transactions</h3>
<div class="paragraph">
<p>A transaction groups a series of operations into an atomic unit of work.
If any one of the operations fails, the transaction can be rolled back, and the operations can be attempted again from the beginning.
If all the operations succeed, the transaction can be committed.</p>
</div>
<div class="paragraph">
<p>In an application client or a Java SE client, you can use local transactions to group message sends and receives.
You use the <code>JMSContext.commit</code> method to commit a transaction.
You can send multiple messages in a transaction, and the messages will not be added to the queue or topic until the transaction is committed.
If you receive multiple messages in a transaction, they will not be acknowledged until the transaction is committed.</p>
</div>
<div class="paragraph">
<p>You can use the <code>JMSContext.rollback</code> method to roll back a transaction.
A transaction rollback means that all produced messages are destroyed and all consumed messages are recovered and redelivered unless they have expired (see <a href="#_allowing_messages_to_expire">Allowing Messages to Expire</a>).</p>
</div>
<div class="paragraph">
<p>A transacted session is always involved in a transaction.
To create a transacted session, call the <code>createContext</code> method as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">JMSContext context =
        connectionFactory.createContext(JMSContext.SESSION_TRANSACTED);</code></pre>
</div>
</div>
<div class="paragraph">
<p>As soon as the <code>commit</code> or the <code>rollback</code> method is called, one transaction ends and another transaction begins.
Closing a transacted session rolls back its transaction in progress, including any pending sends and receives.</p>
</div>
<div class="paragraph">
<p>In an application running in the Jakarta EE web or enterprise bean container, you cannot use local transactions.
Instead, you use Jakarta Transactions, described in <a href="#_using_jakarta_messaging_in_jakarta_ee_applications">Using Jakarta Messaging in Jakarta EE Applications</a>.</p>
</div>
<div class="paragraph">
<p>You can combine several sends and receives in a single Jakarta Messaging local transaction, so long as they are all performed using the same <code>JMSContext</code>.</p>
</div>
<div class="paragraph">
<p>Do not use a single transaction if you use a request/reply mechanism, in which you send a message and then receive a reply to that message.
If you try to use a single transaction, the program will hang, because the send cannot take place until the transaction is committed.
The following code fragment illustrates the problem:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Don't do this!
outMsg.setJMSReplyTo(replyQueue);
context.createProducer().send(outQueue, outMsg);
consumer = context.createConsumer(replyQueue);
inMsg = consumer.receive();
context.commit();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because a message sent during a transaction is not actually sent until the transaction is committed, the transaction cannot contain any receives that depend on that message&#8217;s having been sent.</p>
</div>
<div class="paragraph">
<p>The production and the consumption of a message cannot both be part of the same transaction.
The reason is that the transactions take place between the clients and the Messaging provider, which intervenes between the production and the consumption of the message.
<a href="#_using_jakarta_messaging_local_transactions_2">Figure 8, &#8220;Using Jakarta Messaging Local Transactions&#8221;</a> illustrates this interaction.</p>
</div>
<div id="_using_jakarta_messaging_local_transactions_2" class="imageblock">
<div class="content">
<img src="../../common/_images/jakartaeett_dt_033.svg" alt="Diagram of local transactions, showing separate transactions for sending and consuming a message">
</div>
<div class="title">Figure 8. Using Jakarta Messaging Local Transactions</div>
</div>
<div class="paragraph">
<p>The sending of one or more messages to one or more destinations by Client 1 can form a single transaction, because it forms a single set of interactions with the Messaging provider using a single <code>JMSContext</code>.
Similarly, the receiving of one or more messages from one or more destinations by Client 2 also forms a single transaction using a single <code>JMSContext</code>.
But because the two clients have no direct interaction and are using two different <code>JMSContext</code> objects, no transactions can take place between them.</p>
</div>
<div class="paragraph">
<p>Another way of putting this is that a transaction is a contract between a client and a Messaging provider that defines whether a message is sent to a destination or whether a message is received from the destination.
It is not a contract between the sending client and the receiving client.</p>
</div>
<div class="paragraph">
<p>This is the fundamental difference between messaging and synchronized processing.
Instead of tightly coupling the sender and the receiver of a message, JMS couples the sender of a message with the destination, and it separately couples the destination with the receiver of the message.
Therefore, while the sends and receives each have a tight coupling with the Messaging provider, they do not have any coupling with each other.</p>
</div>
<div class="paragraph">
<p>When you create a <code>JMSContext</code>, you can specify whether it is transacted by using the <code>JMSContext.SESSION_TRANSACTED</code> argument to the <code>createContext</code> method.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">try (JMSContext context = connectionFactory.createContext(
        JMSContext.SESSION_TRANSACTED);) {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>commit</code> and the <code>rollback</code> methods for local transactions are associated with the session that underlies the <code>JMSContext</code>.
You can combine operations on more than one queue or topic, or on a combination of queues and topics, in a single transaction if you use the same session to perform the operations.
For example, you can use the same <code>JMSContext</code> to receive a message from a queue and send a message to a topic in the same transaction.</p>
</div>
<div class="paragraph">
<p>The example in <a href="../jms-examples/jms-examples.html#_using_local_transactions" class="xref page">Using Local Transactions</a> shows how to use Jakarta Messaging local transactions.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sending_messages_asynchronously"><a class="anchor" href="#_sending_messages_asynchronously"></a>Sending Messages Asynchronously</h3>
<div class="paragraph">
<p>Normally, when you send a persistent message, the <code>send</code> method blocks until the Messaging provider confirms that the message was sent successfully.
The asynchronous send mechanism allows your application to send a message and continue work while waiting to learn whether the send completed.</p>
</div>
<div class="paragraph">
<p>This feature is currently available only in application clients and Java SE clients.</p>
</div>
<div class="paragraph">
<p>Sending a message asynchronously involves supplying a callback object.
You specify a <code>CompletionListener</code> with an <code>onCompletion</code> method.
For example, the following code instantiates a <code>CompletionListener</code> named <code>SendListener</code>.
It then calls the <code>setAsync</code> method to specify that sends from this producer should be asynchronous and should use the specified listener:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompletionListener listener = new SendListener();
context.createProducer().setAsync(listener).send(dest, message);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>CompletionListener</code> class must implement two methods, <code>onCompletion</code> and <code>onException</code>.
The <code>onCompletion</code> method is called if the send succeeds, and the <code>onException</code> method is called if it fails.
A simple implementation of these methods might look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Override
public void onCompletion(Message message) {
    System.out.println("onCompletion method: Send has completed.");
}

@Override
public void onException(Message message, Exception e) {
    System.out.println("onException method: send failed: " + e.toString());
    System.out.println("Unsent message is: \n" + message);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_jakarta_messaging_in_jakarta_ee_applications"><a class="anchor" href="#_using_jakarta_messaging_in_jakarta_ee_applications"></a>Using Jakarta Messaging in Jakarta EE Applications</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section describes how using Jakarta Messaging in enterprise bean applications or web applications differs from using it in application clients.</p>
</div>
<div class="sect2">
<h3 id="_overview_of_using_jakarta_messaging"><a class="anchor" href="#_overview_of_using_jakarta_messaging"></a>Overview of Using Jakarta Messaging</h3>
<div class="paragraph">
<p>A general rule in the Jakarta EE platform specification applies to all Jakarta EE components that use Jakarta Messaging within enterprise bean or web containers: Application components in the web and enterprise bean containers must not attempt to create more than one active (not closed) <code>Session</code> object per connection.
Multiple <code>JMSContext</code> objects are permitted, however, since they combine a single connection and a single session.</p>
</div>
<div class="paragraph">
<p>This rule does not apply to application clients.
The application client container supports the creation of multiple sessions for each connection.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_resources_for_jakarta_ee_applications"><a class="anchor" href="#_creating_resources_for_jakarta_ee_applications"></a>Creating Resources for Jakarta EE Applications</h3>
<div class="paragraph">
<p>You can use annotations to create application-specific connection factories and destinations for Jakarta EE enterprise bean or web components.
The resources you create in this way are visible only to the application for which you create them.</p>
</div>
<div class="paragraph">
<p>You can also use deployment descriptor elements to create these resources.
Elements specified in the deployment descriptor override elements specified in annotations.
See <a href="../../platform/packaging/packaging.html#_packaging_applications" class="xref page">Packaging Applications</a> for basic information about deployment descriptors.
You must use a deployment descriptor to create application-specific resources for application clients.</p>
</div>
<div class="paragraph">
<p>To create a destination, use a <code>@JMSDestinationDefinition</code> annotation like the following on a class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@JMSDestinationDefinition(
    name = "java:app/jms/myappTopic",
    interfaceName = "jakarta.jms.Topic",
    destinationName = "MyPhysicalAppTopic"
  )</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>name</code>, <code>interfaceName</code>, and <code>destinationName</code> elements are required.
You can optionally specify a <code>description</code> element.
To create multiple destinations, enclose them in a <code>@JMSDestinationDefinitions</code> annotation, separated by commas.</p>
</div>
<div class="paragraph">
<p>To create a connection factory, use a <code>@JMSConnectionFactoryDefinition</code> annotation like the following on a class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@JMSConnectionFactoryDefinition(
    name="java:app/jms/MyConnectionFactory"
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>name</code> element is required.
You can optionally specify a number of other elements, such as <code>clientId</code> if you want to use the connection factory for durable subscriptions, or <code>description</code>.
If you do not specify the <code>interfaceName</code> element, the default interface is <code>jakarta.jms.ConnectionFactory</code>.
To create multiple connection factories, enclose them in a <code>@JMSConnectionFactoryDefinitions</code> annotation, separated by commas.</p>
</div>
<div class="paragraph">
<p>You need to specify the annotation only once for a given application, in any of the components.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If your application contains one or more message-driven beans, you may want to place the annotation on one of the message-driven beans.
If you place the annotation on a sending component such as an application client, you need to specify the <code>mappedName</code> element to look up the topic, instead of using the <code>destinationLookup</code> property of the activation configuration specification.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When you inject the resource into a component, use the value of the <code>name</code> element in the definition annotation as the value of the <code>lookup</code> element in the <code>@Resource</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Resource(lookup = "java:app/jms/myappTopic")
private Topic topic;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following portable JNDI namespaces are available.
Which ones you can use depends on how your application is packaged.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java:global</code>: Makes the resource available to all deployed applications</p>
</li>
<li>
<p><code>java:app</code>: Makes the resource available to all components in all modules in a single application</p>
</li>
<li>
<p><code>java:module</code>: Makes the resource available to all components within a given module (for example, all enterprise beans within a Jakarta Enterprise Beans module)</p>
</li>
<li>
<p><code>java:comp</code>: Makes the resource available to a single component only (except in a web application, where it is equivalent to <code>java:module</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the API documentation for details on these annotations.
The examples in <a href="../jms-examples/jms-examples.html#_sending_and_receiving_messages_using_a_simple_web_application" class="xref page">Sending and Receiving Messages Using a Simple Web Application</a>, <a href="../jms-examples/jms-examples.html#_sending_messages_from_a_session_bean_to_an_mdb" class="xref page">Sending Messages from a Session Bean to an MDB</a>, and <a href="../jms-examples/jms-examples.html#_using_an_entity_to_join_messages_from_two_mdbs" class="xref page">Using an Entity to Join Messages from Two MDBs</a> all use the <code>@JMSDestinationDefinition</code> annotation.
The other JMS examples do not use these annotations.
The examples that consist only of application clients are not deployed in the application server and must therefore communicate with each other using administratively created resources that exist outside of individual applications.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_resource_injection_in_enterprise_bean_or_web_components"><a class="anchor" href="#_using_resource_injection_in_enterprise_bean_or_web_components"></a>Using Resource Injection in Enterprise Bean or Web Components</h3>
<div class="paragraph">
<p>You may use resource injection to inject both administered objects and <code>JMSContext</code> objects in Jakarta EE applications.</p>
</div>
<div class="sect3">
<h4 id="_injecting_a_connectionfactory_queue_or_topic"><a class="anchor" href="#_injecting_a_connectionfactory_queue_or_topic"></a>Injecting a ConnectionFactory, Queue, or Topic</h4>
<div class="paragraph">
<p>Normally, you use the <code>@Resource</code> annotation to inject a <code>ConnectionFactory</code>, <code>Queue</code>, or <code>Topic</code> into your Jakarta EE application.
These objects must be created administratively before you deploy your application.
You may want to use the default connection factory, whose JNDI name is <code>java:comp/DefaultJMSConnectionFactory</code>.</p>
</div>
<div class="paragraph">
<p>When you use resource injection in an application client component, you normally declare the Messaging resource static:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Resource(lookup = "java:comp/DefaultJMSConnectionFactory")
private static ConnectionFactory connectionFactory;

@Resource(lookup = "jms/MyQueue")
private static Queue queue;</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, when you use this annotation in a session bean, a message-driven bean, or a web component, do not declare the resource static:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Resource(lookup = "java:comp/DefaultJMSConnectionFactory")
private ConnectionFactory connectionFactory;

@Resource(lookup = "jms/MyTopic")
private Topic topic;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you declare the resource static in these components, runtime errors will result.</p>
</div>
</div>
<div class="sect3">
<h4 id="_injecting_a_jmscontext_object"><a class="anchor" href="#_injecting_a_jmscontext_object"></a>Injecting a JMSContext Object</h4>
<div class="paragraph">
<p>To access a <code>JMSContext</code> object in an enterprise bean or web component, instead of injecting the <code>ConnectionFactory</code> resource and then creating a <code>JMSContext</code>, you can use the <code>@Inject</code> and <code>@JMSConnectionFactory</code> annotations to inject a <code>JMSContext</code>.
To use the default connection factory, use code like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
private JMSContext context1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use your own connection factory, use code like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject
@JMSConnectionFactory("jms/MyConnectionFactory")
private JMSContext context2;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_jakarta_ee_components_to_produce_and_to_synchronously_receive_messages"><a class="anchor" href="#_using_jakarta_ee_components_to_produce_and_to_synchronously_receive_messages"></a>Using Jakarta EE Components to Produce and to Synchronously Receive Messages</h3>
<div class="paragraph">
<p>An application that produces messages or synchronously receives them can use a Jakarta EE web or Jakarta Enterprise Beans component, such as a managed bean, a servlet, or a session bean, to perform these operations.
The example in <a href="../jms-examples/jms-examples.html#_sending_messages_from_a_session_bean_to_an_mdb" class="xref page">Sending Messages from a Session Bean to an MDB</a> uses a stateless session bean to send messages to a topic.
The example in <a href="../jms-examples/jms-examples.html#_sending_and_receiving_messages_using_a_simple_web_application" class="xref page">Sending and Receiving Messages Using a Simple Web Application</a> uses managed beans to produce and to consume messages.</p>
</div>
<div class="paragraph">
<p>Because a synchronous receive with no specified timeout ties up server resources, this mechanism usually is not the best application design for a web or Jakarta Enterprise Beans component.
Instead, use a synchronous receive that specifies a timeout value, or use a message-driven bean to receive messages asynchronously.
For details about synchronous receives, see <a href="#_jakarta_messaging_message_consumers">Jakarta Messaging Message Consumers</a>.</p>
</div>
<div class="paragraph">
<p>Using Jakarta Messaging in a Jakarta EE component is in many ways similar to using it in an application client.
The main differences are the areas of resource management and transactions.</p>
</div>
<div class="sect3">
<h4 id="_managing_jakarta_messaging_resources_in_web_and_jakarta_enterprise_beans_components"><a class="anchor" href="#_managing_jakarta_messaging_resources_in_web_and_jakarta_enterprise_beans_components"></a>Managing Jakarta Messaging Resources in Web and Jakarta Enterprise Beans Components</h4>
<div class="paragraph">
<p>The Jakarta Messaging resources are a connection and a session, usually combined in a <code>JMSContext</code> object.
In general, it is important to release Messaging resources when they are no longer being used.
Here are some useful practices to follow.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you wish to maintain a Messaging resource only for the life span of a business method, use a <code>try</code>-with-resources statement to create the <code>JMSContext</code> so that it will be closed automatically at the end of the <code>try</code> block.</p>
</li>
<li>
<p>To maintain a Messaging resource for the duration of a transaction or request, inject the <code>JMSContext</code> as described in <a href="#_injecting_a_jmscontext_object">Injecting a JMSContext Object</a>.
This will also cause the resource to be released when it is no longer needed.</p>
</li>
<li>
<p>If you would like to maintain a Messaging resource for the life span of an enterprise bean instance, you can use a <code>@PostConstruct</code> callback method to create the resource and a <code>@PreDestroy</code> callback method to close the resource.
However, there is normally no need to do this, since application servers usually maintain a pool of connections.
If you use a stateful session bean and you wish to maintain the Messaging resource in a cached state, you must close the resource in a <code>@PrePassivate</code> callback method and set its value to <code>null</code>, and you must create it again in a <code>@PostActivate</code> callback method.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_managing_transactions_in_session_beans"><a class="anchor" href="#_managing_transactions_in_session_beans"></a>Managing Transactions in Session Beans</h4>
<div class="paragraph">
<p>Instead of using local transactions, you use Jakarta transactions.
You can use either container-managed transactions or bean-managed transactions.
Normally, you use container-managed transactions for bean methods that perform sends or receives, allowing the enterprise bean container to handle transaction demarcation.
Because container-managed transactions are the default, you do not have to specify them.</p>
</div>
<div class="paragraph">
<p>You can use bean-managed transactions and the <code>jakarta.transaction.UserTransaction</code> interface&#8217;s transaction demarcation methods, but you should do so only if your application has special requirements and you are an expert in using transactions.
Usually, container-managed transactions produce the most efficient and correct behavior.
This tutorial does not provide any examples of bean-managed transactions.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_message_driven_beans_to_receive_messages_asynchronously"><a class="anchor" href="#_using_message_driven_beans_to_receive_messages_asynchronously"></a>Using Message-Driven Beans to Receive Messages Asynchronously</h3>
<div class="paragraph">
<p>The sections <a href="../../entbeans/ejb-intro/ejb-intro.html#_what_is_a_message_driven_bean" class="xref page">What Is a Message-Driven Bean?</a> and <a href="#_how_does_jakarta_messaging_work_with_the_jakarta_ee_platform">How Does Jakarta Messaging Work with the Jakarta EE Platform?</a> describe how the Jakarta EE platform supports a special kind of enterprise bean, the message-driven bean, which allows Jakarta EE applications to process Jakarta Messaging messages asynchronously.
Other Jakarta EE web and Jakarta Enterprise Beans components allow you to send messages and to receive them synchronously but not asynchronously.</p>
</div>
<div class="paragraph">
<p>A message-driven bean is a message listener to which messages can be delivered from either a queue or a topic.
The messages can be sent by any Jakarta EE component (from an application client, another enterprise bean, or a web component) or from an application or a system that does not use Jakarta EE technology.</p>
</div>
<div class="paragraph">
<p>A message-driven bean class has the following requirements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It must be annotated with the <code>@MessageDriven</code> annotation if it does not use a deployment descriptor.</p>
</li>
<li>
<p>The class must be defined as <code>public</code>, but not as <code>abstract</code> or <code>final</code>.</p>
</li>
<li>
<p>It must contain a public constructor with no arguments.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It is recommended, but not required, that a message-driven bean class implement the message listener interface for the message type it supports.
A bean that supports Jakarta Messaging implements the <code>jakarta.jms.MessageListener</code> interface, which means that it must provide an <code>onMessage</code> method with the following signature:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void onMessage(Message inMessage)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>onMessage</code> method is called by the bean&#8217;s container when a message has arrived for the bean to service.
This method contains the business logic that handles the processing of the message.
It is the message-driven bean&#8217;s responsibility to parse the message and perform the necessary business logic.</p>
</div>
<div class="paragraph">
<p>A message-driven bean differs from an application client&#8217;s message listener in the following ways.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In an application client, you must create a <code>JMSContext</code>, then create a <code>JMSConsumer</code>, then call <code>setMessageListener</code> to activate the listener.
For a message-driven bean, you need only define the class and annotate it, and the enterprise bean container creates it for you.</p>
</li>
<li>
<p>The bean class uses the <code>@MessageDriven</code> annotation, which typically contains an <code>activationConfig</code> element containing <code>@ActivationConfigProperty</code> annotations that specify properties used by the bean or the connection factory.
These properties can include the connection factory, a destination type, a durable subscription, a message selector, or an acknowledgment mode.
Some of the examples in <a href="../jms-examples/jms-examples.html#_jakarta_messaging_examples" class="xref page">Jakarta Messaging Examples</a> set these properties.
You can also set the properties in the deployment descriptor.</p>
</li>
<li>
<p>The application client container has only one instance of a <code>MessageListener</code>, which is called on a single thread at a time.
A message-driven bean, however, may have multiple instances, configured by the container, which may be called concurrently by multiple threads (although each instance is called by only one thread at a time).
Message-driven beans may therefore allow much faster processing of messages than message listeners.</p>
</li>
<li>
<p>You do not need to specify a message acknowledgment mode unless you use bean-managed transactions.
The message is consumed in the transaction in which the <code>onMessage</code> method is invoked.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#_activationconfigproperty_settings_for_message_driven_beans">@ActivationConfigProperty Settings for Message-Driven Beans</a> lists the activation configuration properties defined by the Jakarta Messaging specification.</p>
</div>
<table id="_activationconfigproperty_settings_for_message_driven_beans" class="tableblock frame-all grid-all" style="width: 80%;">
<caption class="title">@ActivationConfigProperty Settings for Message-Driven Beans</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property Name</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>acknowledgeMode</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Acknowledgment mode, used only for bean-managed transactions; the default is <code>Auto-acknowledge</code> (<code>Dups-ok-acknowledge</code> is also permitted)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destinationLookup</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The lookup name of the queue or topic from which the bean will receive messages</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>destinationType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Either <code>jakarta.jms.Queue</code> or <code>jakarta.jms.Topic</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>subscriptionDurability</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For durable subscriptions, set the value to <code>Durable</code>; see <a href="#_creating_durable_subscriptions">Creating Durable Subscriptions</a> for more information</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientId</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For durable subscriptions, the client ID for the connection (optional)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>subscriptionName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">For durable subscriptions, the name of the subscription</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>messageSelector</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A string that filters messages; see <a href="#_jakarta_messaging_message_selectors">Jakarta Messaging Message Selectors</a> for information</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>connectionFactoryLookup</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The lookup name of the connection factory to be used to connect to the Messaging provider from which the bean will receive messages</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For example, here is the message-driven bean used in <a href="../jms-examples/jms-examples.html#_receiving_messages_asynchronously_using_a_message_driven_bean" class="xref page">Receiving Messages Asynchronously Using a Message-Driven Bean</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@MessageDriven(activationConfig = {
    @ActivationConfigProperty(propertyName = "destinationLookup",
            propertyValue = "jms/MyQueue"),
    @ActivationConfigProperty(propertyName = "destinationType",
            propertyValue = "jakarta.jms.Queue")
})
public class SimpleMessageBean implements MessageListener {

    @Resource
    private MessageDrivenContext mdc;
    static final Logger logger = Logger.getLogger("SimpleMessageBean");

    public SimpleMessageBean() {
    }

    @Override
    public void onMessage(Message inMessage) {

        try {
            if (inMessage instanceof TextMessage) {
                logger.log(Level.INFO,
                        "MESSAGE BEAN: Message received: {0}",
                        inMessage.getBody(String.class));
            } else {
                logger.log(Level.WARNING,
                        "Message of wrong type: {0}",
                        inMessage.getClass().getName());
            }
        } catch (JMSException e) {
            logger.log(Level.SEVERE,
                    "SimpleMessageBean.onMessage: JMSException: {0}",
                    e.toString());
            mdc.setRollbackOnly();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If Jakarta Messaging is integrated with the application server using a resource adapter, the Messaging resource adapter handles these tasks for the enterprise bean container.</p>
</div>
<div class="paragraph">
<p>The bean class commonly injects a <code>MessageDrivenContext</code> resource, which provides some additional methods you can use for transaction management (<code>setRollbackOnly</code>, for example):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    @Resource
    private MessageDrivenContext mdc;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A message-driven bean never has a local or remote interface.
Instead, it has only a bean class.</p>
</div>
<div class="paragraph">
<p>A message-driven bean is similar in some ways to a stateless session bean: Its instances are relatively short-lived and retain no state for a specific client.
The instance variables of the message-driven bean instance can contain some state across the handling of client messages: for example, an open database connection, or an object reference to an enterprise bean object.</p>
</div>
<div class="paragraph">
<p>Like a stateless session bean, a message-driven bean can have many interchangeable instances running at the same time.
The container can pool these instances to allow streams of messages to be processed concurrently.
The container attempts to deliver messages in chronological order when that would not impair the concurrency of message processing, but no guarantees are made as to the exact order in which messages are delivered to the instances of the message-driven bean class.
If message order is essential to your application, you may want to configure your application server to use just one instance of the message-driven bean.</p>
</div>
<div class="paragraph">
<p>For details on the lifecycle of a message-driven bean, see <a href="../../entbeans/ejb-intro/ejb-intro.html#_the_lifecycle_of_a_message_driven_bean" class="xref page">The Lifecycle of a Message-Driven Bean</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_managing_jakarta_transactions"><a class="anchor" href="#_managing_jakarta_transactions"></a>Managing Jakarta Transactions</h3>
<div class="paragraph">
<p>Jakarta EE application clients and Java SE clients use JMS local transactions (described in <a href="#_using_jakarta_messaging_local_transactions">Using Jakarta Messaging Local Transactions</a>), which allow the grouping of sends and receives within a specific Messaging session.
Jakarta EE applications that run in the web or enterprise bean container commonly use Jakarta Transactions to ensure the integrity of accesses to external resources.
The key difference between a Jakarta transaction and a Jakarta Messaging local transaction is that a Jakarta transaction is controlled by the application server&#8217;s transaction managers.
Jakarta transactions may be distributed, which means that they can encompass multiple resources in the same transaction, such as a Messaging provider and a database.</p>
</div>
<div class="paragraph">
<p>For example, distributed transactions allow multiple applications to perform atomic updates on the same database, and they allow a single application to perform atomic updates on multiple databases.</p>
</div>
<div class="paragraph">
<p>In a Jakarta EE application that uses Jakarta Messaging, you can use transactions to combine message sends or receives with database updates and other resource manager operations.
You can access resources from multiple application components within a single transaction.
For example, a servlet can start a transaction, access multiple databases, invoke an enterprise bean that sends a Jakarta Messaging message, invoke another enterprise bean that modifies an EIS system using the Connectors, and finally commit the transaction.
Your application cannot, however, both send a Jakarta Messaging message and receive a reply to it within the same transaction.</p>
</div>
<div class="paragraph">
<p>Jakarta Transactions within the enterprise bean and web containers can be either of two kinds.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Container-managed transactions: The container controls the integrity of your transactions without your having to call <code>commit</code> or <code>rollback</code>.
Container-managed transactions are easier to use than bean-managed transactions.
You can specify appropriate transaction attributes for your enterprise bean methods.</p>
<div class="paragraph">
<p>Use the <code>Required</code> transaction attribute (the default) to ensure that a method is always part of a transaction.
If a transaction is in progress when the method is called, the method will be part of that transaction; if not, a new transaction will be started before the method is called and will be committed when the method returns.
See <a href="../../supporttechs/transactions/transactions.html#_transaction_attributes" class="xref page">Transaction Attributes</a> for more information.</p>
</div>
</li>
<li>
<p>Bean-managed transactions: You can use these in conjunction with the <code>jakarta.transaction.UserTransaction</code> interface, which provides its own <code>commit</code> and <code>rollback</code> methods you can use to delimit transaction boundaries.
Bean-managed transactions are recommended only for those who are experienced in programming transactions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can use either container-managed transactions or bean-managed transactions with message-driven beans.
To ensure that all messages are received and handled within the context of a transaction, use container-managed transactions and use the <code>Required</code> transaction attribute (the default) for the <code>onMessage</code> method.</p>
</div>
<div class="paragraph">
<p>When you use container-managed transactions, you can call the following <code>MessageDrivenContext</code> methods.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>setRollbackOnly</code>: Use this method for error handling.
If an exception occurs, <code>setRollbackOnly</code> marks the current transaction so that the only possible outcome of the transaction is a rollback.</p>
</li>
<li>
<p><code>getRollbackOnly</code>: Use this method to test whether the current transaction has been marked for rollback.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you use bean-managed transactions, the delivery of a message to the <code>onMessage</code> method takes place outside the Jakarta transaction context.
The transaction begins when you call the <code>UserTransaction.begin</code> method within the <code>onMessage</code> method, and it ends when you call <code>UserTransaction.commit</code> or <code>UserTransaction.rollback</code>.
Any call to the <code>Connection.createSession</code> method must take place within the transaction.</p>
</div>
<div class="paragraph">
<p>Using bean-managed transactions allows you to process the message by using more than one transaction or to have some parts of the message processing take place outside a transaction context.
However, if you use container-managed transactions, the message is received by the MDB and processed by the <code>onMessage</code> method within the same transaction.
It is not possible to achieve this behavior with bean-managed transactions.</p>
</div>
<div class="paragraph">
<p>When you create a <code>JMSContext</code> in a Jakarta transaction (in the web or enterprise bean container), the container ignores any arguments you specify, because it manages all transactional properties.
When you create a <code>JMSContext</code> in the web or enterprise bean container and there is no Jakarta transaction, the value (if any) passed to the <code>createContext</code> method should be <code>JMSContext.AUTO_ACKNOWLEDGE</code> or <code>JMSContext.DUPS_OK_ACKNOWLEDGE</code>.</p>
</div>
<div class="paragraph">
<p>When you use container-managed transactions, you normally use the <code>Required</code> transaction attribute (the default) for your enterprise bean&#8217;s business methods.</p>
</div>
<div class="paragraph">
<p>You do not specify the activation configuration property <code>acknowledgeMode</code> when you create a message-driven bean that uses container-managed transactions.
The container acknowledges the message automatically when it commits the transaction.</p>
</div>
<div class="paragraph">
<p>If a message-driven bean uses bean-managed transactions, the message receipt cannot be part of the bean-managed transaction.
You can set the activation configuration property <code>acknowledgeMode</code> to <code>Auto-acknowledge</code> or <code>Dups-ok-acknowledge</code> to specify how you want the message received by the message-driven bean to be acknowledged.</p>
</div>
<div class="paragraph">
<p>If the <code>onMessage</code> method throws a <code>RuntimeException</code>, the container does not acknowledge processing the message.
In that case, the Messaging provider will redeliver the unacknowledged message in the future.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_further_information_about_jakarta_messaging"><a class="anchor" href="#_further_information_about_jakarta_messaging"></a>Further Information about Jakarta Messaging</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For more information about Jakarta Messaging, see</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jakarta Messaging website:<br>
<a href="https://projects.eclipse.org/projects/ee4j.jms" class="bare" target="_blank" rel="noopener">https://projects.eclipse.org/projects/ee4j.jms</a></p>
</li>
<li>
<p>Jakarta Messaging specification, version 3.0, available from:<br>
<a href="https://jakarta.ee/specifications/messaging/3.0/" class="bare" target="_blank" rel="noopener">https://jakarta.ee/specifications/messaging/3.0/</a></p>
</li>
</ul>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../../../_/js/site.js" data-ui-root-path="../../../../_"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
