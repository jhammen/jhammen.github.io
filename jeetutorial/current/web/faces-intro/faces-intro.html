<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Jakarta Faces Technology :: Jakarta EE Documentation</title>
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <script>var uiRootPath = '../../../../_'</script>
    <script>!function (theme) {
        if (theme === 'dark') document.documentElement.classList.add('theme-dark')
      }(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)') && 'dark'))
    </script>
      </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a id="site-title" class="navbar-item" href="../../../..">Jakarta EE Documentation</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
<!--
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
 -->
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="../../../../jakartaee-tutorial/10/jakarta-ee-tutorial.pdf">Download</a>
          </span>
        </div>
      </div>
      <div class="navbar-theme-switcher">
        <span class="switch" title="Switch between Light and Dark Theme">
          <input id="theme-switcher-checkbox" type="checkbox" />
          <label for="theme-switcher-checkbox">Dark Theme</label>
        </span>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="jakartaee-tutorial" data-version="10">
  <div class="toolbar"></div>
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../index.html">Jakarta EE Tutorial</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Introduction</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../index.html">Preface</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../intro/overview/overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../intro/usingexamples/usingexamples.html">Using the Tutorial Examples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Core Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta CDI Lite</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-basic/cdi-basic.html">Introduction to Jakarta Contexts and Dependency Injection</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-basicexamples/cdi-basicexamples.html">Running the Basic Contexts and Dependency Injection Examples</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../supporttechs/interceptors/interceptors.html">Using Jakarta EE Interceptors</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta REST</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../websvcs/jaxrs/jaxrs.html">Building RESTful Web Services with Jakarta REST</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../websvcs/jaxrs-client/jaxrs-client.html">Accessing REST Resources with the Jakarta REST Client API</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../websvcs/jaxrs-advanced/jaxrs-advanced.html">Jakarta REST: Advanced Topics and an Example</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta JSON</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../jsonb/jsonb.html">JSON Binding</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../jsonp/jsonp.html">JSON Processing</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Web Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta CDI Full</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-adv/cdi-adv.html">Jakarta Contexts and Dependency Injection: Advanced Topics</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-bootstrap-se8/cdi-bootstrap-se8.html">Bootstrapping a CDI Container in Java SE</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-adv-examples/cdi-adv-examples.html">Running the Advanced Contexts and Dependency Injection Examples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Validation</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../beanvalidation/bean-validation/bean-validation.html">Introduction to Jakarta Bean Validation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../beanvalidation/bean-validation-advanced/bean-validation-advanced.html">Bean Validation: Advanced Topics</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../security/security.html">Jakarta Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Servlets</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../webapp/webapp.html">Getting Started with Web Applications</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlets/servlets.html">Jakarta Servlet Technology</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Faces</span>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="faces-intro.html">Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-facelets/faces-facelets.html">Introduction to Facelets</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-page/faces-page.html">Using Jakarta Faces Technology in Web Pages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-page-core/faces-page-core.html">Using Converters, Listeners, and Validators</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-develop/faces-develop.html">Developing with Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-ajax/faces-ajax.html">Using Ajax with Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-advanced-cc/faces-advanced-cc.html">Composite Components: Advanced Topics and an Example</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-custom/faces-custom.html">Creating Custom UI Components and Other Custom Objects</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-configure/faces-configure.html">Configuring Jakarta Faces Applications</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-ws/faces-ws.html">Using WebSockets with Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../webi18n/webi18n.html">Internationalizing and Localizing Web Applications</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../websocket/websocket.html">Jakarta WebSocket</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Persistence</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-intro/persistence-intro.html">Introduction to Jakarta Persistence</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-basicexamples/persistence-basicexamples.html">Running the Persistence Examples</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-querylanguage/persistence-querylanguage.html">The Jakarta Persistence Query Language</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-criteria/persistence-criteria.html">Using the Criteria API to Create Queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-string-queries/persistence-string-queries.html">Creating and Using String-Based Criteria Queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-locking/persistence-locking.html">Controlling Concurrent Access to Entity Data with Locking</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-entitygraphs/persistence-entitygraphs.html">Creating Fetch Plans with Entity Graphs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-cache/persistence-cache.html">Using a Second-Level Cache with Jakarta Persistence Applications</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Enterprise Beans Lite</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-intro/ejb-intro.html">Enterprise Beans</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-gettingstarted/ejb-gettingstarted.html">Getting Started with Enterprise Beans</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-basicexamples/ejb-basicexamples.html">Running the Enterprise Bean Examples</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-async/ejb-async.html">Using Asynchronous Method Invocation in Session Beans</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Platform</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../messaging/mail-api/mail-api.html">Jakarta Mail</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Messaging</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../messaging/jms-concepts/jms-concepts.html">Jakarta Messaging Concepts</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../messaging/jms-examples/jms-examples.html">Jakarta Messaging Examples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../supporttechs/batch-processing/batch-processing.html">Jakarta Batch</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Advanced</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Web Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../security/security-authentication/security-authentication.html">Jakarta Authentication</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../security/security-authorization/security-authorization.html">Jakarta Authorization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../supporttechs/transactions/transactions.html">Jakarta Transactions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../supporttechs/concurrency-utilities/concurrency-utilities.html">Jakarta Concurrency</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Platform</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../supporttechs/connectors/connectors.html">Jakarta Connectors</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Optional Components</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-el/faces-el.html">Jakarta Expression Language</a>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Jakarta XML Binding</span>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Archived</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Web Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../jakarta-pages/jakarta-pages.html">Jakarta Pages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../jakarta-tags/jakarta-tags.html">Jakarta Tags</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Platform</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../websvcs/xml-websvcs/xml-websvcs.html">XML Web Services</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-full/ejb-full.html">Jakarta Enterprise Beans Full</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Jakarta EE Tutorial</span>
    <span class="version">10</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../../index.html">Jakarta EE Tutorial</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../index.html">10</a>
        </li>
        <li class="version">
          <a href="../../../9.1/index.html">9.1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../index.html">Jakarta EE Tutorial</a></li>
    <li>Jakarta EE Web Profile</li>
    <li>Jakarta Faces</li>
    <li><a href="faces-intro.html">Jakarta Faces Technology</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">10</button>
  <div class="version-menu">
    <a class="version is-current" href="faces-intro.html">10</a>
    <a class="version" href="../../../9.1/web/faces-intro/faces-intro.html">9.1</a>
  </div>
</div>
  <div class="edit-this-page"><a href="file:///home/john/workspace/virtua/jakartaee-tutorial/src/main/antora/modules/web/pages/faces-intro/faces-intro.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Jakarta Faces Technology</h1>
<div id="preamble">
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We are working on a fresh, updated Jakarta EE Tutorial. This section hasn&#8217;t yet been updated.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Jakarta Faces technology is a server-side component framework for building Java technology–based web applications.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction_to_jakarta_faces_technology"><a class="anchor" href="#_introduction_to_jakarta_faces_technology"></a>Introduction to Jakarta Faces Technology</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jakarta Faces technology consists of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An API for representing components and managing their state; handling events, server-side validation, and data conversion; defining page navigation; supporting internationalization and accessibility; and providing extensibility for all these features</p>
</li>
<li>
<p>Tag libraries for adding components to web pages and for connecting components to server-side objects</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Jakarta Faces technology provides a well-defined programming model and various tag libraries.
The tag libraries contain tag handlers that implement the component tags.
These features significantly ease the burden of building and maintaining web applications with server-side user interfaces (UIs).
With minimal effort, you can complete the following tasks.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Create a web page.</p>
</li>
<li>
<p>Drop components onto a web page by adding component tags.</p>
</li>
<li>
<p>Bind components on a page to server-side data.</p>
</li>
<li>
<p>Wire component-generated events to server-side application code.</p>
</li>
<li>
<p>Save and restore application state beyond the life of server requests.</p>
</li>
<li>
<p>Reuse and extend components through customization.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This chapter provides an overview of Jakarta Faces technology.
After explaining what a Jakarta Faces application is and reviewing some of the primary benefits of using Jakarta Faces technology, this chapter describes the process of creating a simple Jakarta Faces application.
This chapter also introduces the Jakarta Faces lifecycle by describing the example Jakarta Faces application and its progression through the lifecycle stages.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_a_jakarta_faces_application"><a class="anchor" href="#_what_is_a_jakarta_faces_application"></a>What Is a Jakarta Faces Application?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The functionality provided by a Jakarta Faces application is similar to that of any other Java web application.
A typical Jakarta Faces application includes the following parts.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A set of web pages in which components are laid out.</p>
</li>
<li>
<p>A set of tags to add components to the web page.</p>
</li>
<li>
<p>A set of managed beans, which are lightweight, container-managed objects (POJOs).
In a Jakarta Faces application, managed beans serve as backing beans, which define properties and functions for UI components on a page.</p>
</li>
<li>
<p>A web deployment descriptor (<code>web.xml</code> file).</p>
</li>
<li>
<p>Optionally, one or more application configuration resource files, such as a <code>faces-config.xml</code> file, which can be used to define page navigation rules and configure beans and other custom objects, such as custom components.</p>
</li>
<li>
<p>Optionally, a set of custom objects, which can include custom components, validators, converters, or listeners, created by the application developer.</p>
</li>
<li>
<p>Optionally, a set of custom tags for representing custom objects on the page.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="#_responding_to_a_client_request_for_a_jakarta_faces_page">Figure 1, &#8220;Responding to a Client Request for a Jakarta Faces Page&#8221;</a> shows the interaction between client and server in a typical Jakarta Faces application.
In response to a client request, a web page is rendered by the web container that implements Jakarta Faces technology.</p>
</div>
<div id="_responding_to_a_client_request_for_a_jakarta_faces_page" class="imageblock">
<div class="content">
<img src="../../common/_images/jakartaeett_dt_014.svg" alt="Diagram that shows a browser accessing the myfacelet.xhtml page using an HTTP Request and the server sending the rendered HTML page using an HTTP Response.">
</div>
<div class="title">Figure 1. Responding to a Client Request for a Jakarta Faces Page</div>
</div>
<div class="paragraph">
<p>The web page, <code>myfacelet.xhtml</code>, is built using Jakarta Faces component tags.
Component tags are used to add components to the <code>view</code> (represented by <code>myView</code> in the diagram), which is the server-side representation of the page.
In addition to components, the web page can also reference objects, such as the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any event listeners, validators, and converters that are registered on the components</p>
</li>
<li>
<p>The JavaBeans components that capture the data and process the application-specific functionality of the components</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>On request from the client, the view is rendered as a response.
Rendering is the process whereby, based on the server-side view, the web container generates output, such as HTML or XHTML, that can be read by the client, such as a browser.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jakarta_faces_technology_benefits"><a class="anchor" href="#_jakarta_faces_technology_benefits"></a>Jakarta Faces Technology Benefits</h2>
<div class="sectionbody">
<div class="paragraph">
<p>One of the greatest advantages of Jakarta Faces technology is that it offers a clean separation between behavior and presentation for web applications.
A Jakarta Faces application can map HTTP requests to component-specific event handling and manage components as stateful objects on the server.
Jakarta Faces technology allows you to build web applications that implement the finer-grained separation of behavior and presentation that is traditionally offered by client-side UI architectures.</p>
</div>
<div class="paragraph">
<p>The separation of logic from presentation also allows each member of a web application development team to focus on a single piece of the development process and provides a simple programming model to link the pieces.
For example, page authors with no programming expertise can use Jakarta Faces technology tags in a web page to link to server-side objects without writing any scripts.</p>
</div>
<div class="paragraph">
<p>Another important goal of Jakarta Faces technology is to leverage familiar component and web-tier concepts without limiting you to a particular scripting technology or markup language.
Jakarta Faces technology APIs are layered directly on top of the Servlet API, as shown in <a href="#_web_application_technologies">Figure 2, &#8220;Web Application Technologies&#8221;</a>.</p>
</div>
<div id="_web_application_technologies" class="imageblock">
<div class="content">
<img src="../../common/_images/jakartaeett_dt_015.svg" alt="Diagram of web application technologies. Jakarta Server Pages, the server pages Standard Tag Library, and Jakarta Faces rest on Jakarta Servlet technology.">
</div>
<div class="title">Figure 2. Web Application Technologies</div>
</div>
<div class="paragraph">
<p>This layering of APIs enables several important application use cases, such as using different presentation technologies, creating your own custom components directly from the component classes, and generating output for various client devices.</p>
</div>
<div class="paragraph">
<p>Facelets technology, available as part of Jakarta Faces technology, is the preferred presentation technology for building Jakarta Faces technology–based web applications.
For more information on Facelets technology features, see <a href="../faces-facelets/faces-facelets.html#_introduction_to_facelets" class="xref page">Introduction to Facelets</a>.</p>
</div>
<div class="paragraph">
<p>Facelets technology offers several advantages.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Code can be reused and extended for components through the templating and composite component features.</p>
</li>
<li>
<p>You can use annotations to automatically register the managed bean as a resource available for Jakarta Faces applications.
In addition, implicit navigation rules allow developers to quickly configure page navigation (see <a href="#_navigation_model">Navigation Model</a> for details).
These features reduce the manual configuration process for applications.</p>
</li>
<li>
<p>Most important, Jakarta Faces technology provides a rich architecture for managing component state, processing component data, validating user input, and handling events.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_a_simple_jakarta_faces_application"><a class="anchor" href="#_a_simple_jakarta_faces_application"></a>A Simple Jakarta Faces Application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jakarta Faces technology provides an easy and user-friendly process for creating web applications.
Developing a simple Jakarta Faces application typically requires the following tasks, which have already been described in <a href="../webapp/webapp.html#_a_web_module_that_uses_jakarta_faces_technology_the_hello1_example" class="xref page">A Web Module That Uses Jakarta Faces Technology: The hello1 Example</a>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Creating web pages using component tags</p>
</li>
<li>
<p>Developing managed beans</p>
</li>
<li>
<p>Mapping the <code>FacesServlet</code> instance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>hello1</code> example includes a managed bean and two Facelets web pages.
When accessed by a client, the first web page asks the user for his or her name, and the second page responds by providing a greeting.</p>
</div>
<div class="paragraph">
<p>For details on Facelets technology, see <a href="../faces-facelets/faces-facelets.html#_introduction_to_facelets" class="xref page">Introduction to Facelets</a>.
For details on using EL expressions, see <a href="../faces-el/faces-el.html#_expression_language" class="xref page">Expression Language</a>.
For details on the Jakarta Faces programming model and building web pages using Jakarta Faces technology, see <a href="../faces-page/faces-page.html#_using_jakarta_faces_technology_in_web_pages" class="xref page">Using Jakarta Faces Technology in Web Pages</a>.</p>
</div>
<div class="paragraph">
<p>Every web application has a lifecycle.
Common tasks, such as handling incoming requests, decoding parameters, modifying and saving state, and rendering web pages to the browser, are all performed during a web application lifecycle.
Some web application frameworks hide the details of the lifecycle from you, whereas others require you to manage them manually.</p>
</div>
<div class="paragraph">
<p>By default, Jakarta Faces automatically handles most of the lifecycle actions for you.
However, it also exposes the various stages of the request lifecycle so that you can modify or perform different actions if your application requirements warrant it.</p>
</div>
<div class="paragraph">
<p>The lifecycle of a Jakarta Faces application starts and ends with the following activity: The client makes a request for the web page, and the server responds with the page.
The lifecycle consists of two main phases: Execute and Render.</p>
</div>
<div class="paragraph">
<p>During the Execute phase, several actions can take place.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The application view is built or restored.</p>
</li>
<li>
<p>The request parameter values are applied.</p>
</li>
<li>
<p>Conversions and validations are performed for component values.</p>
</li>
<li>
<p>Managed beans are updated with component values.</p>
</li>
<li>
<p>Application logic is invoked.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a first (initial) request, only the view is built.
For subsequent (postback) requests, some or all of the other actions can take place.</p>
</div>
<div class="paragraph">
<p>In the Render phase, the requested view is rendered as a response to the client.
Rendering is typically the process of generating output, such as HTML or XHTML, that can be read by the client, usually a browser.</p>
</div>
<div class="paragraph">
<p>The following short description of the example Jakarta Faces application passing through its lifecycle summarizes the activity that takes place behind the scenes.</p>
</div>
<div class="paragraph">
<p>The <code>hello1</code> example application goes through the following stages when it is deployed on GlassFish Server.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>When the <code>hello1</code> application is built and deployed on GlassFish Server, the application is in an uninitiated state.</p>
</li>
<li>
<p>When a client makes an initial request for the <code>index.xhtml</code> web page, the <code>hello1</code> Facelets application is compiled.</p>
</li>
<li>
<p>The compiled Facelets application is executed, and a new component tree is constructed for the <code>hello1</code> application and placed in a <code>FacesContext</code>.</p>
</li>
<li>
<p>The component tree is populated with the component and the managed bean property associated with it, represented by the EL expression <code>hello.name</code>.</p>
</li>
<li>
<p>A new view is built, based on the component tree.</p>
</li>
<li>
<p>The view is rendered to the requesting client as a response.</p>
</li>
<li>
<p>The component tree is destroyed automatically.</p>
</li>
<li>
<p>On subsequent (postback) requests, the component tree is rebuilt, and the saved state is applied.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For full details on the lifecycle, see <a href="#_the_lifecycle_of_a_jakarta_faces_application">The Lifecycle of a Jakarta Faces Application</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_interface_component_model"><a class="anchor" href="#_user_interface_component_model"></a>User Interface Component Model</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In addition to the lifecycle description, an overview of Jakarta Faces architecture provides better understanding of the technology.</p>
</div>
<div class="paragraph">
<p>Jakarta Faces components are the building blocks of a Jakarta Faces view.
A component can be a user interface (UI) component or a non-UI component.</p>
</div>
<div class="paragraph">
<p>Jakarta Faces UI components are configurable, reusable elements that compose the user interfaces of Jakarta Faces applications.
A component can be simple, such as a button, or can be compound, such as a table composed of multiple components.</p>
</div>
<div class="paragraph">
<p>Jakarta Faces technology provides a rich, flexible component architecture that includes the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A set of <code>jakarta.faces.component.UIComponent</code> classes for specifying the state and behavior of UI components</p>
</li>
<li>
<p>A rendering model that defines how to render the components in various ways</p>
</li>
<li>
<p>A conversion model that defines how to register data converters onto a component</p>
</li>
<li>
<p>An event and listener model that defines how to handle component events</p>
</li>
<li>
<p>A validation model that defines how to register validators onto a component</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This section briefly describes each of these pieces of the component architecture.</p>
</div>
<div class="sect2">
<h3 id="_user_interface_component_classes"><a class="anchor" href="#_user_interface_component_classes"></a>User Interface Component Classes</h3>
<div class="paragraph">
<p>Jakarta Faces technology provides a set of UI component classes and associated behavioral interfaces that specify all the UI component functionality, such as holding component state, maintaining a reference to objects, and driving event handling and rendering for a set of standard components.</p>
</div>
<div class="paragraph">
<p>The component classes are completely extensible, allowing component writers to create their own custom components.
See <a href="../faces-custom/faces-custom.html#_creating_custom_ui_components_and_other_custom_objects" class="xref page">Creating Custom UI Components and Other Custom Objects</a> for more information.</p>
</div>
<div class="paragraph">
<p>The abstract base class for all components is <code>jakarta.faces.component.UIComponent</code>.
Jakarta Faces UI component classes extend the <code>UIComponentBase</code> class (a subclass of <code>UIComponent</code>), which defines the default state and behavior of a component.
The following set of component classes is included with Jakarta Faces technology.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>UIColumn</code>: Represents a single column of data in a <code>UIData</code> component.</p>
</li>
<li>
<p><code>UICommand</code>: Represents a control that fires actions when activated.</p>
</li>
<li>
<p><code>UIData</code>: Represents a data binding to a collection of data represented by a <code>jakarta.faces.model.DataModel</code> instance.</p>
</li>
<li>
<p><code>UIForm</code>: Represents an input form to be presented to the user.
Its child components represent (among other things) the input fields to be included when the form is submitted.
This component is analogous to the <code>form</code> tag in HTML.</p>
</li>
<li>
<p><code>UIGraphic</code>: Displays an image.</p>
</li>
<li>
<p><code>UIInput</code>: Takes data input from a user.
This class is a subclass of <code>UIOutput</code>.</p>
</li>
<li>
<p><code>UIMessage</code>: Displays a localized error message.</p>
</li>
<li>
<p><code>UIMessages</code>: Displays a set of localized error messages.</p>
</li>
<li>
<p><code>UIOutcomeTarget</code>: Displays a link in the form of a link or a button.</p>
</li>
<li>
<p><code>UIOutput</code>: Displays data output on a page.</p>
</li>
<li>
<p><code>UIPanel</code>: Manages the layout of its child components.</p>
</li>
<li>
<p><code>UIParameter</code>: Represents substitution parameters.</p>
</li>
<li>
<p><code>UISelectBoolean</code>: Allows a user to set a <code>boolean</code> value on a control by selecting or deselecting it.
This class is a subclass of the <code>UIInput</code> class.</p>
</li>
<li>
<p><code>UISelectItem</code>: Represents a single item in a set of items.</p>
</li>
<li>
<p><code>UISelectItems</code>: Represents an entire set of items.</p>
</li>
<li>
<p><code>UISelectMany</code>: Allows a user to select multiple items from a group of items.
This class is a subclass of the <code>UIInput</code> class.</p>
</li>
<li>
<p><code>UISelectOne</code>: Allows a user to select one item from a group of items.
This class is a subclass of the <code>UIInput</code> class.</p>
</li>
<li>
<p><code>UIViewParameter</code>: Represents the query parameters in a request.
This class is a subclass of the <code>UIInput</code> class.</p>
</li>
<li>
<p><code>UIViewRoot</code>: Represents the root of the component tree.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In addition to extending <code>UIComponentBase</code>, the component classes also implement one or more behavioral interfaces, each of which defines certain behavior for a set of components whose classes implement the interface.</p>
</div>
<div class="paragraph">
<p>These behavioral interfaces, all defined in the <code>jakarta.faces.component</code> package unless otherwise stated, are as follows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ActionSource</code>: Indicates that the component can fire an action event.
This interface is intended for use with components based on JavaServer Faces technology 1.1_01 and earlier versions.
This interface is deprecated in JavaServer Faces 2.</p>
</li>
<li>
<p><code>ActionSource2</code>: Extends <code>ActionSource</code> and therefore provides the same functionality.
However, it allows components to use the Expression Language (EL) when they are referencing methods that handle action events.</p>
</li>
<li>
<p><code>EditableValueHolder</code>: Extends <code>ValueHolder</code> and specifies additional features for editable components, such as validation and emitting value-change events.</p>
</li>
<li>
<p><code>NamingContainer</code>: Mandates that each component rooted at this component have a unique ID.</p>
</li>
<li>
<p><code>StateHolder</code>: Denotes that a component has state that must be saved between requests.</p>
</li>
<li>
<p><code>ValueHolder</code>: Indicates that the component maintains a local value as well as the option of accessing data in the model tier.</p>
</li>
<li>
<p><code>jakarta.faces.event.SystemEventListenerHolder</code>: Maintains a list of <code>jakarta.faces.event.SystemEventListener</code> instances for each type of <code>jakarta.faces.event.SystemEvent</code> defined by that class.</p>
</li>
<li>
<p><code>jakarta.faces.component.behavior.ClientBehaviorHolder</code>: Adds the ability to attach <code>jakarta.faces.component.behavior.ClientBehavior</code> instances, such as a reusable script.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>UICommand</code> implements <code>ActionSource2</code> and <code>StateHolder</code>.
<code>UIOutput</code> and component classes that extend <code>UIOutput</code> implement <code>StateHolder</code> and <code>ValueHolder</code>.
<code>UIInput</code> and component classes that extend <code>UIInput</code> implement <code>EditableValueHolder</code>, <code>StateHolder</code>, and <code>ValueHolder</code>.
<code>UIComponentBase</code> implements <code>StateHolder</code>.</p>
</div>
<div class="paragraph">
<p>Only component writers will need to use the component classes and behavioral interfaces directly.
Page authors and application developers will use a standard component by including a tag that represents it on a page.
Most of the components can be rendered in different ways on a page.
For example, a <code>UICommand</code> component can be rendered as a button or a link.</p>
</div>
<div class="paragraph">
<p>The next section explains how the rendering model works and how page authors can choose to render the components by selecting the appropriate tags.</p>
</div>
</div>
<div class="sect2">
<h3 id="_component_rendering_model"><a class="anchor" href="#_component_rendering_model"></a>Component Rendering Model</h3>
<div class="paragraph">
<p>The Jakarta Faces component architecture is designed such that the functionality of the components is defined by the component classes, whereas the component rendering can be defined by a separate renderer class.
This design has several benefits, including the following.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Component writers can define the behavior of a component once but create multiple renderers, each of which defines a different way to render the component to the same client or to different clients.</p>
</li>
<li>
<p>Page authors and application developers can change the appearance of a component on the page by selecting the tag that represents the appropriate combination of component and renderer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A render kit defines how component classes map to component tags that are appropriate for a particular client.
The Jakarta Faces implementation includes a standard HTML render kit for rendering to an HTML client.</p>
</div>
<div class="paragraph">
<p>The render kit defines a set of <code>jakarta.faces.render.Renderer</code> classes for each component that it supports.
Each <code>Renderer</code> class defines a different way to render the particular component to the output defined by the render kit.
For example, a <code>UISelectOne</code> component has three different renderers.
One of them renders the component as a group of options.
Another renders the component as a combo box.
The third one renders the component as a list box.
Similarly, a <code>UICommand</code> component can be rendered as a button or a link, using the <code>h:commandButton</code> or <code>h:commandLink</code> tag.
The <code>command</code> part of each tag corresponds to the <code>UICommand</code> class, specifying the functionality, which is to fire an action.
The <code>Button</code> or <code>Link</code> part of each tag corresponds to a separate <code>Renderer</code> class that defines how the component appears on the page.</p>
</div>
<div class="paragraph">
<p>Each custom tag defined in the standard HTML render kit is composed of the component functionality (defined in the <code>UIComponent</code> class) and the rendering attributes (defined by the <code>Renderer</code> class).</p>
</div>
<div class="paragraph">
<p>The section <a href="../faces-page/faces-page.html#_adding_components_to_a_page_using_html_tag_library_tags" class="xref page">Adding Components to a Page Using HTML Tag Library Tags</a> lists all supported component tags and illustrates how to use the tags in an example.</p>
</div>
<div class="paragraph">
<p>The Jakarta Faces implementation provides a custom tag library for rendering components in HTML.</p>
</div>
</div>
<div class="sect2">
<h3 id="_conversion_model"><a class="anchor" href="#_conversion_model"></a>Conversion Model</h3>
<div class="paragraph">
<p>A Jakarta Faces application can optionally associate a component with server-side object data.
This object is a JavaBeans component, such as a managed bean.
An application gets and sets the object data for a component by calling the appropriate object properties for that component.</p>
</div>
<div class="paragraph">
<p>When a component is bound to an object, the application has two views of the component&#8217;s data.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The model view, in which data is represented as data types, such as <code>int</code> or <code>long</code>.</p>
</li>
<li>
<p>The presentation view, in which data is represented in a manner that can be read or modified by the user.
For example, a <code>java.util.Date</code> might be represented as a text string in the format <code>mm/dd/yy</code> or as a set of three text strings.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Jakarta Faces implementation automatically converts component data between these two views when the bean property associated with the component is of one of the types supported by the component&#8217;s data.
For example, if a <code>UISelectBoolean</code> component is associated with a bean property of type <code>java.lang.Boolean</code>, the Jakarta Faces implementation will automatically convert the component&#8217;s data from <code>String</code> to <code>Boolean</code>.
In addition, some component data must be bound to properties of a particular type.
For example, a <code>UISelectBoolean</code> component must be bound to a property of type <code>boolean</code> or <code>java.lang.Boolean</code>.</p>
</div>
<div class="paragraph">
<p>Sometimes you might want to convert a component&#8217;s data to a type other than a standard type, or you might want to convert the format of the data.
To facilitate this, Jakarta Faces technology allows you to register a <code>jakarta.faces.convert.Converter</code> implementation on <code>UIOutput</code> components and components whose classes subclass <code>UIOutput</code>.
If you register the <code>Converter</code> implementation on a component, the <code>Converter</code> implementation converts the component&#8217;s data between the two views.</p>
</div>
<div class="paragraph">
<p>You can either use the standard converters supplied with the Jakarta Faces implementation or create your own custom converter.
Custom converter creation is covered in <a href="../faces-custom/faces-custom.html#_creating_custom_ui_components_and_other_custom_objects" class="xref page">Creating Custom UI Components and Other Custom Objects</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_event_and_listener_model"><a class="anchor" href="#_event_and_listener_model"></a>Event and Listener Model</h3>
<div class="paragraph">
<p>The Jakarta Faces event and listener model is similar to the JavaBeans event model in that it has strongly typed event classes and listener interfaces that an application can use to handle events generated by components.</p>
</div>
<div class="paragraph">
<p>The Jakarta Faces specification defines three types of events: application events, system events, and data-model events.</p>
</div>
<div class="paragraph">
<p>Application events are tied to a particular application and are generated by a <code>UIComponent</code>.
They represent the standard events available in previous versions of Jakarta Faces technology.</p>
</div>
<div class="paragraph">
<p>An event object identifies the component that generated the event and stores information about the event.
To be notified of an event, an application must provide an implementation of the listener class and must register it on the component that generates the event.
When the user activates a component, such as by clicking a button, an event is fired.
This causes the Jakarta Faces implementation to invoke the listener method that processes the event.</p>
</div>
<div class="paragraph">
<p>Jakarta Faces supports two kinds of application events: action events and value-change events.</p>
</div>
<div class="paragraph">
<p>An action event (class <code>jakarta.faces.event.ActionEvent</code>) occurs when the user activates a component that implements <code>ActionSource</code>.
These components include buttons and links.</p>
</div>
<div class="paragraph">
<p>A value-change event (class <code>jakarta.faces.event.ValueChangeEvent</code>) occurs when the user changes the value of a component represented by <code>UIInput</code> or one of its subclasses.
An example is selecting a check box, an action that results in the component&#8217;s value changing to <code>true</code>.
The component types that can generate these types of events are the <code>UIInput</code>, <code>UISelectOne</code>, <code>UISelectMany</code>, and <code>UISelectBoolean</code> components.
Value-change events are fired only if no validation errors are detected.</p>
</div>
<div class="paragraph">
<p>Depending on the value of the <code>immediate</code> property (see <a href="../faces-page/faces-page.html#_the_immediate_attribute" class="xref page">The immediate Attribute</a>) of the component emitting the event, action events can be processed during the Invoke Application phase or the Apply Request Values phase, and value-change events can be processed during the Process Validations phase or the Apply Request Values phase.</p>
</div>
<div class="paragraph">
<p>System events are generated by an <code>Object</code> rather than a <code>UIComponent</code>.
They are generated during the execution of an application at predefined times.
They are applicable to the entire application rather than to a specific component.</p>
</div>
<div class="paragraph">
<p>A data-model event occurs when a new row of a <code>UIData</code> component is selected.</p>
</div>
<div class="paragraph">
<p>There are two ways to cause your application to react to action events or value-change events that are emitted by a standard component:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Implement an event listener class to handle the event, and register the listener on the component by nesting either an <code>f:valueChangeListener</code> tag or an <code>f:actionListener</code> tag inside the component tag.</p>
</li>
<li>
<p>Implement a method of a managed bean to handle the event, and refer to the method with a method expression from the appropriate attribute of the component&#8217;s tag.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See <a href="../faces-custom/faces-custom.html#_implementing_an_event_listener" class="xref page">Implementing an Event Listener</a> for information on how to implement an event listener.
See <a href="../faces-page-core/faces-page-core.html#_registering_listeners_on_components" class="xref page">Registering Listeners on Components</a> for information on how to register the listener on a component.</p>
</div>
<div class="paragraph">
<p>See <a href="../faces-develop/faces-develop.html#_writing_a_method_to_handle_an_action_event" class="xref page">Writing a Method to Handle an Action Event</a> and <a href="../faces-develop/faces-develop.html#_writing_a_method_to_handle_a_value_change_event" class="xref page">Writing a Method to Handle a Value-Change Event</a> for information on how to implement managed bean methods that handle these events.</p>
</div>
<div class="paragraph">
<p>See <a href="../faces-page-core/faces-page-core.html#_referencing_a_managed_bean_method" class="xref page">Referencing a Managed Bean Method</a> for information on how to refer to the managed bean method from the component tag.</p>
</div>
<div class="paragraph">
<p>When emitting events from custom components, you must implement the appropriate event class and manually queue the event on the component in addition to implementing an event listener class or a managed bean method that handles the event.
<a href="../faces-custom/faces-custom.html#_handling_events_for_custom_components" class="xref page">Handling Events for Custom Components</a> explains how to do this.</p>
</div>
</div>
<div class="sect2">
<h3 id="_validation_model"><a class="anchor" href="#_validation_model"></a>Validation Model</h3>
<div class="paragraph">
<p>Jakarta Faces technology supports a mechanism for validating the local data of editable components (such as text fields).
This validation occurs before the corresponding model data is updated to match the local value.</p>
</div>
<div class="paragraph">
<p>Like the conversion model, the validation model defines a set of standard classes for performing common data validation checks.
The Jakarta Faces core tag library also defines a set of tags that correspond to the standard <code>jakarta.faces.validator.Validator</code> implementations.
See <a href="../faces-page-core/faces-page-core.html#_using_the_standard_validators" class="xref page">Using the Standard Validators</a> for a list of all the standard validation classes and corresponding tags.</p>
</div>
<div class="paragraph">
<p>Most of the tags have a set of attributes for configuring the validator&#8217;s properties, such as the minimum and maximum allowable values for the component&#8217;s data.
The page author registers the validator on a component by nesting the validator&#8217;s tag within the component&#8217;s tag.</p>
</div>
<div class="paragraph">
<p>In addition to validators that are registered on the component, you can declare a default validator that is registered on all <code>UIInput</code> components in the application.
For more information on default validators, see <a href="../faces-configure/faces-configure.html#_using_default_validators" class="xref page">Using Default Validators</a>.</p>
</div>
<div class="paragraph">
<p>The validation model also allows you to create your own custom validator and corresponding tag to perform custom validation.
The validation model provides two ways to implement custom validation.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Implement a <code>Validator</code> interface that performs the validation.</p>
</li>
<li>
<p>Implement a managed bean method that performs the validation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you are implementing a <code>Validator</code> interface, you must also do the following.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Register the <code>Validator</code> implementation with the application.</p>
</li>
<li>
<p>Create a custom tag or use an <code>f:validator</code> tag to register the validator on the component.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the previously described standard validation model, the validator is defined for each input component on a page.
The Bean Validation model allows the validator to be applied to all fields in a page.
See <a href="../../beanvalidation/bean-validation/bean-validation.html#_introduction_to_jakarta_bean_validation" class="xref page">Introduction to Jakarta Bean Validation</a> and <a href="../../beanvalidation/bean-validation-advanced/bean-validation-advanced.html#_bean_validation_advanced_topics" class="xref page">Bean Validation: Advanced Topics</a> for more information on Bean Validation.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_navigation_model"><a class="anchor" href="#_navigation_model"></a>Navigation Model</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Jakarta Faces navigation model makes it easy to define page navigation and to handle any additional processing that is needed to choose the sequence in which pages are loaded.</p>
</div>
<div class="paragraph">
<p>In Jakarta Faces technology, navigation is a set of rules for choosing the next page or view to be displayed after an application action, such as when a button or link is clicked.</p>
</div>
<div class="paragraph">
<p>Navigation can be implicit or user-defined.
Implicit navigation comes into play when user-defined navigation rules are not configured in the application configuration resource files.</p>
</div>
<div class="paragraph">
<p>When you add a component such as a <code>commandButton</code> to a Facelets page, and assign another page as the value for its <code>action</code> property, the default navigation handler will try to match a suitable page within the application implicitly.
In the following example, the default navigation handler will try to locate a page named <code>response.xhtml</code> within the application and navigate to it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;h:commandButton value="submit" action="response"&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>User-defined navigation rules are declared in zero or more application configuration resource files, such as <code>faces-config.xml</code>, by using a set of XML elements.
The default structure of a navigation rule is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;navigation-rule&gt;
    &lt;description&gt;&lt;/description&gt;
    &lt;from-view-id&gt;&lt;/from-view-id&gt;
    &lt;navigation-case&gt;
        &lt;from-action&gt;&lt;/from-action&gt;
        &lt;from-outcome&gt;&lt;/from-outcome&gt;
        &lt;if&gt;&lt;/if&gt;
        &lt;to-view-id&gt;&lt;/to-view-id&gt;
    &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>User-defined navigation is handled as follows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Define the rules in the application configuration resource file.</p>
</li>
<li>
<p>Refer to an outcome <code>String</code> from the button or link component&#8217;s <code>action</code> attribute.
This outcome <code>String</code> is used by the Jakarta Faces implementation to select the navigation rule.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is an example navigation rule:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;navigation-rule&gt;
    &lt;from-view-id&gt;/greeting.xhtml&lt;/from-view-id&gt;
    &lt;navigation-case&gt;
        &lt;from-outcome&gt;success&lt;/from-outcome&gt;
        &lt;to-view-id&gt;/response.xhtml&lt;/to-view-id&gt;
    &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule states that when a command component (such as an <code>h:commandButton</code> or an <code>h:commandLink</code>) on <code>greeting.xhtml</code> is activated, the application will navigate from the <code>greeting.xhtml</code> page to the <code>response.xhtml</code> page if the outcome referenced by the button component&#8217;s tag is <code>success</code>.
Here is an <code>h:commandButton</code> tag from <code>greeting.xhtml</code> that would specify a logical outcome of <code>success</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;h:commandButton id="submit" value="Submit" action="success"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the example demonstrates, each <code>navigation-rule</code> element defines how to get from one page (specified in the <code>from-view-id</code> element) to the other pages of the application.
The <code>navigation-rule</code> elements can contain any number of <code>navigation-case</code> elements, each of which defines the page to open next (defined by <code>to-view-id</code>) based on a logical outcome (defined by <code>from-outcome</code>).</p>
</div>
<div class="paragraph">
<p>In more complicated applications, the logical outcome can also come from the return value of an action method in a managed bean.
This method performs some processing to determine the outcome.
For example, the method can check whether the password the user entered on the page matches the one on file.
If it does, the method might return <code>success</code>; otherwise, it might return <code>failure</code>.
An outcome of <code>failure</code> might result in the logon page being reloaded.
An outcome of <code>success</code> might cause the page displaying the user&#8217;s credit card activity to open.
If you want the outcome to be returned by a method on a bean, you must refer to the method using a method expression with the <code>action</code> attribute, as shown by this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;h:commandButton id="submit" value="Submit"
                 action="#{cashierBean.submit}" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the user clicks the button represented by this tag, the corresponding component generates an action event.
This event is handled by the default <code>jakarta.faces.event.ActionListener</code> instance, which calls the action method referenced by the component that triggered the event.
The action method returns a logical outcome to the action listener.</p>
</div>
<div class="paragraph">
<p>The listener passes the logical outcome and a reference to the action method that produced the outcome to the default <code>jakarta.faces.application.NavigationHandler</code>.
The <code>NavigationHandler</code> selects the page to display next by matching the outcome or the action method reference against the navigation rules in the application configuration resource file by the following process.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The <code>NavigationHandler</code> selects the navigation rule that matches the page currently displayed.</p>
</li>
<li>
<p>It matches the outcome or the action method reference that it received from the default <code>jakarta.faces.event.ActionListener</code> with those defined by the navigation cases.</p>
</li>
<li>
<p>It tries to match both the method reference and the outcome against the same navigation case.</p>
</li>
<li>
<p>If the previous step fails, the navigation handler attempts to match the outcome.</p>
</li>
<li>
<p>Finally, the navigation handler attempts to match the action method reference if the previous two attempts failed.</p>
</li>
<li>
<p>If no navigation case is matched, it displays the same view again.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When the <code>NavigationHandler</code> achieves a match, the Render Response phase begins.
During this phase, the page selected by the <code>NavigationHandler</code> will be rendered.</p>
</div>
<div class="paragraph">
<p>The Duke&#8217;s Tutoring case study example application uses navigation rules in the business methods that handle creating, editing, and deleting the users of the application.
For example, the form for creating a student has the following <code>h:commandButton</code> tag:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;h:commandButton id="submit"
        action="#{adminBean.createStudent(studentManager.newStudent)}"
        value="#{bundle['action.submit']}"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The action event calls the <code>dukestutoring.ejb.AdminBean.createStudent</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public String createStudent(Student student) {
    em.persist(student);
    return "createdStudent";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The return value of <code>createdStudent</code> has a corresponding navigation case in the <code>faces-config.xml</code> configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;navigation-rule&gt;
    &lt;from-view-id&gt;/admin/student/createStudent.xhtml&lt;/from-view-id&gt;
    &lt;navigation-case&gt;
        &lt;from-outcome&gt;createdStudent&lt;/from-outcome&gt;
        &lt;to-view-id&gt;/admin/index.xhtml&lt;/to-view-id&gt;
    &lt;/navigation-case&gt;
&lt;/navigation-rule&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>After the student is created, the user is returned to the Administration index page.</p>
</div>
<div class="paragraph">
<p>For more information on how to define navigation rules, see <a href="../faces-configure/faces-configure.html#_configuring_navigation_rules" class="xref page">Configuring Navigation Rules</a>.</p>
</div>
<div class="paragraph">
<p>For more information on how to implement action methods to handle navigation, see <a href="../faces-develop/faces-develop.html#_writing_a_method_to_handle_an_action_event" class="xref page">Writing a Method to Handle an Action Event</a>.</p>
</div>
<div class="paragraph">
<p>For more information on how to reference outcomes or action methods from component tags, see <a href="../faces-page-core/faces-page-core.html#_referencing_a_method_that_performs_navigation" class="xref page">Referencing a Method That Performs Navigation</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_lifecycle_of_a_jakarta_faces_application"><a class="anchor" href="#_the_lifecycle_of_a_jakarta_faces_application"></a>The Lifecycle of a Jakarta Faces Application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The lifecycle of an application refers to the various stages of processing of that application, from its initiation to its conclusion.
All applications have lifecycles.
During a web application lifecycle, common tasks are performed, including the following.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Handling incoming requests</p>
</li>
<li>
<p>Decoding parameters</p>
</li>
<li>
<p>Modifying and saving state</p>
</li>
<li>
<p>Rendering web pages to the browser</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Jakarta Faces web application framework manages lifecycle phases automatically for simple applications or allows you to manage them manually for more complex applications as required.</p>
</div>
<div class="paragraph">
<p>Jakarta Faces applications that use advanced features may require interaction with the lifecycle at certain phases.
For example, Ajax applications use partial processing features of the lifecycle (see <a href="#_partial_processing_and_partial_rendering">Partial Processing and Partial Rendering</a>).
A clearer understanding of the lifecycle phases is key to creating well-designed components.</p>
</div>
<div class="paragraph">
<p>A simplified view of the Jakarta Faces lifecycle, consisting of the two main phases of a Jakarta Faces web application, is introduced in <a href="#_a_simple_jakarta_faces_application">A Simple Jakarta Faces Application</a>.
This section examines the Jakarta Faces lifecycle in more detail.</p>
</div>
<div class="sect2">
<h3 id="_overview_of_the_jakarta_faces_lifecycle"><a class="anchor" href="#_overview_of_the_jakarta_faces_lifecycle"></a>Overview of the Jakarta Faces Lifecycle</h3>
<div class="paragraph">
<p>The lifecycle of a Jakarta Faces application begins when the client makes an HTTP request for a page and ends when the server responds with the page, translated to HTML.</p>
</div>
<div class="paragraph">
<p>The lifecycle can be divided into two main phases: Execute and Render.
The Execute phase is further divided into subphases to support the sophisticated component tree.
This structure requires that component data be converted and validated, component events be handled, and component data be propagated to beans in an orderly fashion.</p>
</div>
<div class="paragraph">
<p>A Jakarta Faces page is represented by a tree of components, called a view.
During the lifecycle, the Jakarta Faces implementation must build the view while considering the state saved from a previous submission of the page.
When the client requests a page, the Jakarta Faces implementation performs several tasks, such as validating the data input of components in the view and converting input data to types specified on the server side.</p>
</div>
<div class="paragraph">
<p>The Jakarta Faces implementation performs all these tasks as a series of steps in the Jakarta Faces request-response lifecycle.
<a href="#_jakarta_faces_standard_request_response_lifecycle">Figure 3, &#8220;Jakarta Faces Standard Request-Response Lifecycle&#8221;</a> illustrates these steps.</p>
</div>
<div id="_jakarta_faces_standard_request_response_lifecycle" class="imageblock">
<div class="content">
<img src="../../common/_images/jakartaeett_dt_016.svg" alt="Flow diagram of Faces request and Faces response, including event and validation processing, error handling, model updating, application invocation.">
</div>
<div class="title">Figure 3. Jakarta Faces Standard Request-Response Lifecycle</div>
</div>
<div class="paragraph">
<p>The request-response lifecycle handles two kinds of requests: initial requests and postbacks.
An initial request occurs when a user makes a request for a page for the first time.
A postback request occurs when a user submits the form contained on a page that was previously loaded into the browser as a result of executing an initial request.</p>
</div>
<div class="paragraph">
<p>When the lifecycle handles an initial request, it executes only the Restore View and Render Response phases, because there is no user input or action to process.
Conversely, when the lifecycle handles a postback, it executes all of the phases.</p>
</div>
<div class="paragraph">
<p>Usually, the first request for a Jakarta Faces page comes in from a client, as a result of clicking a link or button component on a Jakarta Faces page.
To render a response that is another Jakarta Faces page, the application creates a new view and stores it in the <code>jakarta.faces.context.FacesContext</code> instance, which represents all of the information associated with processing an incoming request and creating a response.
The application then acquires object references needed by the view and calls the <code>FacesContext.renderResponse</code> method, which forces immediate rendering of the view by skipping to the <a href="#_render_response_phase">Render Response Phase</a> of the lifecycle, as is shown by the arrows labelled Render Response in <a href="#_jakarta_faces_standard_request_response_lifecycle">Figure 3, &#8220;Jakarta Faces Standard Request-Response Lifecycle&#8221;</a>.</p>
</div>
<div class="paragraph">
<p>Sometimes, an application might need to redirect to a different web application resource, such as a web service, or generate a response that does not contain Jakarta Faces components.
In these situations, the developer must skip the Render Response phase by calling the <code>FacesContext.responseComplete</code> method.
This situation is also shown in , with the arrows labelled Response Complete.</p>
</div>
<div class="paragraph">
<p>The most common situation is that a Jakarta Faces component submits a request for another Jakarta Faces page.
In this case, the Jakarta Faces implementation handles the request and automatically goes through the phases in the lifecycle to perform any necessary conversions, validations, and model updates and to generate the response.</p>
</div>
<div class="paragraph">
<p>There is one exception to the lifecycle described in this section.
When a component&#8217;s <code>immediate</code> attribute is set to <code>true</code>, the validation, conversion, and events associated with these components are processed during the <a href="#_apply_request_values_phase">Apply Request Values Phase</a> rather than in a later phase.</p>
</div>
<div class="paragraph">
<p>The details of the lifecycle explained in the following sections are primarily intended for developers who need to know information such as when validations, conversions, and events are usually handled and ways to change how and when they are handled.
For more information on each of the lifecycle phases, download the latest Jakarta Faces Specification documentation from <a href="https://jakarta.ee/specifications/faces/" class="bare" target="_blank" rel="noopener">https://jakarta.ee/specifications/faces/</a>.</p>
</div>
<div class="paragraph">
<p>The Jakarta Faces application lifecycle Execute phase contains the following subphases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#_restore_view_phase">Restore View Phase</a></p>
</li>
<li>
<p><a href="#_apply_request_values_phase">Apply Request Values Phase</a></p>
</li>
<li>
<p><a href="#_process_validations_phase">Process Validations Phase</a></p>
</li>
<li>
<p><a href="#_update_model_values_phase">Update Model Values Phase</a></p>
</li>
<li>
<p><a href="#_invoke_application_phase">Invoke Application Phase</a></p>
</li>
<li>
<p><a href="#_render_response_phase">Render Response Phase</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_restore_view_phase"><a class="anchor" href="#_restore_view_phase"></a>Restore View Phase</h3>
<div class="paragraph">
<p>When a request for a Jakarta Faces page is made, usually by an action, such as when a link or a button component is clicked, the Jakarta Faces implementation begins the Restore View phase.</p>
</div>
<div class="paragraph">
<p>During this phase, the Jakarta Faces implementation builds the view of the page, wires event handlers and validators to components in the view, and saves the view in the <code>FacesContext</code> instance, which contains all the information needed to process a single request.
All the application&#8217;s components, event handlers, converters, and validators have access to the <code>FacesContext</code> instance.</p>
</div>
<div class="paragraph">
<p>If the request for the page is an initial request, the Jakarta Faces implementation creates an empty view during this phase and the lifecycle advances to the Render Response phase, during which the empty view is populated with the components referenced by the tags in the page.</p>
</div>
<div class="paragraph">
<p>If the request for the page is a postback, a view corresponding to this page already exists in the <code>FacesContext</code> instance.
During this phase, the Jakarta Faces implementation restores the view by using the state information saved on the client or the server.</p>
</div>
</div>
<div class="sect2">
<h3 id="_apply_request_values_phase"><a class="anchor" href="#_apply_request_values_phase"></a>Apply Request Values Phase</h3>
<div class="paragraph">
<p>After the component tree is restored during a postback request, each component in the tree extracts its new value from the request parameters by using its <code>decode</code> (<code>processDecodes()</code>) method.
The value is then stored locally on each component.</p>
</div>
<div class="paragraph">
<p>If any <code>decode</code> methods or event listeners have called the <code>renderResponse</code> method on the current <code>FacesContext</code> instance, the Jakarta Faces implementation skips to the Render Response phase.</p>
</div>
<div class="paragraph">
<p>If any events have been queued during this phase, the Jakarta Faces implementation broadcasts the events to interested listeners.</p>
</div>
<div class="paragraph">
<p>If some components on the page have their <code>immediate</code> attributes (see <a href="../faces-page/faces-page.html#_the_immediate_attribute" class="xref page">The immediate Attribute</a>) set to <code>true</code>, then the validations, conversions, and events associated with these components will be processed during this phase.
If any conversion fails, an error message associated with the component is generated and queued on <code>FacesContext</code>.
This message will be displayed during the Render Response phase, along with any validation errors resulting from the Process Validations phase.</p>
</div>
<div class="paragraph">
<p>At this point, if the application needs to redirect to a different web application resource or generate a response that does not contain any Jakarta Faces components, it can call the <code>FacesContext.responseComplete</code> method.</p>
</div>
<div class="paragraph">
<p>At the end of this phase, the components are set to their new values, and messages and events have been queued.</p>
</div>
<div class="paragraph">
<p>If the current request is identified as a partial request, the partial context is retrieved from the <code>FacesContext</code>, and the partial processing method is applied.</p>
</div>
</div>
<div class="sect2">
<h3 id="_process_validations_phase"><a class="anchor" href="#_process_validations_phase"></a>Process Validations Phase</h3>
<div class="paragraph">
<p>During this phase, the Jakarta Faces implementation processes all validators registered on the components in the tree by using its <code>validate</code> (<code>processValidators</code>) method.
It examines the component attributes that specify the rules for the validation and compares these rules to the local value stored for the component.
The Jakarta Faces implementation also completes conversions for input components that do not have the <code>immediate</code> attribute set to true.</p>
</div>
<div class="paragraph">
<p>If the local value is invalid, or if any conversion fails, the Jakarta Faces implementation adds an error message to the <code>FacesContext</code> instance, and the lifecycle advances directly to the Render Response phase so that the page is rendered again with the error messages displayed.
If there were conversion errors from the Apply Request Values phase, the messages for these errors are also displayed.</p>
</div>
<div class="paragraph">
<p>If any <code>validate</code> methods or event listeners have called the <code>renderResponse</code> method on the current <code>FacesContext</code>, the Jakarta Faces implementation skips to the Render Response phase.</p>
</div>
<div class="paragraph">
<p>At this point, if the application needs to redirect to a different web application resource or generate a response that does not contain any Jakarta Faces components, it can call the <code>FacesContext.responseComplete</code> method.</p>
</div>
<div class="paragraph">
<p>If events have been queued during this phase, the Jakarta Faces implementation broadcasts them to interested listeners.</p>
</div>
<div class="paragraph">
<p>If the current request is identified as a partial request, the partial context is retrieved from the <code>FacesContext</code>, and the partial processing method is applied.</p>
</div>
</div>
<div class="sect2">
<h3 id="_update_model_values_phase"><a class="anchor" href="#_update_model_values_phase"></a>Update Model Values Phase</h3>
<div class="paragraph">
<p>After the Jakarta Faces implementation determines that the data is valid, it traverses the component tree and sets the corresponding server-side object properties to the components' local values.
The Jakarta Faces implementation updates only the bean properties pointed at by an input component&#8217;s <code>value</code> attribute.
If the local data cannot be converted to the types specified by the bean properties, the lifecycle advances directly to the Render Response phase so that the page is re-rendered with errors displayed.
This is similar to what happens with validation errors.</p>
</div>
<div class="paragraph">
<p>If any <code>updateModels</code> methods or any listeners have called the <code>renderResponse</code> method on the current <code>FacesContext</code> instance, the Jakarta Faces implementation skips to the Render Response phase.</p>
</div>
<div class="paragraph">
<p>At this point, if the application needs to redirect to a different web application resource or generate a response that does not contain any Jakarta Faces components, it can call the <code>FacesContext.responseComplete</code> method.</p>
</div>
<div class="paragraph">
<p>If any events have been queued during this phase, the Jakarta Faces implementation broadcasts them to interested listeners.</p>
</div>
<div class="paragraph">
<p>If the current request is identified as a partial request, the partial context is retrieved from the <code>FacesContext</code>, and the partial processing method is applied.</p>
</div>
</div>
<div class="sect2">
<h3 id="_invoke_application_phase"><a class="anchor" href="#_invoke_application_phase"></a>Invoke Application Phase</h3>
<div class="paragraph">
<p>During this phase, the Jakarta Faces implementation handles any application-level events, such as submitting a form or linking to another page.</p>
</div>
<div class="paragraph">
<p>At this point, if the application needs to redirect to a different web application resource or generate a response that does not contain any Jakarta Faces components, it can call the <code>FacesContext.responseComplete</code> method.</p>
</div>
<div class="paragraph">
<p>If the view being processed was reconstructed from state information from a previous request and if a component has fired an event, these events are broadcast to interested listeners.</p>
</div>
<div class="paragraph">
<p>Finally, the Jakarta Faces implementation transfers control to the Render Response phase.</p>
</div>
</div>
<div class="sect2">
<h3 id="_render_response_phase"><a class="anchor" href="#_render_response_phase"></a>Render Response Phase</h3>
<div class="paragraph">
<p>During this phase, Jakarta Faces builds the view and delegates authority to the appropriate resource for rendering the pages.</p>
</div>
<div class="paragraph">
<p>If this is an initial request, the components that are represented on the page will be added to the component tree.
If this is not an initial request, the components are already added to the tree and need not be added again.</p>
</div>
<div class="paragraph">
<p>If the request is a postback and errors were encountered during the Apply Request Values phase, Process Validations phase, or Update Model Values phase, the original page is rendered again during this phase.
If the pages contain <code>h:message</code> or <code>h:messages</code> tags, any queued error messages are displayed on the page.</p>
</div>
<div class="paragraph">
<p>After the content of the view is rendered, the state of the response is saved so that subsequent requests can access it.
The saved state is available to the Restore View phase.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_partial_processing_and_partial_rendering"><a class="anchor" href="#_partial_processing_and_partial_rendering"></a>Partial Processing and Partial Rendering</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Jakarta Faces lifecycle spans all of the execute and render processes of an application.
It is also possible to process and render only parts of an application, such as a single component.
For example, the Jakarta Faces Ajax framework can generate requests containing information on which particular component may be processed and which particular component may be rendered back to the client.</p>
</div>
<div class="paragraph">
<p>Once such a partial request enters the Jakarta Faces lifecycle, the information is identified and processed by a <code>jakarta.faces.context.PartialViewContext</code> object.
The Jakarta Faces lifecycle is still aware of such Ajax requests and modifies the component tree accordingly.</p>
</div>
<div class="paragraph">
<p>The <code>execute</code> and <code>render</code> attributes of the <code>f:ajax</code> tag are used to identify which components may be executed and rendered.
For more information on these attributes, see <a href="../faces-ajax/faces-ajax.html#_using_ajax_with_jakarta_faces_technology" class="xref page">Using Ajax with Jakarta Faces Technology</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_further_information_about_jakarta_faces_technology"><a class="anchor" href="#_further_information_about_jakarta_faces_technology"></a>Further Information about Jakarta Faces Technology</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For more information on Jakarta Faces technology, see</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Jakarta Faces 3.0 specification:<br>
<a href="https://jakarta.ee/specifications/faces/3.0/" class="bare" target="_blank" rel="noopener">https://jakarta.ee/specifications/faces/3.0/</a></p>
</li>
<li>
<p>Mojarra website:<br>
<a href="https://eclipse-ee4j.github.io/mojarra/" class="bare" target="_blank" rel="noopener">https://eclipse-ee4j.github.io/mojarra/</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For additional samples, see the GlassFish samples at <a href="https://github.com/eclipse-ee4j/glassfish-samples/tree/master/ws/jakartaee9" class="bare" target="_blank" rel="noopener">https://github.com/eclipse-ee4j/glassfish-samples/tree/master/ws/jakartaee9</a>.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../../../_/js/site.js" data-ui-root-path="../../../../_"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
