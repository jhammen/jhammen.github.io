<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Jakarta WebSocket :: Jakarta EE Documentation</title>
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../../_/css/site.css">
    <script>var uiRootPath = '../../../../_'</script>
    <script>!function (theme) {
        if (theme === 'dark') document.documentElement.classList.add('theme-dark')
      }(localStorage && localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)') && 'dark'))
    </script>
      </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a id="site-title" class="navbar-item" href="../../../..">Jakarta EE Documentation</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
<!--
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
 -->
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="../../../../jakartaee-tutorial/10/jakarta-ee-tutorial.pdf">Download</a>
          </span>
        </div>
      </div>
      <div class="navbar-theme-switcher">
        <span class="switch" title="Switch between Light and Dark Theme">
          <input id="theme-switcher-checkbox" type="checkbox" />
          <label for="theme-switcher-checkbox">Dark Theme</label>
        </span>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="jakartaee-tutorial" data-version="10">
  <div class="toolbar"></div>
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../../index.html">Jakarta EE Tutorial</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Introduction</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../index.html">Preface</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../intro/overview/overview.html">Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../intro/usingexamples/usingexamples.html">Using the Tutorial Examples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Core Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta CDI Lite</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-basic/cdi-basic.html">Introduction to Jakarta Contexts and Dependency Injection</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-basicexamples/cdi-basicexamples.html">Running the Basic Contexts and Dependency Injection Examples</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../supporttechs/interceptors/interceptors.html">Using Jakarta EE Interceptors</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta REST</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../websvcs/jaxrs/jaxrs.html">Building RESTful Web Services with Jakarta REST</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../websvcs/jaxrs-client/jaxrs-client.html">Accessing REST Resources with the Jakarta REST Client API</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../websvcs/jaxrs-advanced/jaxrs-advanced.html">Jakarta REST: Advanced Topics and an Example</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta JSON</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../jsonb/jsonb.html">JSON Binding</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../jsonp/jsonp.html">JSON Processing</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Web Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta CDI Full</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-adv/cdi-adv.html">Jakarta Contexts and Dependency Injection: Advanced Topics</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-bootstrap-se8/cdi-bootstrap-se8.html">Bootstrapping a CDI Container in Java SE</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../cdi/cdi-adv-examples/cdi-adv-examples.html">Running the Advanced Contexts and Dependency Injection Examples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Validation</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../beanvalidation/bean-validation/bean-validation.html">Introduction to Jakarta Bean Validation</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../beanvalidation/bean-validation-advanced/bean-validation-advanced.html">Bean Validation: Advanced Topics</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../security/security.html">Jakarta Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Servlets</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../webapp/webapp.html">Getting Started with Web Applications</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../servlets/servlets.html">Jakarta Servlet Technology</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Faces</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-intro/faces-intro.html">Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-facelets/faces-facelets.html">Introduction to Facelets</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-page/faces-page.html">Using Jakarta Faces Technology in Web Pages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-page-core/faces-page-core.html">Using Converters, Listeners, and Validators</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-develop/faces-develop.html">Developing with Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-ajax/faces-ajax.html">Using Ajax with Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-advanced-cc/faces-advanced-cc.html">Composite Components: Advanced Topics and an Example</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-custom/faces-custom.html">Creating Custom UI Components and Other Custom Objects</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-configure/faces-configure.html">Configuring Jakarta Faces Applications</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-ws/faces-ws.html">Using WebSockets with Jakarta Faces Technology</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../webi18n/webi18n.html">Internationalizing and Localizing Web Applications</a>
  </li>
</ul>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="websocket.html">Jakarta WebSocket</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Persistence</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-intro/persistence-intro.html">Introduction to Jakarta Persistence</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-basicexamples/persistence-basicexamples.html">Running the Persistence Examples</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-querylanguage/persistence-querylanguage.html">The Jakarta Persistence Query Language</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-criteria/persistence-criteria.html">Using the Criteria API to Create Queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-string-queries/persistence-string-queries.html">Creating and Using String-Based Criteria Queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-locking/persistence-locking.html">Controlling Concurrent Access to Entity Data with Locking</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-entitygraphs/persistence-entitygraphs.html">Creating Fetch Plans with Entity Graphs</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../persist/persistence-cache/persistence-cache.html">Using a Second-Level Cache with Jakarta Persistence Applications</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Enterprise Beans Lite</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-intro/ejb-intro.html">Enterprise Beans</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-gettingstarted/ejb-gettingstarted.html">Getting Started with Enterprise Beans</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-basicexamples/ejb-basicexamples.html">Running the Enterprise Bean Examples</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-async/ejb-async.html">Using Asynchronous Method Invocation in Session Beans</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Platform</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../messaging/mail-api/mail-api.html">Jakarta Mail</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta Messaging</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../messaging/jms-concepts/jms-concepts.html">Jakarta Messaging Concepts</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../messaging/jms-examples/jms-examples.html">Jakarta Messaging Examples</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../supporttechs/batch-processing/batch-processing.html">Jakarta Batch</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Advanced</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Web Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../security/security-authentication/security-authentication.html">Jakarta Authentication</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../security/security-authorization/security-authorization.html">Jakarta Authorization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../supporttechs/transactions/transactions.html">Jakarta Transactions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../supporttechs/concurrency-utilities/concurrency-utilities.html">Jakarta Concurrency</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Platform</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../supporttechs/connectors/connectors.html">Jakarta Connectors</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Optional Components</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../faces-el/faces-el.html">Jakarta Expression Language</a>
  </li>
  <li class="nav-item" data-depth="2">
    <span class="nav-text">Jakarta XML Binding</span>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Archived</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Web Profile</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../jakarta-pages/jakarta-pages.html">Jakarta Pages</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../jakarta-tags/jakarta-tags.html">Jakarta Tags</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jakarta EE Platform</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../websvcs/xml-websvcs/xml-websvcs.html">XML Web Services</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../entbeans/ejb-full/ejb-full.html">Jakarta Enterprise Beans Full</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Jakarta EE Tutorial</span>
    <span class="version">10</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../../index.html">Jakarta EE Tutorial</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../index.html">10</a>
        </li>
        <li class="version">
          <a href="../../../9.1/index.html">9.1</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../index.html">Jakarta EE Tutorial</a></li>
    <li>Jakarta EE Web Profile</li>
    <li><a href="websocket.html">Jakarta WebSocket</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">10</button>
  <div class="version-menu">
    <a class="version is-current" href="websocket.html">10</a>
    <a class="version" href="../../../9.1/web/websocket/websocket.html">9.1</a>
  </div>
</div>
  <div class="edit-this-page"><a href="file:///home/john/workspace/virtua/jakartaee-tutorial/src/main/antora/modules/web/pages/websocket/websocket.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Jakarta WebSocket</h1>
<div id="preamble">
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>We are working on a fresh, updated Jakarta EE Tutorial. This section hasn&#8217;t yet been updated.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This chapter describes Jakarta WebSocket, which provides support for creating WebSocket applications.
WebSocket is an application protocol that provides full-duplex communications between two peers over the TCP protocol.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction_to_websocket"><a class="anchor" href="#_introduction_to_websocket"></a>Introduction to WebSocket</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the traditional request-response model used in HTTP, the client requests resources, and the server provides responses.
The exchange is always initiated by the client; the server cannot send any data without the client requesting it first.
This model worked well for the World Wide Web when clients made occasional requests for documents that changed infrequently, but the limitations of this approach are increasingly relevant as content changes quickly and users expect a more interactive experience on the Web.
The WebSocket protocol addresses these limitations by providing a full-duplex communication channel between the client and the server.
Combined with other client technologies, such as JavaScript and HTML5, WebSocket enables web applications to deliver a richer user experience.</p>
</div>
<div class="paragraph">
<p>In a WebSocket application, the server publishes a WebSocket endpoint, and the client uses the endpoint&#8217;s URI to connect to the server.
The WebSocket protocol is symmetrical after the connection has been established; the client and the server can send messages to each other at any time while the connection is open, and they can close the connection at any time.
Clients usually connect only to one server, and servers accept connections from multiple clients.</p>
</div>
<div class="paragraph">
<p>The WebSocket protocol has two parts: handshake and data transfer.
The client initiates the handshake by sending a request to a WebSocket endpoint using its URI.
The handshake is compatible with existing HTTP-based infrastructure: web servers interpret it as an HTTP connection upgrade request.
An example handshake from a client looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-http hljs" data-lang="http">GET /path/to/websocket/endpoint HTTP/1.1
Host: localhost
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==
Origin: http://localhost
Sec-WebSocket-Version: 13</code></pre>
</div>
</div>
<div class="paragraph">
<p>An example handshake from the server in response to the client looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-http hljs" data-lang="http">HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=</code></pre>
</div>
</div>
<div class="paragraph">
<p>The server applies a known operation to the value of the <code>Sec-WebSocket-Key</code> header to generate the value of the <code>Sec-WebSocket-Accept</code> header.
The client applies the same operation to the value of the <code>Sec-WebSocket-Key</code> header, and the connection is established successfully if the result matches the value received from the server.
The client and the server can send messages to each other after a successful handshake.</p>
</div>
<div class="paragraph">
<p>WebSocket supports text messages (encoded as UTF-8) and binary messages.
The control frames in WebSocket are close, ping, and pong (a response to a ping frame).
Ping and pong frames may also contain application data.</p>
</div>
<div class="paragraph">
<p>WebSocket endpoints are represented by URIs that have the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">ws://host:port/path?query
wss://host:port/path?query</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ws</code> scheme represents an unencrypted WebSocket connection, and the <code>wss</code> scheme represents an encrypted connection.
The <code>port</code> component is optional; the default port number is 80 for unencrypted connections and 443 for encrypted connections.
The <code>path</code> component indicates the location of an endpoint within a server.
The <code>query</code> component is optional.</p>
</div>
<div class="paragraph">
<p>Modern web browsers implement the WebSocket protocol and provide a JavaScript API to connect to endpoints, send messages, and assign callback methods for WebSocket events (such as opened connections, received messages, and closed connections).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creating_websocket_applications_in_the_jakarta_ee_platform"><a class="anchor" href="#_creating_websocket_applications_in_the_jakarta_ee_platform"></a>Creating WebSocket Applications in the Jakarta EE Platform</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Jakarta EE platform includes Jakarta WebSocket, which enables you to create, configure, and deploy WebSocket endpoints in web applications.
The WebSocket client API specified in Jakarta WebSocket also enables you to access remote WebSocket endpoints from any Java application.</p>
</div>
<div class="paragraph">
<p>Jakarta WebSocket consists of the following packages.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>jakarta.websocket.server</code> package contains annotations, classes, and interfaces to create and configure server endpoints.</p>
</li>
<li>
<p>The <code>jakarta.websocket</code> package contains annotations, classes, interfaces, and exceptions that are common to client and server endpoints.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>WebSocket endpoints are instances of the <code>jakarta.websocket.Endpoint</code> class.
Jakarta WebSocket enables you to create two kinds of endpoints: programmatic endpoints and annotated endpoints.
To create a programmatic endpoint, you extend the <code>Endpoint</code> class and override its lifecycle methods.
To create an annotated endpoint, you decorate a Java class and some of its methods with the annotations provided by the packages mentioned previously.
After you have created an endpoint, you deploy it to an specific URI in the application so that remote clients can connect to it.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In most cases, it is easier to create and deploy an annotated endpoint than a programmatic endpoint.
This chapter provides a simple example of a programmatic endpoint, but it focuses on annotated endpoints.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_creating_and_deploying_a_websocket_endpoint"><a class="anchor" href="#_creating_and_deploying_a_websocket_endpoint"></a>Creating and Deploying a WebSocket Endpoint</h3>
<div class="paragraph">
<p>The process for creating and deploying a WebSocket endpoint:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Create an endpoint class.</p>
</li>
<li>
<p>Implement the lifecycle methods of the endpoint.</p>
</li>
<li>
<p>Add your business logic to the endpoint.</p>
</li>
<li>
<p>Deploy the endpoint inside a web application.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The process is slightly different for programmatic endpoints and annotated endpoints, and it is covered in detail in the following sections.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As opposed to servlets, WebSocket endpoints are instantiated multiple times.
The container creates an instance of an endpoint per connection to its deployment URI.
Each instance is associated with one and only one connection.
This facilitates keeping user state for each connection and makes development easier, because there is only one thread executing the code of an endpoint instance at any given time.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_programmatic_endpoints"><a class="anchor" href="#_programmatic_endpoints"></a>Programmatic Endpoints</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following example shows how to create an endpoint by extending the <code>Endpoint</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class EchoEndpoint extends Endpoint {
   @Override
   public void onOpen(final Session session, EndpointConfig config) {
      session.addMessageHandler(new MessageHandler.Whole&lt;String&gt;() {
         @Override
         public void onMessage(String msg) {
            try {
               session.getBasicRemote().sendText(msg);
            } catch (IOException e) { ... }
         }
      });
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This endpoint echoes every message received.
The <code>Endpoint</code> class defines three lifecycle methods: <code>onOpen</code>, <code>onClose</code>, and <code>onError</code>.
The <code>EchoEndpoint</code> class implements the <code>onOpen</code> method, which is the only abstract method in the <code>Endpoint</code> class.</p>
</div>
<div class="paragraph">
<p>The <code>Session</code> parameter represents a conversation between this endpoint and the remote endpoint.
The <code>addMessageHandler</code> method registers message handlers, and the <code>getBasicRemote</code> method returns an object that represents the remote endpoint.
The <code>Session</code> interface is covered in detail in the rest of this chapter.</p>
</div>
<div class="paragraph">
<p>The message handler is implemented as an anonymous inner class.
The <code>onMessage</code> method of the message handler is invoked when the endpoint receives a text message.</p>
</div>
<div class="paragraph">
<p>To deploy this programmatic endpoint, use the following code in your Jakarta EE application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ServerEndpointConfig.Builder.create(EchoEndpoint.class, "/echo").build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you deploy your application, the endpoint is available at <code>ws://&lt;host&gt;:&lt;port&gt;/&lt;application&gt;/echo</code>; for example, <code>ws://localhost:8080/echoapp/echo</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_annotated_endpoints"><a class="anchor" href="#_annotated_endpoints"></a>Annotated Endpoints</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following example shows how to create the same endpoint from <a href="#_programmatic_endpoints">Programmatic Endpoints</a> using annotations instead:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServerEndpoint("/echo")
public class EchoEndpoint {
   @OnMessage
   public void onMessage(Session session, String msg) {
      try {
         session.getBasicRemote().sendText(msg);
      } catch (IOException e) { ... }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The annotated endpoint is simpler than the equivalent programmatic endpoint, and it is deployed automatically with the application to the relative path defined in the <code>ServerEndpoint</code> annotation.
Instead of having to create an additional class for the message handler, this example uses the <code>OnMessage</code> annotation to designate the method invoked to handle messages.</p>
</div>
<div class="paragraph">
<p><a href="#_websocket_endpoint_lifecycle_annotations">WebSocket Endpoint Lifecycle Annotations</a> lists the annotations available in the <code>jakarta.websocket</code> package to designate the methods that handle lifecycle events.
The examples in the table show the most common parameters for these methods.
See the API reference for details on what combinations of parameters are allowed in each case.</p>
</div>
<table id="_websocket_endpoint_lifecycle_annotations" class="tableblock frame-all grid-all" style="width: 80%;">
<caption class="title">WebSocket Endpoint Lifecycle Annotations</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Annotation</th>
<th class="tableblock halign-left valign-top">Event</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OnOpen</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Connection opened</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@OnOpen
public void open(Session session,
                 EndpointConfig conf) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OnMessage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Message received</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@OnMessage
public void message(Session session,
                    String msg) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OnError</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Connection error</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@OnError
public void error(Session session,
                  Throwable error) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OnClose</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Connection closed</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@OnClose
public void close(Session session,
                  CloseReason reason) { }</code></pre>
</div>
</div>
<div class="paragraph">
<p></p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_sending_and_receiving_messages"><a class="anchor" href="#_sending_and_receiving_messages"></a>Sending and Receiving Messages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>WebSocket endpoints can send and receive text and binary messages.
In addition, they can also send ping frames and receive pong frames.
This section describes how to use the <code>Session</code> and <code>RemoteEndpoint</code> interfaces to send messages to the connected peer and how to use the <code>OnMessage</code> annotation to receive messages from it.</p>
</div>
<div class="sect2">
<h3 id="_sending_messages"><a class="anchor" href="#_sending_messages"></a>Sending Messages</h3>
<div class="paragraph">
<p>Follow these steps to send messages in an endpoint.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Obtain the <code>Session</code> object from the connection.</p>
<div class="paragraph">
<p>The <code>Session</code> object is available as a parameter in the annotated lifecycle methods of the endpoint, like those in <a href="#_websocket_endpoint_lifecycle_annotations">Websocket Endpoint Lifecycle Annotations</a>.
When your message is a response to a message from the peer, you have the <code>Session</code> object available inside the method that received the message (the method annotated with <code>@OnMessage</code>).
If you have to send messages that are not responses, store the <code>Session</code> object as an instance variable of the endpoint class in the method annotated with <code>@OnOpen</code> so that you can access it from other methods.</p>
</div>
</li>
<li>
<p>Use the <code>Session</code> object to obtain a <code>RemoteEndpoint</code> object.</p>
<div class="paragraph">
<p>The <code>Session.getBasicRemote</code> method and the <code>Session.getAsyncRemote</code> method return <code>RemoteEndpoint.Basic</code> and <code>RemoteEndpoint.Async</code> objects respectively.
The <code>RemoteEndpoint.Basic</code> interface provides blocking methods to send messages; the <code>RemoteEndpoint.Async</code> interface provides nonblocking methods.</p>
</div>
</li>
<li>
<p>Use the <code>RemoteEndpoint</code> object to send messages to the peer.</p>
<div class="paragraph">
<p>The following list shows some of the methods you can use to send messages to the peer.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>void RemoteEndpoint.Basic.sendText(String text)</code></p>
<div class="paragraph">
<p>Send a text message to the peer.
This method blocks until the whole message has been transmitted.</p>
</div>
</li>
<li>
<p><code>void RemoteEndpoint.Basic.sendBinary(ByteBuffer data)</code></p>
<div class="paragraph">
<p>Send a binary message to the peer.
This method blocks until the whole message has been transmitted.</p>
</div>
</li>
<li>
<p><code>void RemoteEndpoint.sendPing(ByteBuffer appData)</code></p>
<div class="paragraph">
<p>end a ping frame to the peer.</p>
</div>
</li>
<li>
<p><code>void RemoteEndpoint.sendPong(ByteBuffer appData)</code></p>
<div class="paragraph">
<p>Send a pong frame to the peer.</p>
</div>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>The example in <a href="#_annotated_endpoints">Annotated Endpoints</a> demonstrates how to use this procedure to reply to every incoming text message.</p>
</div>
<div class="sect3">
<h4 id="_sending_messages_to_all_peers_connected_to_an_endpoint"><a class="anchor" href="#_sending_messages_to_all_peers_connected_to_an_endpoint"></a>Sending Messages to All Peers Connected to an Endpoint</h4>
<div class="paragraph">
<p>Each instance of an endpoint class is associated with one and only one connection and peer; however, there are cases in which an endpoint instance needs to send messages to all connected peers.
Examples include chat applications and online auctions.
The <code>Session</code> interface provides the <code>getOpenSessions</code> method for this purpose.
The following example demonstrates how to use this method to forward incoming text messages to all connected peers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServerEndpoint("/echoall")
public class EchoAllEndpoint {
   @OnMessage
   public void onMessage(Session session, String msg) {
      try {
         for (Session sess : session.getOpenSessions()) {
            if (sess.isOpen())
               sess.getBasicRemote().sendText(msg);
         }
      } catch (IOException e) { ... }
   }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_receiving_messages"><a class="anchor" href="#_receiving_messages"></a>Receiving Messages</h3>
<div class="paragraph">
<p>The <code>OnMessage</code> annotation designates methods that handle incoming messages.
You can have at most three methods annotated with <code>@OnMessage</code> in an endpoint, one for each message type: text, binary, and pong.
The following example demonstrates how to designate methods to receive all three types of messages:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServerEndpoint("/receive")
public class ReceiveEndpoint {
   @OnMessage
   public void textMessage(Session session, String msg) {
      System.out.println("Text message: " + msg);
   }
   @OnMessage
   public void binaryMessage(Session session, ByteBuffer msg) {
      System.out.println("Binary message: " + msg.toString());
   }
   @OnMessage
   public void pongMessage(Session session, PongMessage msg) {
      System.out.println("Pong message: " +
                          msg.getApplicationData().toString());
   }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_maintaining_client_state"><a class="anchor" href="#_maintaining_client_state"></a>Maintaining Client State</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Because the container creates an instance of the endpoint class for every connection, you can define and use instance variables to store client state information.
In addition, the <code>Session.getUserProperties</code> method provides a modifiable map to store user properties.
For example, the following endpoint replies to incoming text messages with the contents of the previous message from each client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServerEndpoint("/delayedecho")
public class DelayedEchoEndpoint {
   @OnOpen
   public void open(Session session) {
      session.getUserProperties().put("previousMsg", " ");
   }
   @OnMessage
   public void message(Session session, String msg) {
      String prev = (String) session.getUserProperties()
                                    .get("previousMsg");
      session.getUserProperties().put("previousMsg", msg);
      try {
         session.getBasicRemote().sendText(prev);
      } catch (IOException e) { ... }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To store information common to all connected clients, you can use class (static) variables; however, you are responsible for ensuring thread-safe access to them.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_using_encoders_and_decoders"><a class="anchor" href="#_using_encoders_and_decoders"></a>Using Encoders and Decoders</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jakarta WebSocket provides support for converting between WebSocket messages and custom Java types using encoders and decoders.
An encoder takes a Java object and produces a representation that can be transmitted as a WebSocket message; for example, encoders typically produce JSON, XML, or binary representations.
A decoder performs the reverse function; it reads a WebSocket message and creates a Java object.</p>
</div>
<div class="paragraph">
<p>This mechanism simplifies WebSocket applications, because it decouples the business logic from the serialization and deserialization of objects.</p>
</div>
<div class="sect2">
<h3 id="_implementing_encoders_to_convert_java_objects_into_websocket_messages"><a class="anchor" href="#_implementing_encoders_to_convert_java_objects_into_websocket_messages"></a>Implementing Encoders to Convert Java Objects into WebSocket Messages</h3>
<div class="paragraph">
<p>The procedure to implement and use encoders in endpoints follows.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Implement one of the following interfaces:</p>
<div class="ulist">
<ul>
<li>
<p><code>Encoder.Text&lt;T&gt;</code> for text messages</p>
</li>
<li>
<p><code>Encoder.Binary&lt;T&gt;</code> for binary messages</p>
<div class="paragraph">
<p>These interfaces specify the <code>encode</code> method.
Implement an encoder class for each custom Java type that you want to send as a WebSocket message.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Add the names of your encoder implementations to the <code>encoders</code> optional parameter of the <code>ServerEndpoint</code> annotation.</p>
</li>
<li>
<p>Use the <code>sendObject(Object data)</code> method of the <code>RemoteEndpoint.Basic</code> or <code>RemoteEndpoint.Async</code> interfaces to send your objects as messages.
The container looks for an encoder that matches your type and uses it to convert the object to a WebSocket message.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For example, if you have two Java types (<code>MessageA</code> and <code>MessageB</code>) that you want to send as text messages, implement the <code>Encoder.Text&lt;MessageA&gt;</code> and <code>Encoder.Text&lt;MessageB&gt;</code> interfaces as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MessageATextEncoder implements Encoder.Text&lt;MessageA&gt; {
   @Override
   public void init(EndpointConfig ec) { }
   @Override
   public void destroy() { }
   @Override
   public String encode(MessageA msgA) throws EncodeException {
      // Access msgA's properties and convert to JSON text...
      return msgAJsonString;
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Implement <code>Encoder.Text&lt;MessageB&gt;</code> similarly.
Then, add the <code>encoders</code> parameter to the <code>ServerEndpoint</code> annotation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServerEndpoint(
   value = "/myendpoint",
   encoders = { MessageATextEncoder.class, MessageBTextEncoder.class }
)
public class EncEndpoint { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, you can send <code>MessageA</code> and <code>MessageB</code> objects as WebSocket messages using the <code>sendObject</code> method as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MessageA msgA = new MessageA(...);
MessageB msgB = new MessageB(...);
session.getBasicRemote.sendObject(msgA);
session.getBasicRemote.sendObject(msgB);</code></pre>
</div>
</div>
<div class="paragraph">
<p>As in this example, you can have more than one encoder for text messages and more than one encoder for binary messages.
Like endpoints, encoder instances are associated with one and only one WebSocket connection and peer, so there is only one thread executing the code of an encoder instance at any given time.</p>
</div>
</div>
<div class="sect2">
<h3 id="_implementing_decoders_to_convert_websocket_messages_into_java_objects"><a class="anchor" href="#_implementing_decoders_to_convert_websocket_messages_into_java_objects"></a>Implementing Decoders to Convert WebSocket Messages into Java Objects</h3>
<div class="paragraph">
<p>The procedure to implement and use decoders in endpoints follows.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Implement one of the following interfaces:</p>
<div class="ulist">
<ul>
<li>
<p><code>Decoder.Text&lt;T&gt;</code> for text messages</p>
</li>
<li>
<p><code>Decoder.Binary&lt;T&gt;</code> for binary messages</p>
<div class="paragraph">
<p>These interfaces specify the <code>willDecode</code> and <code>decode</code> methods.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Unlike with encoders, you can specify at most one decoder for binary messages and one decoder for text messages.
</td>
</tr>
</table>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Add the names of your decoder implementations to the <code>decoders</code> optional parameter of the <code>ServerEndpoint</code> annotation.</p>
</li>
<li>
<p>Use the <code>OnMessage</code> annotation in the endpoint to designate a method that takes your custom Java type as a parameter.
When the endpoint receives a message that can be decoded by one of the decoders you specified, the container calls the method annotated with <code>@OnMessage</code> that takes your custom Java type as a parameter if this method exists.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For example, if you have two Java types (<code>MessageA</code> and <code>MessageB</code>) that you want to send and receive as text messages, define them so that they extend a common class (<code>Message</code>).
Because you can only define one decoder for text messages, implement a decoder for the <code>Message</code> class as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MessageTextDecoder implements Decoder.Text&lt;Message&gt; {
   @Override
   public void init(EndpointConfig ec) { }
   @Override
   public void destroy() { }
   @Override
   public Message decode(String string) throws DecodeException {
      // Read message...
      if ( /* message is an A message */ )
         return new MessageA(...);
      else if ( /* message is a B message */ )
         return new MessageB(...);
   }
   @Override
   public boolean willDecode(String string) {
      // Determine if the message can be converted into either a
      // MessageA object or a MessageB object...
      return canDecode;
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, add the <code>decoder</code> parameter to the <code>ServerEndpoint</code> annotation as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServerEndpoint(
   value = "/myendpoint",
   encoders = { MessageATextEncoder.class, MessageBTextEncoder.class },
   decoders = { MessageTextDecoder.class }
)
public class EncDecEndpoint { ... }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, define a method in the endpoint class that receives <code>MessageA</code> and <code>MessageB</code> objects as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@OnMessage
public void message(Session session, Message msg) {
   if (msg instanceof MessageA) {
      // We received a MessageA object...
   } else if (msg instanceof MessageB) {
      // We received a MessageB object...
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like endpoints, decoder instances are associated with one and only one WebSocket connection and peer, so there is only one thread executing the code of a decoder instance at any given time.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_path_parameters"><a class="anchor" href="#_path_parameters"></a>Path Parameters</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>ServerEndpoint</code> annotation enables you to use URI templates to specify parts of an endpoint deployment URI as application parameters.
For example, consider this endpoint:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServerEndpoint("/chatrooms/{room-name}")
public class ChatEndpoint {
   ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the endpoint is deployed inside a web application called <code>chatapp</code> at a local Jakarta EE server in port 8080, clients can connect to the endpoint using any of the following URIs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">http://localhost:8080/chatapp/chatrooms/currentnews
http://localhost:8080/chatapp/chatrooms/music
http://localhost:8080/chatapp/chatrooms/cars
http://localhost:8080/chatapp/chatrooms/technology</code></pre>
</div>
</div>
<div class="paragraph">
<p>Annotated endpoints can receive path parameters as arguments in methods annotated with <code>@OnOpen</code>, <code>@OnMessage</code>, and <code>@OnClose</code>.
In this example, the endpoint uses the parameter in the <code>@OnOpen</code> method to determine which chat room the client wants to join:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServerEndpoint("/chatrooms/{room-name}")
public class ChatEndpoint {
   @OnOpen
   public void open(Session session,
                    EndpointConfig c,
                    @PathParam("room-name") String roomName) {
      // Add the client to the chat room of their choice ...
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The path parameters used as arguments in these methods can be strings, primitive types, or the corresponding wrapper types.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_handling_errors"><a class="anchor" href="#_handling_errors"></a>Handling Errors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To designate a method that handles errors in an annotated WebSocket endpoint, decorate it with <code>@OnError</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServerEndpoint("/testendpoint")
public class TestEndpoint {
   ...
   @OnError
   public void error(Session session, Throwable t) {
      t.printStackTrace();
      ...
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This method is invoked when there are connection problems, runtime errors from message handlers, or conversion errors when decoding messages.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_specifying_an_endpoint_configurator_class"><a class="anchor" href="#_specifying_an_endpoint_configurator_class"></a>Specifying an Endpoint Configurator Class</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Jakarta WebSocket enables you to configure how the container creates server endpoint instances.
You can provide custom endpoint configuration logic to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Access the details of the initial HTTP request for a WebSocket connection</p>
</li>
<li>
<p>Perform custom checks on the <code>Origin</code> HTTP header</p>
</li>
<li>
<p>Modify the WebSocket handshake response</p>
</li>
<li>
<p>Choose a WebSocket subprotocol from those requested by the client</p>
</li>
<li>
<p>Control the instantiation and initialization of endpoint instances</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To provide custom endpoint configuration logic, you extend the <code>ServerEndpointConfig.Configurator</code> class and override some of its methods.
In the endpoint class, you specify the configurator class using the <code>configurator</code> parameter of the <code>ServerEndpoint</code> annotation.</p>
</div>
<div class="paragraph">
<p>For example, the following configurator class makes the handshake request object available to endpoint instances:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class CustomConfigurator extends ServerEndpointConfig.Configurator {

    @Override
    public void modifyHandshake(ServerEndpointConfig conf,
                                HandshakeRequest req,
                                HandshakeResponse resp) {

        conf.getUserProperties().put("handshakereq", req);
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following endpoint class configures endpoint instances with the custom configurator, which enables them to access the handshake request object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServerEndpoint(
    value = "/myendpoint",
    configurator = CustomConfigurator.class
)
public class MyEndpoint {

    @OnOpen
    public void open(Session s, EndpointConfig conf) {
        HandshakeRequest req = (HandshakeRequest) conf.getUserProperties()
                                                      .get("handshakereq");
        Map&lt;String,List&lt;String&gt;&gt; headers = req.getHeaders();
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The endpoint class can use the handshake request object to access the details of the initial HTTP request, such as its headers or the <code>HttpSession</code> object.</p>
</div>
<div class="paragraph">
<p>For more information on endpoint configuration, see the API reference for the <code>ServerEndpointConfig.Configurator</code> class.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_dukeetf2_example_application"><a class="anchor" href="#_the_dukeetf2_example_application"></a>The dukeetf2 Example Application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>dukeetf2</code> example application, located in the <code><em>jakartaee-examples</em>/tutorial/web/websocket/dukeetf2/</code> directory, demonstrates how to use a WebSocket endpoint to provide data updates to web clients.
The example resembles a service that provides periodic updates on the price and trading volume of an electronically traded fund (ETF).</p>
</div>
<div class="sect2">
<h3 id="_architecture_of_the_dukeetf2_sample_application"><a class="anchor" href="#_architecture_of_the_dukeetf2_sample_application"></a>Architecture of the dukeetf2 Sample Application</h3>
<div class="paragraph">
<p>The <code>dukeetf2</code> example application consists of a WebSocket endpoint, an enterprise bean, and an HTML page.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The endpoint accepts connections from clients and sends them updates when new data for price and trading volume becomes available.</p>
</li>
<li>
<p>The enterprise bean updates the price and volume information once every second.</p>
</li>
<li>
<p>The HTML page uses JavaScript code to connect to the WebSocket endpoint, parse incoming messages, and update the price and volume information without reloading the page.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_the_endpoint"><a class="anchor" href="#_the_endpoint"></a>The Endpoint</h4>
<div class="paragraph">
<p>The WebSocket endpoint is implemented in the <code>ETFEndpoint</code> class, which stores all connected sessions in a queue and provides a method that the enterprise bean calls when there is new information available to send:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServerEndpoint("/dukeetf")
public class ETFEndpoint {
   private static final Logger logger = Logger.getLogger("ETFEndpoint");
   /* Queue for all open WebSocket sessions */
   static Queue&lt;Session&gt; queue = new ConcurrentLinkedQueue&lt;&gt;();

   /* PriceVolumeBean calls this method to send updates */
   public static void send(double price, int volume) {
      String msg = String.format("%.2f / %d", price, volume);
      try {
         /* Send updates to all open WebSocket sessions */
         for (Session session : queue) {
            session.getBasicRemote().sendText(msg);
            logger.log(Level.INFO, "Sent: {0}", msg);
         }
      } catch (IOException e) {
         logger.log(Level.INFO, e.toString());
      }
    }
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The lifecycle methods of the endpoint add and remove sessions to and from the queue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServerEndpoint("/dukeetf")
public class ETFEndpoint {
   ...
   @OnOpen
   public void openConnection(Session session) {
      /* Register this connection in the queue */
      queue.add(session);
      logger.log(Level.INFO, "Connection opened.");
   }

   @OnClose
   public void closedConnection(Session session) {
      /* Remove this connection from the queue */
      queue.remove(session);
      logger.log(Level.INFO, "Connection closed.");
   }

   @OnError
   public void error(Session session, Throwable t) {
      /* Remove this connection from the queue */
      queue.remove(session);
      logger.log(Level.INFO, t.toString());
      logger.log(Level.INFO, "Connection error.");
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_enterprise_bean"><a class="anchor" href="#_the_enterprise_bean"></a>The Enterprise Bean</h4>
<div class="paragraph">
<p>The enterprise bean uses the timer service to generate new price and volume information every second:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Startup
@Singleton
public class PriceVolumeBean {
   /* Use the container's timer service */
   @Resource TimerService tservice;
   private Random random;
   private volatile double price = 100.0;
   private volatile int volume = 300000;
   private static final Logger logger = Logger.getLogger("PriceVolumeBean");

   @PostConstruct
   public void init() {
       /* Initialize the EJB and create a timer */
       logger.log(Level.INFO, "Initializing EJB.");
       random = new Random();
       tservice.createIntervalTimer(1000, 1000, new TimerConfig());
   }

   @Timeout
   public void timeout() {
       /* Adjust price and volume and send updates */
       price += 1.0*(random.nextInt(100)-50)/100.0;
       volume += random.nextInt(5000) - 2500;
       ETFEndpoint.send(price, volume);
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The enterprise bean calls the <code>send</code> method of the <code>ETFEndpoint</code> class in the timeout method.
See <a href="../../entbeans/ejb-basicexamples/ejb-basicexamples.html#_using_the_timer_service" class="xref page">Using the Timer Service</a> in <a href="../../entbeans/ejb-basicexamples/ejb-basicexamples.html#_running_the_enterprise_bean_examples" class="xref page">Running the Enterprise Bean Examples</a> for more information on the timer service.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_html_page"><a class="anchor" href="#_the_html_page"></a>The HTML Page</h4>
<div class="paragraph">
<p>The HTML page consists of a table and some JavaScript code.
The table contains two fields referenced from JavaScript code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-html hljs" data-lang="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;...&lt;/head&gt;
&lt;body&gt;
  ...
  &lt;table&gt;
    ...
    &lt;td id="price"&gt;--.--&lt;/td&gt;
    ...
    &lt;td id="volume"&gt;--&lt;/td&gt;
    ...
  &lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The JavaScript code uses the WebSocket API to connect to the server endpoint and to designate a callback method for incoming messages.
The callback method updates the page with the new information.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">var wsocket;
function connect() {
   wsocket = new WebSocket("ws://localhost:8080/dukeetf2/dukeetf");
   wsocket.onmessage = onMessage;
}
function onMessage(evt) {
   var arraypv = evt.data.split("/");
   document.getElementById("price").innerHTML = arraypv[0];
   document.getElementById("volume").innerHTML = arraypv[1];
}
window.addEventListener("load", connect, false);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The WebSocket API is supported by most modern browsers, and it is widely used in HTML5 web client development.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_running_the_dukeetf2_example_application"><a class="anchor" href="#_running_the_dukeetf2_example_application"></a>Running the dukeetf2 Example Application</h3>
<div class="paragraph">
<p>This section describes how to run the <code>dukeetf2</code> example application using NetBeans IDE and from the command line.</p>
</div>
<div class="sect3">
<h4 id="_to_run_the_dukeetf2_example_application_using_netbeans_ide"><a class="anchor" href="#_to_run_the_dukeetf2_example_application_using_netbeans_ide"></a>To Run the dukeetf2 Example Application Using NetBeans IDE</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make sure that GlassFish Server has been started (see <a href="../../intro/usingexamples/usingexamples.html#_starting_and_stopping_glassfish_server" class="xref page">Starting and Stopping GlassFish Server</a>).</p>
</li>
<li>
<p>From the <strong>File</strong> menu, choose <strong>Open Project</strong>.</p>
</li>
<li>
<p>In the Open Project dialog box, navigate to:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">jakartaee-examples/tutorial/web/websocket</code></pre>
</div>
</div>
</li>
<li>
<p>Select the <code>dukeetf2</code> folder.</p>
</li>
<li>
<p>Click <strong>Open Project</strong>.</p>
</li>
<li>
<p>In the <strong>Projects</strong> tab, right-click the <code>dukeetf2</code> project and select <strong>Run</strong>.</p>
<div class="paragraph">
<p>This command builds and packages the application into a WAR file (<code>dukeetf2.war</code>) located in the <code>target/</code> directory, deploys it to the server, and launches a web browser window with the following URL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">http://localhost:8080/dukeetf2/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Open the same URL on a different web browser tab or window to see how both pages get price and volume updates simultaneously.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_to_run_the_dukeetf2_example_application_using_maven"><a class="anchor" href="#_to_run_the_dukeetf2_example_application_using_maven"></a>To Run the dukeetf2 Example Application Using Maven</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make sure that GlassFish Server has been started (see <a href="../../intro/usingexamples/usingexamples.html#_starting_and_stopping_glassfish_server" class="xref page">Starting and Stopping GlassFish Server</a>).</p>
</li>
<li>
<p>In a terminal window, go to:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">jakartaee-examples/tutorial/web/websocket/dukeetf2/</code></pre>
</div>
</div>
</li>
<li>
<p>Enter the following command to deploy the application:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">mvn install</code></pre>
</div>
</div>
</li>
<li>
<p>Open a web browser window and enter the following URL:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">http://localhost:8080/dukeetf2/</code></pre>
</div>
</div>
<div class="paragraph">
<p>Open the same URL on a different web browser tab or window to see how both pages get price and volume updates simultaneously.</p>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_websocketbot_example_application"><a class="anchor" href="#_the_websocketbot_example_application"></a>The websocketbot Example Application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>websocketbot</code> example application, located in the <code><em>jakartaee-examples</em>/tutorial/web/websocket/websocketbot/</code> directory, demonstrates how to use a WebSocket endpoint to implement a chat.
The example resembles a chat room in which many users can join and have a conversation.
Users can ask simple questions to a bot agent that is always available in the chat room.</p>
</div>
<div class="sect2">
<h3 id="_architecture_of_the_websocketbot_example_application"><a class="anchor" href="#_architecture_of_the_websocketbot_example_application"></a>Architecture of the websocketbot Example Application</h3>
<div class="paragraph">
<p>The <code>websocketbot</code> example application consists of the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#_the_cdi_bean">The CDI Bean</a>  A CDI bean (<code>BotBean</code>) that contains the logic for the bot agent to reply to messages</p>
</li>
<li>
<p><a href="#_the_websocket_endpoint">The WebSocket Endpoint</a>  A WebSocket endpoint (<code>BotEndpoint</code>) that implements the chat room</p>
</li>
<li>
<p><a href="#_the_application_messages">The Application Messages</a>  A set of classes (<code>Message</code>, <code>ChatMessage</code>, <code>InfoMessage</code>, <code>JoinMessage</code>, and <code>UsersMessage</code>) that represent application messages</p>
</li>
<li>
<p><a href="#_the_encoder_classes">The Encoder Classes</a>  A set of classes (<code>ChatMessageEncoder</code>, <code>InfoMessageEncoder</code>, <code>JoinMessageEncoder</code>, and <code>UsersMessageEncoder</code>) that encode application messages into WebSocket text messages as JSON data</p>
</li>
<li>
<p><a href="#_the_message_decoder">The Message Decoder</a>  A class (<code>MessageDecoder</code>) the parses WebSocket text messages as JSON data and decodes them into <code>JoinMessage</code> or <code>ChatMessage</code> objects</p>
</li>
<li>
<p><a href="#_the_html_page">The HTML Page</a>  An HTML page (<code>index.html</code>) that uses JavaScript code to implement the client for the chat room</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_the_cdi_bean"><a class="anchor" href="#_the_cdi_bean"></a>The CDI Bean</h4>
<div class="paragraph">
<p>The CDI bean (<code>BotBean</code>) is a Java class that contains the <code>respond</code> method.
This method compares the incoming chat message with a set of predefined questions and returns a chat response.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Named
public class BotBean {
    public String respond(String msg) { ... }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_websocket_endpoint"><a class="anchor" href="#_the_websocket_endpoint"></a>The WebSocket Endpoint</h4>
<div class="paragraph">
<p>The WebSocket endpoint (<code>BotEndpoint</code>) is an annotated endpoint that performs the following functions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Receives messages from clients</p>
</li>
<li>
<p>Forwards messages to clients</p>
</li>
<li>
<p>Maintains a list of connected clients</p>
</li>
<li>
<p>Invokes the bot agent functionality</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The endpoint specifies its deployment URI and the message encoders and decoders using the <code>ServerEndpoint</code> annotation.
The endpoint obtains an instance of the <code>BotBean</code> class and a managed executor service resource through dependency injection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ServerEndpoint(
   value = "/websocketbot",
   decoders = { MessageDecoder.class },
   encoders = { JoinMessageEncoder.class, ChatMessageEncoder.class,
                InfoMessageEncoder.class, UsersMessageEncoder.class }
)
/* There is a BotEndpoint instance per connection */
public class BotEndpoint {
   private static final Logger logger = Logger.getLogger("BotEndpoint");
   /* Bot functionality bean */
   @Inject private BotBean botbean;
   /* Executor service for asynchronous processing */
   @Resource(name="comp/DefaultManagedExecutorService")
   private ManagedExecutorService mes;

   @OnOpen
   public void openConnection(Session session) {
       logger.log(Level.INFO, "Connection opened.");
   }
   ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>message</code> method processes incoming messages from clients.
The decoder converts incoming text messages into <code>JoinMessage</code> or <code>ChatMessage</code> objects, which inherit from the <code>Message</code> class.
The <code>message</code> method receives a <code>Message</code> object as a parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@OnMessage
public void message(Session session, Message msg) {
   logger.log(Level.INFO, "Received: {0}", msg.toString());

   if (msg instanceof JoinMessage) {
      /* Add the new user and notify everybody */
      JoinMessage jmsg = (JoinMessage) msg;
      session.getUserProperties().put("name", jmsg.getName());
      session.getUserProperties().put("active", true);
      logger.log(Level.INFO, "Received: {0}", jmsg.toString());
      sendAll(session, new InfoMessage(jmsg.getName() +
              " has joined the chat"));
      sendAll(session, new ChatMessage("Duke", jmsg.getName(),
              "Hi there!!"));
      sendAll(session, new UsersMessage(this.getUserList(session)));

   } else if (msg instanceof ChatMessage) {
      /* Forward the message to everybody */
      ChatMessage cmsg = (ChatMessage) msg;
      logger.log(Level.INFO, "Received: {0}", cmsg.toString());
      sendAll(session, cmsg);
      if (cmsg.getTarget().compareTo("Duke") == 0) {
         /* The bot replies to the message */
         mes.submit(new Runnable() {
            @Override
            public void run() {
               String resp = botbean.respond(cmsg.getMessage());
               sendAll(session, new ChatMessage("Duke",
                       cmsg.getName(), resp));
            }
         });
      }
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the message is a join message, the endpoint adds the new user to the list and notifies all connected clients.
If the message is a chat message, the endpoint forwards it to all connected clients.</p>
</div>
<div class="paragraph">
<p>If a chat message is for the bot agent, the endpoint obtains a response using the <code>BotBean</code> instance and sends it to all connected clients.
The <code>sendAll</code> method is similar to the example in <a href="#_sending_messages_to_all_peers_connected_to_an_endpoint">Sending Messages to All Peers Connected to an Endpoint</a>.</p>
</div>
<div class="sect4">
<h5 id="_asynchronous_processing_and_concurrency_considerations"><a class="anchor" href="#_asynchronous_processing_and_concurrency_considerations"></a>Asynchronous Processing and Concurrency Considerations</h5>
<div class="paragraph">
<p>The WebSocket endpoint calls the <code>BotBean.respond</code> method to obtain a response from the bot.
In this example, this is a blocking operation; the user that sent the associated message would not be able to send or receive other chat messages until the operation completes.
To avoid this problem, the endpoint obtains an executor service from the container and executes the blocking operation in a different thread using the <code>ManagedExecutorService.submit</code> method from Concurrency Utilities for Jakarta EE.</p>
</div>
<div class="paragraph">
<p>Jakarta WebSocket specification requires that Jakarta EE implementations instantiate endpoint classes once per connection.
This facilitates the development of WebSocket endpoints, because you are guaranteed that only one thread is executing the code in a WebSocket endpoint class at any given time.
When you introduce a new thread in an endpoint, as in this example, you must ensure that variables and methods accessed by more than one thread are thread safe.
In this example, the code in <code>BotBean</code> is thread safe, and the <code>BotEndpoint.sendAll</code> method has been declared <code>synchronized</code>.</p>
</div>
<div class="paragraph">
<p>Refer to <a href="../../supporttechs/concurrency-utilities/concurrency-utilities.html#_jakarta_concurrency" class="xref page">Jakarta Concurrency</a> for more information on the managed executor service and Concurrency Utilities for Jakarta EE.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_application_messages"><a class="anchor" href="#_the_application_messages"></a>The Application Messages</h4>
<div class="paragraph">
<p>The classes that represent application messages (<code>Message</code>, <code>ChatMessage</code>, <code>InfoMessage</code>, <code>JoinMessage</code>, and <code>UsersMessage</code>) contain only properties and getter and setter methods.
For example, the <code>ChatMessage</code> class looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ChatMessage extends Message {
    private String name;
    private String target;
    private String message;
    /* ... Constructor, getters, and setters ... */
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_encoder_classes"><a class="anchor" href="#_the_encoder_classes"></a>The Encoder Classes</h4>
<div class="paragraph">
<p>The encoder classes convert application message objects into JSON text using the Java API for JSON Processing.
For example, the <code>ChatMessageEncoder</code> class is implemented as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/* Encode a ChatMessage as JSON.
 * For example, (new ChatMessage("Peter","Duke","How are you?"))
 * is encoded as follows:
 * {"type":"chat","target":"Duke","message":"How are you?"}
 */
public class ChatMessageEncoder implements Encoder.Text&lt;ChatMessage&gt; {
   @Override
   public void init(EndpointConfig ec) { }
   @Override
   public void destroy() { }
   @Override
   public String encode(ChatMessage chatMessage) throws EncodeException {
      // Access properties in chatMessage and write JSON text...
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="../jsonp/jsonp.html#_json_processing" class="xref page">JSON Processing</a> for more information on the Jakarta JSON Processing.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_message_decoder"><a class="anchor" href="#_the_message_decoder"></a>The Message Decoder</h4>
<div class="paragraph">
<p>The message decoder (<code>MessageDecoder</code>) class converts WebSocket text messages into application messages by parsing JSON text.
It is implemented as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">/* Decode a JSON message into a JoinMessage or a ChatMessage.
 * For example, the incoming message
 * {"type":"chat","name":"Peter","target":"Duke","message":"How are you?"}
 * is decoded as (new ChatMessage("Peter", "Duke", "How are you?"))
 */
public class MessageDecoder implements Decoder.Text&lt;Message&gt; {
    /* Stores the name-value pairs from a JSON message as a Map */
    private Map&lt;String,String&gt; messageMap;

    @Override
    public void init(EndpointConfig ec) { }
    @Override
    public void destroy() { }

    /* Create a new Message object if the message can be decoded */
    @Override
    public Message decode(String string) throws DecodeException {
       Message msg = null;
       if (willDecode(string)) {
          switch (messageMap.get("type")) {
             case "join":
                msg = new JoinMessage(messageMap.get("name"));
                break;
             case "chat":
                msg = new ChatMessage(messageMap.get("name"),
                                      messageMap.get("target"),
                                      messageMap.get("message"));
          }
       } else {
          throw new DecodeException(string, "[Message] Can't decode.");
       }
       return msg;
   }

   /* Decode a JSON message into a Map and check if it contains
    * all the required fields according to its type. */
   @Override
   public boolean willDecode(String string) {
      // Convert JSON data from the message into a name-value map...
      // Check if the message has all the fields for its message type...
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_the_html_page_2"><a class="anchor" href="#_the_html_page_2"></a>The HTML Page</h4>
<div class="paragraph">
<p>The HTML page (<code>index.html</code>) contains a field for the user name.
After the user types a name and clicks Join, three text areas are available: one to type and send messages, one for the chat room, and one with the list of users.
The page also contains a WebSocket console that shows the messages sent and received as JSON text.</p>
</div>
<div class="paragraph">
<p>The JavaScript code on the page uses the WebSocket API to connect to the endpoint, send messages, and designate callback methods.
The WebSocket API is supported by most modern browsers and is widely used for web client development with HTML5.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_running_the_websocketbot_example_application"><a class="anchor" href="#_running_the_websocketbot_example_application"></a>Running the websocketbot Example Application</h3>
<div class="paragraph">
<p>This section describes how to run the <code>websocketbot</code> example application using NetBeans IDE and from the command line.</p>
</div>
<div class="sect3">
<h4 id="_to_run_the_websocketbot_example_application_using_netbeans_ide"><a class="anchor" href="#_to_run_the_websocketbot_example_application_using_netbeans_ide"></a>To Run the websocketbot Example Application Using NetBeans IDE</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make sure that GlassFish Server has been started (see <a href="../../intro/usingexamples/usingexamples.html#_starting_and_stopping_glassfish_server" class="xref page">Starting and Stopping GlassFish Server</a>).</p>
</li>
<li>
<p>From the <strong>File</strong> menu, choose <strong>Open Project</strong>.</p>
</li>
<li>
<p>In the Open Project dialog box, navigate to:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">jakartaee-examples/tutorial/web/websocket</code></pre>
</div>
</div>
</li>
<li>
<p>Select the <code>websocketbot</code> folder.</p>
</li>
<li>
<p>Click <strong>Open Project</strong>.</p>
</li>
<li>
<p>In the <strong>Projects</strong> tab, right-click the <code>websocketbot</code> project and select <strong>Run</strong>.</p>
<div class="paragraph">
<p>This command builds and packages the application into a WAR file, <code>websocketbot.war</code>, located in the <code>target/</code> directory; deploys it to the server; and launches a web browser window with the following URL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">http://localhost:8080/websocketbot/</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#_to_test_the_websocketbot_example_application">To Test the websocketbot Example Application</a> for more information.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_to_run_the_websocketbot_example_application_using_maven"><a class="anchor" href="#_to_run_the_websocketbot_example_application_using_maven"></a>To Run the websocketbot Example Application Using Maven</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Make sure that GlassFish Server has been started (see <a href="../../intro/usingexamples/usingexamples.html#_starting_and_stopping_glassfish_server" class="xref page">Starting and Stopping GlassFish Server</a>).</p>
</li>
<li>
<p>In a terminal window, go to:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">jakartaee-examples/tutorial/web/websocket/websocketbot/</code></pre>
</div>
</div>
</li>
<li>
<p>Enter the following command to deploy the application:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">mvn install</code></pre>
</div>
</div>
</li>
<li>
<p>Open a web browser window and type the following address:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">http://localhost:8080/websocketbot/</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#_to_test_the_websocketbot_example_application">To Test the websocketbot Example Application</a> for more information.</p>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_to_test_the_websocketbot_example_application"><a class="anchor" href="#_to_test_the_websocketbot_example_application"></a>To Test the websocketbot Example Application</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>On the main page, type your name on the first text field and press the Enter key.</p>
<div class="paragraph">
<p>The list of connected users appears on the text area on the right.
The text area on the left is the chat room.</p>
</div>
</li>
<li>
<p>Type a message on the text area below the login button.
For example, type the messages in bold and press enter to obtain responses similar to the following:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-asciidoc hljs" data-lang="asciidoc">[--Peter has joined the chat--]
Duke: @Peter Hi there!!
Peter: @Duke how are you?
Duke: @Peter I'm doing great, thank you!
Peter: @Duke when is your birthday?
Duke: @Peter My birthday is on May 23rd. Thanks for asking!</code></pre>
</div>
</div>
</li>
<li>
<p>Join the chat from another browser window by copying and pasting the URI on the address bar and joining with a different name.</p>
<div class="paragraph">
<p>The new user name appears in the list of users in both browser windows.
You can send messages from either window and see how they appear in the other.</p>
</div>
</li>
<li>
<p>Click Show WebSocket Console.</p>
<div class="paragraph">
<p>The console shows the messages sent and received as JSON text.</p>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_further_information_about_websocket"><a class="anchor" href="#_further_information_about_websocket"></a>Further Information about WebSocket</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For more information on WebSocket in Jakarta EE, see the Jakarta WebSocket specification:</p>
</div>
<div class="paragraph">
<p><a href="https://jakarta.ee/specifications/websocket/2.0/" class="bare" target="_blank" rel="noopener">https://jakarta.ee/specifications/websocket/2.0/</a></p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../../../_/js/site.js" data-ui-root-path="../../../../_"></script>
<script async src="../../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
